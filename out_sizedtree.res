
  EXPLORED Args.parser output 
 EXPLORED learningOn  true
 EXPLORED bidirectionality  true
 EXPLORED effect-filter  false
 EXPLORED specfile :: tests_specsynth/sizedtree_quant.spec
 EXPLORED goal Number :: 0
 EXPLORED Max path length :: 4stexcwhitespace var: tlen
whitespace colon
whitespace var: tree
whitespace colon
whitespace var: int
semicolon
var: dummy
whitespace colon
whitespace lcurly
var: v
whitespace colon
whitespace var: unit
whitespace pipe
whitespace truercurly
semicolon
var: leaf
whitespace colon
whitespace lcurly
var: v
whitespace colon
whitespace var: tree
whitespace pipe
whitespace var: tlen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace int: 0
rcurly
semicolon
var: node
whitespace colon
whitespace lparen
var: root
whitespace colon
whitespace lcurly
var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace lparen
lbrace
var: v
lessthanopint: 0
rbrace
whitespace disjwhitespace lbrace
var: v
equalopint: 0
rbrace
rparen
rcurly
rparen
whitespace arrow
whitespace lparen
var: sizel
whitespace colon
whitespace lcurly
var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace truercurly
rparen
whitespace arrow
whitespace whitespace lparen
var: ltree
whitespace colon
whitespace lcurly
var: v
whitespace colon
whitespace var: tree
whitespace pipe
whitespace lambdalparen
var: u
colon
var: int
rparen
dotwhitespace whitespace var: tlen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: sizel
rcurly
rparen
whitespace arrow
whitespace whitespace lparen
var: sizer
whitespace colon
whitespace lcurly
var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace truercurly
rparen
whitespace arrow
whitespace whitespace lparen
var: rtree
whitespace colon
whitespace lcurly
var: v
whitespace colon
whitespace var: tree
whitespace pipe
whitespace lambdalparen
var: u
colon
var: int
rparen
dotwhitespace whitespace var: tlen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: sizer
rcurly
rparen
whitespace arrow
whitespace lcurly
var: v
colon
whitespace var: tree
whitespace pipe
whitespace lambdalparen
var: u
whitespace colon
whitespace var: int
rparen
dotwhitespace lparen
var: u
whitespace equalopwhitespace var: sizel
whitespace pluswhitespace int: 1
rparen
whitespace implieswhitespace lparen
var: tlen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: u
rparen
rcurly
semicolon
whitespace var: sizecheck
whitespace colon
whitespace lparen
var: s
whitespace colon
whitespace var: int
rparen
whitespace arrow
whitespace whitespace lcurly
var: v
whitespace colon
whitespace var: bool
whitespace pipe
whitespace lbrace
var: v
equaloptruerbrace
whitespace iffwhitespace lbrace
var: s
equalopint: 0
rbrace
whitespace conjwhitespace whitespace lbrace
var: v
equalopfalserbrace
whitespace iffwhitespace lbrace
var: s
lessthanopint: 0
rbrace
rcurly
semicolon
var: int_gen
whitespace colon
whitespace lparen
var: d
colon
var: unit
rparen
whitespace arrow
whitespace lcurly
whitespace var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace lparen
lbrace
var: v
lessthanopint: 0
rbrace
whitespace disjwhitespace lbrace
var: v
equalopint: 0
rbrace
rparen
rcurly
semicolon
whitespace var: subs
whitespace colon
whitespace lparen
var: n
whitespace colon
whitespace lcurly
var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace truercurly
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace var: v
whitespace equalopwhitespace var: n
whitespace ar-minuswhitespace int: 1
rcurly
semicolon
var: goal
whitespace colon
whitespace lparen
var: s0
whitespace colon
whitespace lcurly
whitespace var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace truercurly
whitespace rparen
whitespace arrow
whitespace whitespace lcurly
var: v
whitespace colon
whitespace var: tree
whitespace pipe
whitespace lambdalparen
var: u
colon
var: int
rparen
dotwhitespace whitespace lparen
var: tlen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: u
rparen
whitespace implieswhitespace lbrace
var: u
whitespace equalopwhitespace var: s0
rbrace
rcurly
semicolon
RelSpec {  SRs ;  PRs ;  TSs  
 Assume false
 name dummy : 
 params :
 Type {v:Ty_unit | true} 
 Assume false
 name leaf : 
 params :
 Type {v:Ty_alphatree | (tlen)(v) ==(0)} 
 Assume false
 name node : 
 params :
 Type  Arrow ( ( root : {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } ) ->  Arrow ( ( sizel : {v:Ty_int | true} ) ->  Arrow ( ( ltree : {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} ) ->  Arrow ( ( sizer : {v:Ty_int | true} ) ->  Arrow ( ( rtree : {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} ) -> {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((sizel) + (1))
 	 (tlen)(v) ==(u) > }} 
 Assume false
 name sizecheck : 
 params :
 Type  Arrow ( ( s : {var_v0:Ty_int | true} ) -> {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c s = 0
 	 , DoubleImpl 
 v = false
  s > 0 >c } 
 Assume false
 name int_gen : 
 params :
 Type  Arrow ( ( d : {var_v1:Ty_unit | true} ) -> {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } 
 Assume false
 name subs : 
 params :
 Type  Arrow ( ( n : {v:Ty_int | true} ) -> {v:Ty_int | (v) ==((n) -- (1))} 
 Assume false
 name goal : 
 params :
 Type  Arrow ( ( s0 : {v:Ty_int | true} ) -> {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (tlen)(v) ==(u)
 	 u = s0 > }};  Formulas  }
 INITIAL GAMMA 
 
 goal :  Arrow ( ( s0 : {v:Ty_int | true} ) -> {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (tlen)(v) ==(u)
 	 u = s0 > }}
 subs :  Arrow ( ( n : {v:Ty_int | true} ) -> {v:Ty_int | (v) ==((n) -- (1))}
 int_gen :  Arrow ( ( d : {var_v1:Ty_unit | true} ) -> {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }
 sizecheck :  Arrow ( ( s : {var_v0:Ty_int | true} ) -> {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c s = 0
 	 , DoubleImpl 
 v = false
  s > 0 >c }
 node :  Arrow ( ( root : {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } ) ->  Arrow ( ( sizel : {v:Ty_int | true} ) ->  Arrow ( ( ltree : {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} ) ->  Arrow ( ( sizer : {v:Ty_int | true} ) ->  Arrow ( ( rtree : {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} ) -> {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((sizel) + (1))
 	 (tlen)(v) ==(u) > }}
 leaf : {v:Ty_alphatree | (tlen)(v) ==(0)}
 dummy : {v:Ty_unit | true}
 INITIAL SIGMA 
 
 TypeNames 
 
 Qualifiers 
 
 Qual tlen :  :-> Ty_alphatree :-> Ty_int
 Show ***********Calling S-FUNC synthesize***************
 Show Uncurried , s0:{v:Ty_int | true} -> {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (tlen)(v) ==(u)
 	 u = s0 > }}
 Decreasing Measure s0
 Decreasing Type {v:Ty_int | true}
 Calculated Decreasing Predicate s0 > v
 Calculated Decreased Goal Type  Arrow ( ( s01 : {v:Ty_int | 
 	 Conj <c true
 	 , s0 > v >c } ) -> {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (tlen)(v) ==(u)
 	 u = s01 > }}
 Show Trying :: Top-level Match
 Show :: Synthesize Match {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (tlen)(v) ==(u)
 	 u = s0 > }}
 Show :: List Ty_int
 Show :: Non List Case
 Match-case failed :: Try Top-level If-then-else 
 **********************************************
 iSynthesize If-THEN-ELSE {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (tlen)(v) ==(u)
 	 u = s0 > }}
 **********************************************
  *********************Synthesizing the Guard*******************
 iSynthesize Boolean Guard {var_v2:Ty_bool | true}
  *********************Synthesizing the Guard*******************
 esynthesizeScalar for {var_v2:Ty_bool | true}
 >>>>>>>>>>>>>>>>>> No Scalar found in Environment, Trying esynthesizePureApp <<<<<<<<<<<<<<<<<< 
  Entering Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  , 
 sizecheck
 ############################################################
  Synthesizing the Function application Pure Component sizecheck
 ############################################################
  *************** Trying Arrow Component ************sizecheck :  Arrow ( ( s : {var_v0:Ty_int | true} ) -> {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c s = 0
 	 , DoubleImpl 
 v = false
  s > 0 >c }
  *************** Synthesizing Args ei : ti for ************sizecheck
 ##################################################################################
  Synthesizing the 1th argument for Function sizecheck
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v0:Ty_int | true}
 
 Enumerating a Scalar Term s0
 
 Type of the Scalar Term {v:Ty_int | true}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  , 
 subs, 
 int_gen
 ############################################################
  Synthesizing the Function application Pure Component subs
 ############################################################
  *************** Trying Arrow Component ************subs :  Arrow ( ( n : {v:Ty_int | true} ) -> {v:Ty_int | (v) ==((n) -- (1))}
  *************** Synthesizing Args ei : ti for ************subs
 ##################################################################################
  Synthesizing the 1th argument for Function subs
  Trying Arguments in Scalars 
 esynthesizeScalar for {v:Ty_int | true}
 
 Enumerating a Scalar Term s0
 
 Type of the Scalar Term {v:Ty_int | true}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  , 
 subs, 
 int_gen
 ############################################################
  Synthesizing the Function application Pure Component subs
 ############################################################
 ############################################################
  Synthesizing the Function application Pure Component int_gen
 ############################################################
  *************** Trying Arrow Component ************int_gen :  Arrow ( ( d : {var_v1:Ty_unit | true} ) -> {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }
  *************** Synthesizing Args ei : ti for ************int_gen
 ##################################################################################
  Synthesizing the 1th argument for Function int_gen
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v1:Ty_unit | true}
 
 Enumerating a Scalar Term dummy
 
 Type of the Scalar Term {v:Ty_unit | true}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>> 1th Args option for int_gen : dummy
 TEST Overall List : List of Args for int_gen
 EI dummy
 ##################################################################################
  *************** Successfully Synthesized Args ei Forall i 
 Ith Argument Options for int_gen
 EI dummy
 # of Possible Argument Options for int_gen 1
 Possible Arg Options 
 EI dummy
 Apply Single Argument Case : f (ei) Case int_gen
  Case : f (ei) Case int_gen dummy
 Finding Already seen tree for apply int_gen  (, dummy )
 Typechecking the Term apply int_gen  (, dummy )
 Against {v:Ty_int | true}
 Argument dummy :: {v:Ty_unit | true} | true
 AppType Type {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
  Show *************** TypeChecking Succsessful {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 let _lbv0 = apply int_gen  (, dummy )
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 >>>>>>>>>>>>>>>>>>> 1th Args option for subs : s0
 >>>>>>>>>>>>>>>>>>> 1th Args option for subs : apply int_gen  (, dummy )
 TEST Overall List : List of Args for subs
 EI s0
 EI apply int_gen  (, dummy )
 ##################################################################################
  *************** Successfully Synthesized Args ei Forall i 
 Ith Argument Options for subs
 EI s0
 EI apply int_gen  (, dummy )
 # of Possible Argument Options for subs 2
 Possible Arg Options 
 EI s0
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 Apply Single Argument Case : f (ei) Case subs
  Case : f (ei) Case subs s0
 Finding Already seen tree for apply subs  (, s0 )
 Typechecking the Term apply subs  (, s0 )
 Against {var_v0:Ty_int | true}
 Argument s0 :: {v:Ty_int | true} | true
 AppType Type {v:Ty_int | (v) ==((s0) -- (1))}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
  Show *************** TypeChecking Succsessful {v:Ty_int | (v) ==((s0) -- (1))}
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 let _lbv1 = apply subs  (, s0 )
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  Case : f (ei) Case subs _lbv0
 Finding Already seen tree for apply subs  (, _lbv0 )
 Typechecking the Term apply subs  (, _lbv0 )
 Against {var_v0:Ty_int | true}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 AppType Type {v:Ty_int | (v) ==((_lbv0) -- (1))}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
  Show *************** TypeChecking Succsessful {v:Ty_int | (v) ==((_lbv0) -- (1))}
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 let _lbv2 = apply subs  (, _lbv0 )
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 >>>>>>>>>>>>>>>>>>> 1th Args option for sizecheck : s0
 >>>>>>>>>>>>>>>>>>> 1th Args option for sizecheck : apply subs  (, apply int_gen  (, dummy ) )
 >>>>>>>>>>>>>>>>>>> 1th Args option for sizecheck : apply subs  (, s0 )
 TEST Overall List : List of Args for sizecheck
 EI s0
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI apply subs  (, s0 )
 ##################################################################################
  *************** Successfully Synthesized Args ei Forall i 
 Ith Argument Options for sizecheck
 EI s0
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI apply subs  (, s0 )
 # of Possible Argument Options for sizecheck 3
 Possible Arg Options 
 EI s0
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 Possible Arg Options 
 EI apply subs  (, s0 )
 Apply Single Argument Case : f (ei) Case sizecheck
  Case : f (ei) Case sizecheck s0
 Finding Already seen tree for apply sizecheck  (, s0 )
 Typechecking the Term apply sizecheck  (, s0 )
 Against {var_v2:Ty_bool | true}
 Argument s0 :: {v:Ty_int | true} | true
 AppType Type {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c s0 = 0
 	 , DoubleImpl 
 v = false
  s0 > 0 >c }
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
  Show *************** TypeChecking Succsessful {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c s0 = 0
 	 , DoubleImpl 
 v = false
  s0 > 0 >c }
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 let _lbv3 = apply sizecheck  (, s0 )
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  Case : f (ei) Case sizecheck _lbv2
 Finding Already seen tree for apply sizecheck  (, _lbv2 )
 Typechecking the Term apply sizecheck  (, _lbv2 )
 Against {var_v2:Ty_bool | true}
 Argument _lbv2 :: {v:Ty_int | (v) ==((_lbv0) -- (1))} | (_lbv2) ==((_lbv0) -- (1))
 AppType Type {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c _lbv2 = 0
 	 , DoubleImpl 
 v = false
  _lbv2 > 0 >c }
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
  Show *************** TypeChecking Succsessful {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c _lbv2 = 0
 	 , DoubleImpl 
 v = false
  _lbv2 > 0 >c }
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 let _lbv4 = apply sizecheck  (, _lbv2 )
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  Case : f (ei) Case sizecheck _lbv1
 Finding Already seen tree for apply sizecheck  (, _lbv1 )
 Typechecking the Term apply sizecheck  (, _lbv1 )
 Against {var_v2:Ty_bool | true}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 AppType Type {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c _lbv1 = 0
 	 , DoubleImpl 
 v = false
  _lbv1 > 0 >c }
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
  Show *************** TypeChecking Succsessful {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c _lbv1 = 0
 	 , DoubleImpl 
 v = false
  _lbv1 > 0 >c }
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 let _lbv5 = apply sizecheck  (, _lbv1 )
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 Show :: Synthesizing The IF-THEN-ELSE for Next Boolean Guard apply sizecheck  (, s0 )
  *********************Synthesizing the True branch*******************
 Show :: True Predicate 
 	 Conj <c var_v3 = true
 	 , DoubleImpl 
 var_v3 = true
  
 	 Conj <c s0 = 0
 	 , DoubleImpl 
 var_v3 = false
  s0 > 0 >c  >c 
 Show ***********Calling Scalar synthesize***************
 esynthesizeScalar for {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (tlen)(v) ==(u)
 	 u = s0 > }}
 
 Enumerating a Scalar Term leaf
 
 Type of the Scalar Term {v:Ty_alphatree | (tlen)(v) ==(0)}                                                                                                                                          
# of Final Z3 expressions 24
 Final solver 
 (declare-sort T14)
(declare-fun |0| () Int)
(declare-fun _lbv0 () Int)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv2 () Int)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv5 () Bool)
(declare-fun var_v3 () Bool)
(declare-fun tlen (T14) Int)
(declare-fun leaf () T14)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (or (> _lbv0 |0|) (= _lbv0 |0|)))
(assert (= _lbv1 (- s0 1)))
(assert (= _lbv2 (- _lbv0 1)))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv4 true) (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv5 true) (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= var_v3 true) (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|)))))
(assert (= (tlen leaf) 0))
(assert (= var_v3 true))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= var_v3 true) (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|)))))
(assert (= (tlen leaf) 0))
(assert (let ((a!1 (forall ((var_u4 Int)) (=> (= (tlen leaf) var_u4) (= var_u4 s0)))))
  (not a!1)))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Show :: Found a Few Macthing Scalars 
 *********************************************
 True Branch :: Successfully Synthesisized
 *********************************************
 if apply sizecheck  (, s0 )
 	 then 
 ***********
 leaf
 *********************************************
 ************ Synthesize False Branch**************
 *********************************************
 False Branch :: Trying False Branch
 Show :: Synthesizing the false branch
 Show :: False Predicate 
 	 Conj <c var_v3 = false
 	 , DoubleImpl 
 var_v3 = true
  
 	 Conj <c s0 = 0
 	 , DoubleImpl 
 var_v3 = false
  s0 > 0 >c  >c 
 Show ***********Calling Scalar synthesize***************
 esynthesizeScalar for {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (tlen)(v) ==(u)
 	 u = s0 > }}
 
 Enumerating a Scalar Term leaf
 
 Type of the Scalar Term {v:Ty_alphatree | (tlen)(v) ==(0)}                                                                                                                                          
# of Final Z3 expressions 24
 Final solver 
 (declare-sort T20)
(declare-fun |0| () Int)
(declare-fun _lbv0 () Int)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv2 () Int)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv5 () Bool)
(declare-fun var_v3 () Bool)
(declare-fun tlen (T20) Int)
(declare-fun leaf () T20)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (or (> _lbv0 |0|) (= _lbv0 |0|)))
(assert (= _lbv1 (- s0 1)))
(assert (= _lbv2 (- _lbv0 1)))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv4 true) (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv5 true) (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= var_v3 true) (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|)))))
(assert (= (tlen leaf) 0))
(assert (= var_v3 false))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= var_v3 true) (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|)))))
(assert (= (tlen leaf) 0))
(assert (let ((a!1 (forall ((var_u5 Int)) (=> (= (tlen leaf) var_u5) (= var_u5 s0)))))
  (not a!1)))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 
 FaileD the subtype check T_vi <: T_goal
 >>>>>>>>>>>>>>>>>> No Scalar found in Environment, Trying esynthesizePureApp <<<<<<<<<<<<<<<<<< 
  Entering Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  , 
 goal, 
 node
 ############################################################
  Synthesizing the Function application Pure Component goal
 ############################################################
  *************** Trying Arrow Component ************goal :  Arrow ( ( s01 : {v:Ty_int | 
 	 Conj <c true
 	 , s0 > v >c } ) -> {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (tlen)(v) ==(u)
 	 u = s01 > }}
  *************** Synthesizing Args ei : ti for ************goal
 ##################################################################################
  Synthesizing the 1th argument for Function goal
  Trying Arguments in Scalars 
 esynthesizeScalar for {v:Ty_int | 
 	 Conj <c true
 	 , s0 > v >c }
 
 Enumerating a Scalar Term s0
 
 Type of the Scalar Term {v:Ty_int | true}                                                                                                                                         
# of Final Z3 expressions 23
 Final solver 
 (declare-sort T25)
(declare-fun tlen (T25) Int)
(declare-fun leaf () T25)
(declare-fun |0| () Int)
(declare-fun _lbv0 () Int)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv2 () Int)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv5 () Bool)
(declare-fun var_v3 () Bool)
(assert (= (tlen leaf) 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (or (> _lbv0 |0|) (= _lbv0 |0|)))
(assert (= _lbv1 (- s0 1)))
(assert (= _lbv2 (- _lbv0 1)))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv4 true) (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv5 true) (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= var_v3 true) (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|)))))
(assert (= var_v3 false))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= var_v3 true) (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|)))))
(assert (not (> s0 s0)))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term _lbv0
 
 Type of the Scalar Term {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }                                                                                                                                                    
# of Final Z3 expressions 26
 Final solver 
 (declare-sort T31)
(declare-fun tlen (T31) Int)
(declare-fun leaf () T31)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv0 () Int)
(declare-fun _lbv2 () Int)
(declare-fun |0| () Int)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv5 () Bool)
(declare-fun var_v3 () Bool)
(assert (= (tlen leaf) 0))
(assert (= _lbv1 (- s0 1)))
(assert (= _lbv2 (- _lbv0 1)))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv4 true) (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv5 true) (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= var_v3 true) (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (or (> _lbv0 |0|) (= _lbv0 |0|)))
(assert (= var_v3 false))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= var_v3 true) (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (or (> _lbv0 |0|) (= _lbv0 |0|)))
(assert (not (> s0 _lbv0)))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {v:Ty_int | true}                                                                                                                                         
# of Final Z3 expressions 23
 Final solver 
 (declare-sort T37)
(declare-fun tlen (T37) Int)
(declare-fun leaf () T37)
(declare-fun |0| () Int)
(declare-fun _lbv0 () Int)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv2 () Int)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv5 () Bool)
(declare-fun var_v3 () Bool)
(declare-fun n () Int)
(assert (= (tlen leaf) 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (or (> _lbv0 |0|) (= _lbv0 |0|)))
(assert (= _lbv1 (- s0 1)))
(assert (= _lbv2 (- _lbv0 1)))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv4 true) (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv5 true) (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= var_v3 true) (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|)))))
(assert (= var_v3 false))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= var_v3 true) (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|)))))
(assert (not (> s0 n)))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term _lbv1
 
 Type of the Scalar Term {v:Ty_int | (v) ==((s0) -- (1))}                                                                                                                                         
# of Final Z3 expressions 24
 Final solver 
 (declare-sort T43)
(declare-fun tlen (T43) Int)
(declare-fun leaf () T43)
(declare-fun |0| () Int)
(declare-fun _lbv0 () Int)
(declare-fun _lbv2 () Int)
(declare-fun s0 () Int)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun var_v3 () Bool)
(assert (= (tlen leaf) 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (or (> _lbv0 |0|) (= _lbv0 |0|)))
(assert (= _lbv2 (- _lbv0 1)))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv4 true) (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv5 true) (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= var_v3 true) (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|)))))
(assert (= _lbv1 (- s0 1)))
(assert (= var_v3 false))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= var_v3 true) (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|)))))
(assert (= _lbv1 (- s0 1)))
(assert (not (> s0 _lbv1)))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 Enumerating a Scalar Term _lbv2
 
 Type of the Scalar Term {v:Ty_int | (v) ==((_lbv0) -- (1))}                                                                                                                                         
# of Final Z3 expressions 24
 Final solver 
 (declare-sort T49)
(declare-fun tlen (T49) Int)
(declare-fun leaf () T49)
(declare-fun |0| () Int)
(declare-fun _lbv0 () Int)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv5 () Bool)
(declare-fun var_v3 () Bool)
(assert (= (tlen leaf) 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (or (> _lbv0 |0|) (= _lbv0 |0|)))
(assert (= _lbv1 (- s0 1)))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv4 true) (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv5 true) (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= var_v3 true) (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|)))))
(assert (= _lbv2 (- _lbv0 1)))
(assert (= var_v3 false))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= var_v3 true) (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|)))))
(assert (= _lbv2 (- _lbv0 1)))
(assert (not (> s0 _lbv2)))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term s
 
 Type of the Scalar Term {var_v0:Ty_int | true}                                                                                                                                         
# of Final Z3 expressions 23
 Final solver 
 (declare-sort T55)
(declare-fun tlen (T55) Int)
(declare-fun leaf () T55)
(declare-fun |0| () Int)
(declare-fun _lbv0 () Int)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv2 () Int)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv5 () Bool)
(declare-fun var_v3 () Bool)
(declare-fun s () Int)
(assert (= (tlen leaf) 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (or (> _lbv0 |0|) (= _lbv0 |0|)))
(assert (= _lbv1 (- s0 1)))
(assert (= _lbv2 (- _lbv0 1)))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv4 true) (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv5 true) (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= var_v3 true) (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|)))))
(assert (= var_v3 false))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= var_v3 true) (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|)))))
(assert (not (> s0 s)))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 
 FaileD the subtype check T_vi <: T_goal
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  , 
 subs, 
 int_gen
 ############################################################
  Synthesizing the Function application Pure Component subs
 ############################################################
  *************** Trying Arrow Component ************subs :  Arrow ( ( n : {v:Ty_int | true} ) -> {v:Ty_int | (v) ==((n) -- (1))}
  *************** Synthesizing Args ei : ti for ************subs
 ##################################################################################
  Synthesizing the 1th argument for Function subs
  Trying Arguments in Scalars 
 esynthesizeScalar for {v:Ty_int | true}
 
 Enumerating a Scalar Term s0
 
 Type of the Scalar Term {v:Ty_int | true}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term _lbv0
 
 Type of the Scalar Term {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {v:Ty_int | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 ################################################
 
 Enumerating a Scalar Term _lbv1
 
 Type of the Scalar Term {v:Ty_int | (v) ==((s0) -- (1))}
 ################################################
 Skipping Variable _lbv1 As Outer Function Call is subs
 
 Enumerating a Scalar Term _lbv2
 
 Type of the Scalar Term {v:Ty_int | (v) ==((_lbv0) -- (1))}
 ################################################
 Skipping Variable _lbv2 As Outer Function Call is subs
 
 Enumerating a Scalar Term s
 
 Type of the Scalar Term {var_v0:Ty_int | true}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  , 
 subs, 
 int_gen
 ############################################################
  Synthesizing the Function application Pure Component subs
 ############################################################
 ############################################################
  Synthesizing the Function application Pure Component int_gen
 ############################################################
  *************** Trying Arrow Component ************int_gen :  Arrow ( ( d : {var_v1:Ty_unit | true} ) -> {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }
  *************** Synthesizing Args ei : ti for ************int_gen
 ##################################################################################
  Synthesizing the 1th argument for Function int_gen
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v1:Ty_unit | true}
 
 Enumerating a Scalar Term dummy
 
 Type of the Scalar Term {v:Ty_unit | true}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term d
 
 Type of the Scalar Term {var_v1:Ty_unit | true}
 ################################################
 Skipping Variable d As this a  Formal Parameter to the current function Call
 ################################################
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>> 1th Args option for int_gen : dummy
 TEST Overall List : List of Args for int_gen
 EI dummy
 ##################################################################################
  *************** Successfully Synthesized Args ei Forall i 
 Ith Argument Options for int_gen
 EI dummy
 # of Possible Argument Options for int_gen 1
 Possible Arg Options 
 EI dummy
 Apply Single Argument Case : f (ei) Case int_gen
  Case : f (ei) Case int_gen dummy
 Finding Already seen tree for apply int_gen  (, dummy )
 Found _lbv0
 >>>>>>>>>>>>>>>>>>> 1th Args option for subs : s
 >>>>>>>>>>>>>>>>>>> 1th Args option for subs : apply int_gen  (, dummy )
 >>>>>>>>>>>>>>>>>>> 1th Args option for subs : s0
 >>>>>>>>>>>>>>>>>>> 1th Args option for subs : apply int_gen  (, dummy )
 TEST Overall List : List of Args for subs
 EI s
 EI apply int_gen  (, dummy )
 EI s0
 EI apply int_gen  (, dummy )
 ##################################################################################
  *************** Successfully Synthesized Args ei Forall i 
 Ith Argument Options for subs
 EI s
 EI apply int_gen  (, dummy )
 EI s0
 EI apply int_gen  (, dummy )
 # of Possible Argument Options for subs 4
 Possible Arg Options 
 EI s
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 Possible Arg Options 
 EI s0
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 Apply Single Argument Case : f (ei) Case subs
  Case : f (ei) Case subs s
 Finding Already seen tree for apply subs  (, s )
 Typechecking the Term apply subs  (, s )
 Against {v:Ty_int | 
 	 Conj <c true
 	 , s0 > v >c }
 Argument s :: {var_v0:Ty_int | true} | true
 AppType Type {v:Ty_int | (v) ==((s) -- (1))}                                                                                                                                         
# of Final Z3 expressions 25
 Final solver 
 (declare-sort T65)
(declare-fun tlen (T65) Int)
(declare-fun leaf () T65)
(declare-fun |0| () Int)
(declare-fun _lbv0 () Int)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv2 () Int)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv5 () Bool)
(declare-fun var_v3 () Bool)
(declare-fun s () Int)
(declare-fun v () Int)
(assert (= (tlen leaf) 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (or (> _lbv0 |0|) (= _lbv0 |0|)))
(assert (= _lbv1 (- s0 1)))
(assert (= _lbv2 (- _lbv0 1)))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv4 true) (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv5 true) (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= var_v3 true) (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|)))))
(assert (= v (- s 1)))
(assert (= var_v3 false))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= var_v3 true) (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|)))))
(assert (= v (- s 1)))
(assert (not (> s0 v)))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply subs  (, s )
  Case : f (ei) Case subs _lbv0
 Finding Already seen tree for apply subs  (, _lbv0 )
 Found _lbv2
  Case : f (ei) Case subs s0
 Finding Already seen tree for apply subs  (, s0 )
 Found _lbv1
  Case : f (ei) Case subs _lbv0
 Finding Already seen tree for apply subs  (, _lbv0 )
 Found _lbv2
 >>>>>>>>>>>>>>>>>>> 1th Args option for goal : apply subs  (, s0 )
 >>>>>>>>>>>>>>>>>>> 1th Args option for goal : apply subs  (, apply int_gen  (, dummy ) )
 >>>>>>>>>>>>>>>>>>> 1th Args option for goal : apply subs  (, s0 )
 >>>>>>>>>>>>>>>>>>> 1th Args option for goal : apply subs  (, apply int_gen  (, dummy ) )
 TEST Overall List : List of Args for goal
 EI apply subs  (, s0 )
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI apply subs  (, s0 )
 EI apply subs  (, apply int_gen  (, dummy ) )
 ##################################################################################
  *************** Successfully Synthesized Args ei Forall i 
 Ith Argument Options for goal
 EI apply subs  (, s0 )
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI apply subs  (, s0 )
 EI apply subs  (, apply int_gen  (, dummy ) )
 # of Possible Argument Options for goal 4
 Possible Arg Options 
 EI apply subs  (, s0 )
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 Possible Arg Options 
 EI apply subs  (, s0 )
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 Apply Single Argument Case : f (ei) Case goal
  Case : f (ei) Case goal _lbv1
 Finding Already seen tree for apply goal  (, _lbv1 )
 Typechecking the Term apply goal  (, _lbv1 )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (tlen)(v) ==(u)
 	 u = s0 > }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (tlen)(v) ==(u)
 	 u = _lbv1 > }}                                                                                                                                                           
# of Final Z3 expressions 14
 Final solver 
 (declare-sort T71)
(declare-fun |0| () Int)
(declare-fun _lbv1 () Int)
(declare-fun tlen (T71) Int)
(declare-fun v () T71)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T71)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u7 Int) (var_u6 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (> s0 s01)
         (=> (= (tlen v) var_u6) (= var_u6 _lbv1))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (=> (= (tlen v) var_u7) (= var_u7 _lbv1))))))
(assert (let ((a!1 (forall ((var_u8 Int)) (=> (= (tlen v) var_u8) (= var_u8 s0)))))
  (not a!1)))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply goal  (, _lbv1 )
  Case : f (ei) Case goal _lbv2
 Finding Already seen tree for apply goal  (, _lbv2 )
 Typechecking the Term apply goal  (, _lbv2 )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (tlen)(v) ==(u)
 	 u = s0 > }}
 Argument _lbv2 :: {v:Ty_int | (v) ==((_lbv0) -- (1))} | (_lbv2) ==((_lbv0) -- (1))
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (tlen)(v) ==(u)
 	 u = _lbv2 > }}                                                                                                                                                           
# of Final Z3 expressions 14
 Final solver 
 (declare-sort T77)
(declare-fun |0| () Int)
(declare-fun _lbv2 () Int)
(declare-fun tlen (T77) Int)
(declare-fun v () T77)
(declare-fun _lbv0 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T77)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u10 Int) (var_u9 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (> s0 s01)
         (=> (= (tlen v) var_u9) (= var_u9 _lbv2))
         (= var_v3 false)
         a!4
         (= _lbv2 (- _lbv0 1))
         (=> (= (tlen v) var_u10) (= var_u10 _lbv2))))))
(assert (let ((a!1 (forall ((var_u11 Int)) (=> (= (tlen v) var_u11) (= var_u11 s0)))))
  (not a!1)))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply goal  (, _lbv2 )
  Case : f (ei) Case goal _lbv1
 Finding Already seen tree for apply goal  (, _lbv1 )
 Typechecking the Term apply goal  (, _lbv1 )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (tlen)(v) ==(u)
 	 u = s0 > }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (tlen)(v) ==(u)
 	 u = _lbv1 > }}                                                                                                                                                           
# of Final Z3 expressions 14
 Final solver 
 (declare-sort T83)
(declare-fun |0| () Int)
(declare-fun _lbv1 () Int)
(declare-fun tlen (T83) Int)
(declare-fun v () T83)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T83)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u13 Int) (var_u12 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (> s0 s01)
         (=> (= (tlen v) var_u12) (= var_u12 _lbv1))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (=> (= (tlen v) var_u13) (= var_u13 _lbv1))))))
(assert (let ((a!1 (forall ((var_u14 Int)) (=> (= (tlen v) var_u14) (= var_u14 s0)))))
  (not a!1)))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply goal  (, _lbv1 )
  Case : f (ei) Case goal _lbv2
 Finding Already seen tree for apply goal  (, _lbv2 )
 Typechecking the Term apply goal  (, _lbv2 )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (tlen)(v) ==(u)
 	 u = s0 > }}
 Argument _lbv2 :: {v:Ty_int | (v) ==((_lbv0) -- (1))} | (_lbv2) ==((_lbv0) -- (1))
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (tlen)(v) ==(u)
 	 u = _lbv2 > }}                                                                                                                                                           
# of Final Z3 expressions 14
 Final solver 
 (declare-sort T89)
(declare-fun |0| () Int)
(declare-fun _lbv2 () Int)
(declare-fun tlen (T89) Int)
(declare-fun v () T89)
(declare-fun _lbv0 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T89)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u16 Int) (var_u15 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (> s0 s01)
         (=> (= (tlen v) var_u15) (= var_u15 _lbv2))
         (= var_v3 false)
         a!4
         (= _lbv2 (- _lbv0 1))
         (=> (= (tlen v) var_u16) (= var_u16 _lbv2))))))
(assert (let ((a!1 (forall ((var_u17 Int)) (=> (= (tlen v) var_u17) (= var_u17 s0)))))
  (not a!1)))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply goal  (, _lbv2 )
  ###################################################
  The Choice of Function goal Was Ill Fated Try Next Choice of function
 ############################################################
  Synthesizing the Function application Pure Component node
 ############################################################
  *************** Trying Arrow Component ************node :  Arrow ( ( root : {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } ) ->  Arrow ( ( sizel : {v:Ty_int | true} ) ->  Arrow ( ( ltree : {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} ) ->  Arrow ( ( sizer : {v:Ty_int | true} ) ->  Arrow ( ( rtree : {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} ) -> {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((sizel) + (1))
 	 (tlen)(v) ==(u) > }}
  *************** Synthesizing Args ei : ti for ************node
 ##################################################################################
  Synthesizing the 1th argument for Function node
  Trying Arguments in Scalars 
 esynthesizeScalar for {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }
 
 Enumerating a Scalar Term s0
 
 Type of the Scalar Term {v:Ty_int | true}                                                                                                                                                    
# of Final Z3 expressions 26
 Final solver 
 (declare-sort T95)
(declare-fun tlen (T95) Int)
(declare-fun leaf () T95)
(declare-fun |0| () Int)
(declare-fun _lbv0 () Int)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv2 () Int)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv5 () Bool)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(assert (= (tlen leaf) 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (or (> _lbv0 |0|) (= _lbv0 |0|)))
(assert (= _lbv1 (- s0 1)))
(assert (= _lbv2 (- _lbv0 1)))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv4 true) (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv5 true) (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= var_v3 true) (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|)))))
(assert (> s0 s01))
(assert (= var_v3 false))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= var_v3 true) (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (not (or (> s0 |0|) (= s0 |0|))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term _lbv0
 
 Type of the Scalar Term {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }                                                                                                                                                               
# of Final Z3 expressions 29
 Final solver 
 (declare-sort T101)
(declare-fun tlen (T101) Int)
(declare-fun leaf () T101)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv0 () Int)
(declare-fun _lbv2 () Int)
(declare-fun |0| () Int)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv5 () Bool)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(assert (= (tlen leaf) 0))
(assert (= _lbv1 (- s0 1)))
(assert (= _lbv2 (- _lbv0 1)))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv4 true) (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv5 true) (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= var_v3 true) (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|)))))
(assert (> s0 s01))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (or (> _lbv0 |0|) (= _lbv0 |0|)))
(assert (= var_v3 false))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= var_v3 true) (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (or (> _lbv0 |0|) (= _lbv0 |0|)))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (not (or (> _lbv0 |0|) (= _lbv0 |0|))))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 Enumerating a Scalar Term _lbv1
 
 Type of the Scalar Term {v:Ty_int | (v) ==((s0) -- (1))}                                                                                                                                                    
# of Final Z3 expressions 27
 Final solver 
 (declare-sort T107)
(declare-fun tlen (T107) Int)
(declare-fun leaf () T107)
(declare-fun |0| () Int)
(declare-fun _lbv0 () Int)
(declare-fun _lbv2 () Int)
(declare-fun s0 () Int)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(assert (= (tlen leaf) 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (or (> _lbv0 |0|) (= _lbv0 |0|)))
(assert (= _lbv2 (- _lbv0 1)))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv4 true) (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv5 true) (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= var_v3 true) (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|)))))
(assert (> s0 s01))
(assert (= _lbv1 (- s0 1)))
(assert (= var_v3 false))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= var_v3 true) (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|)))))
(assert (= _lbv1 (- s0 1)))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (not (or (> _lbv1 |0|) (= _lbv1 |0|))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term _lbv2
 
 Type of the Scalar Term {v:Ty_int | (v) ==((_lbv0) -- (1))}                                                                                                                                                    
# of Final Z3 expressions 27
 Final solver 
 (declare-sort T113)
(declare-fun tlen (T113) Int)
(declare-fun leaf () T113)
(declare-fun |0| () Int)
(declare-fun _lbv0 () Int)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv5 () Bool)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(assert (= (tlen leaf) 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (or (> _lbv0 |0|) (= _lbv0 |0|)))
(assert (= _lbv1 (- s0 1)))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv4 true) (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv5 true) (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= var_v3 true) (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|)))))
(assert (> s0 s01))
(assert (= _lbv2 (- _lbv0 1)))
(assert (= var_v3 false))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= var_v3 true) (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|)))))
(assert (= _lbv2 (- _lbv0 1)))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (not (or (> _lbv2 |0|) (= _lbv2 |0|))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term s
 
 Type of the Scalar Term {var_v0:Ty_int | true}                                                                                                                                                    
# of Final Z3 expressions 26
 Final solver 
 (declare-sort T119)
(declare-fun tlen (T119) Int)
(declare-fun leaf () T119)
(declare-fun |0| () Int)
(declare-fun _lbv0 () Int)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv2 () Int)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv5 () Bool)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun s () Int)
(assert (= (tlen leaf) 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (or (> _lbv0 |0|) (= _lbv0 |0|)))
(assert (= _lbv1 (- s0 1)))
(assert (= _lbv2 (- _lbv0 1)))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv4 true) (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv5 true) (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= var_v3 true) (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|)))))
(assert (> s0 s01))
(assert (= var_v3 false))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= var_v3 true) (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (not (or (> s |0|) (= s |0|))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {v:Ty_int | true}                                                                                                                                                    
# of Final Z3 expressions 26
 Final solver 
 (declare-sort T125)
(declare-fun tlen (T125) Int)
(declare-fun leaf () T125)
(declare-fun |0| () Int)
(declare-fun _lbv0 () Int)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv2 () Int)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv5 () Bool)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun n () Int)
(assert (= (tlen leaf) 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (or (> _lbv0 |0|) (= _lbv0 |0|)))
(assert (= _lbv1 (- s0 1)))
(assert (= _lbv2 (- _lbv0 1)))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv4 true) (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv5 true) (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= var_v3 true) (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|)))))
(assert (> s0 s01))
(assert (= var_v3 false))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= var_v3 true) (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (not (or (> n |0|) (= n |0|))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term s01
 
 Type of the Scalar Term {v:Ty_int | 
 	 Conj <c true
 	 , s0 > v >c }                                                                                                                                                         
# of Final Z3 expressions 27
 Final solver 
 (declare-sort T131)
(declare-fun tlen (T131) Int)
(declare-fun leaf () T131)
(declare-fun |0| () Int)
(declare-fun _lbv0 () Int)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv2 () Int)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv5 () Bool)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(assert (= (tlen leaf) 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (or (> _lbv0 |0|) (= _lbv0 |0|)))
(assert (= _lbv1 (- s0 1)))
(assert (= _lbv2 (- _lbv0 1)))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv4 true) (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv5 true) (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= var_v3 true) (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|)))))
(assert (> s0 s01))
(assert (= var_v3 false))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= var_v3 true) (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|)))))
(assert (> s0 s01))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (not (or (> s01 |0|) (= s01 |0|))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 
 FaileD the subtype check T_vi <: T_goal
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  , 
 subs, 
 int_gen
 ############################################################
  Synthesizing the Function application Pure Component subs
 ############################################################
  *************** Trying Arrow Component ************subs :  Arrow ( ( n : {v:Ty_int | true} ) -> {v:Ty_int | (v) ==((n) -- (1))}
  *************** Synthesizing Args ei : ti for ************subs
 ##################################################################################
  Synthesizing the 1th argument for Function subs
  Trying Arguments in Scalars 
 esynthesizeScalar for {v:Ty_int | true}
 
 Enumerating a Scalar Term s0
 
 Type of the Scalar Term {v:Ty_int | true}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term _lbv0
 
 Type of the Scalar Term {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 Enumerating a Scalar Term _lbv1
 
 Type of the Scalar Term {v:Ty_int | (v) ==((s0) -- (1))}
 ################################################
 Skipping Variable _lbv1 As Outer Function Call is subs
 
 Enumerating a Scalar Term _lbv2
 
 Type of the Scalar Term {v:Ty_int | (v) ==((_lbv0) -- (1))}
 ################################################
 Skipping Variable _lbv2 As Outer Function Call is subs
 
 Enumerating a Scalar Term s
 
 Type of the Scalar Term {var_v0:Ty_int | true}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {v:Ty_int | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 ################################################
 
 Enumerating a Scalar Term s01
 
 Type of the Scalar Term {v:Ty_int | 
 	 Conj <c true
 	 , s0 > v >c }
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  , 
 subs, 
 int_gen
 ############################################################
  Synthesizing the Function application Pure Component subs
 ############################################################
 ############################################################
  Synthesizing the Function application Pure Component int_gen
 ############################################################
  *************** Trying Arrow Component ************int_gen :  Arrow ( ( d : {var_v1:Ty_unit | true} ) -> {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }
  *************** Synthesizing Args ei : ti for ************int_gen
 ##################################################################################
  Synthesizing the 1th argument for Function int_gen
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v1:Ty_unit | true}
 
 Enumerating a Scalar Term dummy
 
 Type of the Scalar Term {v:Ty_unit | true}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term d
 
 Type of the Scalar Term {var_v1:Ty_unit | true}
 ################################################
 Skipping Variable d As this a  Formal Parameter to the current function Call
 ################################################
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>> 1th Args option for int_gen : dummy
 TEST Overall List : List of Args for int_gen
 EI dummy
 ##################################################################################
  *************** Successfully Synthesized Args ei Forall i 
 Ith Argument Options for int_gen
 EI dummy
 # of Possible Argument Options for int_gen 1
 Possible Arg Options 
 EI dummy
 Apply Single Argument Case : f (ei) Case int_gen
  Case : f (ei) Case int_gen dummy
 Finding Already seen tree for apply int_gen  (, dummy )
 Found _lbv0
 >>>>>>>>>>>>>>>>>>> 1th Args option for subs : s01
 >>>>>>>>>>>>>>>>>>> 1th Args option for subs : s
 >>>>>>>>>>>>>>>>>>> 1th Args option for subs : apply int_gen  (, dummy )
 >>>>>>>>>>>>>>>>>>> 1th Args option for subs : s0
 >>>>>>>>>>>>>>>>>>> 1th Args option for subs : apply int_gen  (, dummy )
 TEST Overall List : List of Args for subs
 EI s01
 EI s
 EI apply int_gen  (, dummy )
 EI s0
 EI apply int_gen  (, dummy )
 ##################################################################################
  *************** Successfully Synthesized Args ei Forall i 
 Ith Argument Options for subs
 EI s01
 EI s
 EI apply int_gen  (, dummy )
 EI s0
 EI apply int_gen  (, dummy )
 # of Possible Argument Options for subs 5
 Possible Arg Options 
 EI s01
 Possible Arg Options 
 EI s
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 Possible Arg Options 
 EI s0
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 Apply Single Argument Case : f (ei) Case subs
  Case : f (ei) Case subs s01
 Finding Already seen tree for apply subs  (, s01 )
 Typechecking the Term apply subs  (, s01 )
 Against {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }
 Argument s01 :: {v:Ty_int | 
 	 Conj <c true
 	 , s0 > v >c } | 
 	 Conj <c true
 	 , s0 > s01 >c 
 AppType Type {v:Ty_int | (v) ==((s01) -- (1))}                                                                                                                                                         
# of Final Z3 expressions 29
 Final solver 
 (declare-sort T142)
(declare-fun tlen (T142) Int)
(declare-fun leaf () T142)
(declare-fun |0| () Int)
(declare-fun _lbv0 () Int)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv2 () Int)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv5 () Bool)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun v () Int)
(assert (= (tlen leaf) 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (or (> _lbv0 |0|) (= _lbv0 |0|)))
(assert (= _lbv1 (- s0 1)))
(assert (= _lbv2 (- _lbv0 1)))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv4 true) (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv5 true) (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= var_v3 true) (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|)))))
(assert (> s0 s01))
(assert (= v (- s01 1)))
(assert (= var_v3 false))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= var_v3 true) (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|)))))
(assert (> s0 s01))
(assert (= v (- s01 1)))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (not (or (> v |0|) (= v |0|))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply subs  (, s01 )
  Case : f (ei) Case subs s
 Finding Already seen tree for apply subs  (, s )
 Typechecking the Term apply subs  (, s )
 Against {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }
 Argument s :: {var_v0:Ty_int | true} | true
 AppType Type {v:Ty_int | (v) ==((s) -- (1))}                                                                                                                                                    
# of Final Z3 expressions 28
 Final solver 
 (declare-sort T148)
(declare-fun tlen (T148) Int)
(declare-fun leaf () T148)
(declare-fun |0| () Int)
(declare-fun _lbv0 () Int)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv2 () Int)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv5 () Bool)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun s () Int)
(declare-fun v () Int)
(assert (= (tlen leaf) 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (or (> _lbv0 |0|) (= _lbv0 |0|)))
(assert (= _lbv1 (- s0 1)))
(assert (= _lbv2 (- _lbv0 1)))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv4 true) (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv5 true) (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= var_v3 true) (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|)))))
(assert (> s0 s01))
(assert (= v (- s 1)))
(assert (= var_v3 false))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= var_v3 true) (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|)))))
(assert (= v (- s 1)))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (not (or (> v |0|) (= v |0|))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply subs  (, s )
  Case : f (ei) Case subs _lbv0
 Finding Already seen tree for apply subs  (, _lbv0 )
 Found _lbv2
  Case : f (ei) Case subs s0
 Finding Already seen tree for apply subs  (, s0 )
 Found _lbv1
  Case : f (ei) Case subs _lbv0
 Finding Already seen tree for apply subs  (, _lbv0 )
 Found _lbv2
 >>>>>>>>>>>>>>>>>>> 1th Args option for node : apply int_gen  (, dummy )
 >>>>>>>>>>>>>>>>>>> 1th Args option for node : apply subs  (, apply int_gen  (, dummy ) )
 >>>>>>>>>>>>>>>>>>> 1th Args option for node : apply subs  (, s0 )
 >>>>>>>>>>>>>>>>>>> 1th Args option for node : apply subs  (, apply int_gen  (, dummy ) )
 TEST Overall List : List of Args for node
 EI apply int_gen  (, dummy )
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI apply subs  (, s0 )
 EI apply subs  (, apply int_gen  (, dummy ) )
 ##################################################################################
  Synthesizing the 2th argument for Function node
  Trying Arguments in Scalars 
 esynthesizeScalar for {v:Ty_int | true}
 
 Enumerating a Scalar Term s0
 
 Type of the Scalar Term {v:Ty_int | true}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term _lbv0
 
 Type of the Scalar Term {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }
 ################################################
 Skipping Variable _lbv0 As Outer Function Call is int_gen
 
 Enumerating a Scalar Term _lbv1
 
 Type of the Scalar Term {v:Ty_int | (v) ==((s0) -- (1))}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 Enumerating a Scalar Term _lbv2
 
 Type of the Scalar Term {v:Ty_int | (v) ==((_lbv0) -- (1))}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 Enumerating a Scalar Term s
 
 Type of the Scalar Term {var_v0:Ty_int | true}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term s01
 
 Type of the Scalar Term {v:Ty_int | 
 	 Conj <c true
 	 , s0 > v >c }
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {v:Ty_int | true}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term root
 
 Type of the Scalar Term {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  , 
 subs, 
 int_gen
 ############################################################
  Synthesizing the Function application Pure Component subs
 ############################################################
  *************** Trying Arrow Component ************subs :  Arrow ( ( n : {v:Ty_int | true} ) -> {v:Ty_int | (v) ==((n) -- (1))}
  *************** Synthesizing Args ei : ti for ************subs
 ##################################################################################
  Synthesizing the 1th argument for Function subs
  Trying Arguments in Scalars 
 esynthesizeScalar for {v:Ty_int | true}
 
 Enumerating a Scalar Term s0
 
 Type of the Scalar Term {v:Ty_int | true}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term _lbv0
 
 Type of the Scalar Term {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 Enumerating a Scalar Term _lbv1
 
 Type of the Scalar Term {v:Ty_int | (v) ==((s0) -- (1))}
 ################################################
 Skipping Variable _lbv1 As Outer Function Call is subs
 
 Enumerating a Scalar Term _lbv2
 
 Type of the Scalar Term {v:Ty_int | (v) ==((_lbv0) -- (1))}
 ################################################
 Skipping Variable _lbv2 As Outer Function Call is subs
 
 Enumerating a Scalar Term s
 
 Type of the Scalar Term {var_v0:Ty_int | true}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term s01
 
 Type of the Scalar Term {v:Ty_int | 
 	 Conj <c true
 	 , s0 > v >c }
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {v:Ty_int | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 ################################################
 
 Enumerating a Scalar Term root
 
 Type of the Scalar Term {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  , 
 subs, 
 int_gen
 ############################################################
  Synthesizing the Function application Pure Component subs
 ############################################################
 ############################################################
  Synthesizing the Function application Pure Component int_gen
 ############################################################
  *************** Trying Arrow Component ************int_gen :  Arrow ( ( d : {var_v1:Ty_unit | true} ) -> {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }
  *************** Synthesizing Args ei : ti for ************int_gen
 ##################################################################################
  Synthesizing the 1th argument for Function int_gen
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v1:Ty_unit | true}
 
 Enumerating a Scalar Term dummy
 
 Type of the Scalar Term {v:Ty_unit | true}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term d
 
 Type of the Scalar Term {var_v1:Ty_unit | true}
 ################################################
 Skipping Variable d As this a  Formal Parameter to the current function Call
 ################################################
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>> 1th Args option for int_gen : dummy
 TEST Overall List : List of Args for int_gen
 EI dummy
 ##################################################################################
  *************** Successfully Synthesized Args ei Forall i 
 Ith Argument Options for int_gen
 EI dummy
 # of Possible Argument Options for int_gen 1
 Possible Arg Options 
 EI dummy
 Apply Single Argument Case : f (ei) Case int_gen
  Case : f (ei) Case int_gen dummy
 Finding Already seen tree for apply int_gen  (, dummy )
 Found _lbv0
 >>>>>>>>>>>>>>>>>>> 1th Args option for subs : root
 >>>>>>>>>>>>>>>>>>> 1th Args option for subs : s01
 >>>>>>>>>>>>>>>>>>> 1th Args option for subs : s
 >>>>>>>>>>>>>>>>>>> 1th Args option for subs : apply int_gen  (, dummy )
 >>>>>>>>>>>>>>>>>>> 1th Args option for subs : s0
 >>>>>>>>>>>>>>>>>>> 1th Args option for subs : apply int_gen  (, dummy )
 TEST Overall List : List of Args for subs
 EI root
 EI s01
 EI s
 EI apply int_gen  (, dummy )
 EI s0
 EI apply int_gen  (, dummy )
 ##################################################################################
  *************** Successfully Synthesized Args ei Forall i 
 Ith Argument Options for subs
 EI root
 EI s01
 EI s
 EI apply int_gen  (, dummy )
 EI s0
 EI apply int_gen  (, dummy )
 # of Possible Argument Options for subs 6
 Possible Arg Options 
 EI root
 Possible Arg Options 
 EI s01
 Possible Arg Options 
 EI s
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 Possible Arg Options 
 EI s0
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 Apply Single Argument Case : f (ei) Case subs
  Case : f (ei) Case subs root
 Finding Already seen tree for apply subs  (, root )
 Typechecking the Term apply subs  (, root )
 Against {v:Ty_int | true}
 Argument root :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  root > 0
 	,   root = 0>d 
 AppType Type {v:Ty_int | (v) ==((root) -- (1))}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
  Show *************** TypeChecking Succsessful {v:Ty_int | (v) ==((root) -- (1))}
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 let _lbv6 = apply subs  (, root )
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  Case : f (ei) Case subs s01
 Finding Already seen tree for apply subs  (, s01 )
 Typechecking the Term apply subs  (, s01 )
 Against {v:Ty_int | true}
 Argument s01 :: {v:Ty_int | 
 	 Conj <c true
 	 , s0 > v >c } | 
 	 Conj <c true
 	 , s0 > s01 >c 
 AppType Type {v:Ty_int | (v) ==((s01) -- (1))}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
  Show *************** TypeChecking Succsessful {v:Ty_int | (v) ==((s01) -- (1))}
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 let _lbv7 = apply subs  (, s01 )
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  Case : f (ei) Case subs s
 Finding Already seen tree for apply subs  (, s )
 Typechecking the Term apply subs  (, s )
 Against {v:Ty_int | true}
 Argument s :: {var_v0:Ty_int | true} | true
 AppType Type {v:Ty_int | (v) ==((s) -- (1))}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
  Show *************** TypeChecking Succsessful {v:Ty_int | (v) ==((s) -- (1))}
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 let _lbv8 = apply subs  (, s )
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  Case : f (ei) Case subs _lbv0
 Finding Already seen tree for apply subs  (, _lbv0 )
 Found _lbv2
  Case : f (ei) Case subs s0
 Finding Already seen tree for apply subs  (, s0 )
 Found _lbv1
  Case : f (ei) Case subs _lbv0
 Finding Already seen tree for apply subs  (, _lbv0 )
 Found _lbv2
 >>>>>>>>>>>>>>>>>>> 2th Args option for node : root
 >>>>>>>>>>>>>>>>>>> 2th Args option for node : n
 >>>>>>>>>>>>>>>>>>> 2th Args option for node : s01
 >>>>>>>>>>>>>>>>>>> 2th Args option for node : s
 >>>>>>>>>>>>>>>>>>> 2th Args option for node : apply subs  (, apply int_gen  (, dummy ) )
 >>>>>>>>>>>>>>>>>>> 2th Args option for node : apply subs  (, s0 )
 >>>>>>>>>>>>>>>>>>> 2th Args option for node : s0
 >>>>>>>>>>>>>>>>>>> 2th Args option for node : apply subs  (, apply int_gen  (, dummy ) )
 >>>>>>>>>>>>>>>>>>> 2th Args option for node : apply subs  (, s0 )
 >>>>>>>>>>>>>>>>>>> 2th Args option for node : apply subs  (, apply int_gen  (, dummy ) )
 >>>>>>>>>>>>>>>>>>> 2th Args option for node : apply subs  (, s )
 >>>>>>>>>>>>>>>>>>> 2th Args option for node : apply subs  (, s01 )
 >>>>>>>>>>>>>>>>>>> 2th Args option for node : apply subs  (, root )
 TEST Overall List : List of Args for node
 EI root
 EI n
 EI s01
 EI s
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI apply subs  (, s0 )
 EI s0
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI apply subs  (, s0 )
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI apply subs  (, s )
 EI apply subs  (, s01 )
 EI apply subs  (, root )
 TEST Overall List : List of Args for node
 EI apply int_gen  (, dummy )
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI apply subs  (, s0 )
 EI apply subs  (, apply int_gen  (, dummy ) )
 ##################################################################################
  Synthesizing the 3th argument for Function node
  Trying Arguments in Scalars 
 esynthesizeScalar for {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 
 Enumerating a Scalar Term leaf
 
 Type of the Scalar Term {v:Ty_alphatree | (tlen)(v) ==(0)}                                                                                                                                                    
# of Final Z3 expressions 31
 Final solver 
 (declare-sort T171)
(declare-fun |0| () Int)
(declare-fun _lbv0 () Int)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv2 () Int)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv5 () Bool)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun root () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv7 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun tlen (T171) Int)
(declare-fun leaf () T171)
(declare-fun sizel () Int)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (or (> _lbv0 |0|) (= _lbv0 |0|)))
(assert (= _lbv1 (- s0 1)))
(assert (= _lbv2 (- _lbv0 1)))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv4 true) (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv5 true) (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= var_v3 true) (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|)))))
(assert (> s0 s01))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (or (> root |0|) (= root |0|)))
(assert (= _lbv6 (- root 1)))
(assert (= _lbv7 (- s01 1)))
(assert (= _lbv8 (- s 1)))
(assert (= (tlen leaf) 0))
(assert (= var_v3 false))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= var_v3 true) (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|)))))
(assert (= (tlen leaf) 0))
(assert (not (forall ((var_u18 Int)) (= (tlen leaf) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 
 FaileD the subtype check T_vi <: T_goal
 >>>>>>>>>>>>>>>>>> No Scalar found in Environment, Trying esynthesizePureApp <<<<<<<<<<<<<<<<<< 
  Entering Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  , 
 goal, 
 node
 ############################################################
  Synthesizing the Function application Pure Component goal
 ############################################################
  *************** Trying Arrow Component ************goal :  Arrow ( ( s01 : {v:Ty_int | 
 	 Conj <c true
 	 , s0 > v >c } ) -> {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (tlen)(v) ==(u)
 	 u = s01 > }}
  *************** Synthesizing Args ei : ti for ************goal
 ##################################################################################
  Synthesizing the 1th argument for Function goal
  Trying Arguments in Scalars 
 esynthesizeScalar for {v:Ty_int | 
 	 Conj <c true
 	 , s0 > v >c }
 
 Enumerating a Scalar Term s0
 
 Type of the Scalar Term {v:Ty_int | true}                                                                                                                                                         
# of Final Z3 expressions 30
 Final solver 
 (declare-sort T176)
(declare-fun tlen (T176) Int)
(declare-fun leaf () T176)
(declare-fun |0| () Int)
(declare-fun _lbv0 () Int)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv2 () Int)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv5 () Bool)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun root () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv7 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(assert (= (tlen leaf) 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (or (> _lbv0 |0|) (= _lbv0 |0|)))
(assert (= _lbv1 (- s0 1)))
(assert (= _lbv2 (- _lbv0 1)))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv4 true) (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv5 true) (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= var_v3 true) (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|)))))
(assert (> s0 s01))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (or (> root |0|) (= root |0|)))
(assert (= _lbv6 (- root 1)))
(assert (= _lbv7 (- s01 1)))
(assert (= _lbv8 (- s 1)))
(assert (= var_v3 false))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= var_v3 true) (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|)))))
(assert (not (> s0 s0)))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term _lbv0
 
 Type of the Scalar Term {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }                                                                                                                                                                    
# of Final Z3 expressions 33
 Final solver 
 (declare-sort T182)
(declare-fun tlen (T182) Int)
(declare-fun leaf () T182)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv0 () Int)
(declare-fun _lbv2 () Int)
(declare-fun |0| () Int)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv5 () Bool)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun root () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv7 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(assert (= (tlen leaf) 0))
(assert (= _lbv1 (- s0 1)))
(assert (= _lbv2 (- _lbv0 1)))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv4 true) (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv5 true) (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= var_v3 true) (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|)))))
(assert (> s0 s01))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (or (> root |0|) (= root |0|)))
(assert (= _lbv6 (- root 1)))
(assert (= _lbv7 (- s01 1)))
(assert (= _lbv8 (- s 1)))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (or (> _lbv0 |0|) (= _lbv0 |0|)))
(assert (= var_v3 false))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= var_v3 true) (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (or (> _lbv0 |0|) (= _lbv0 |0|)))
(assert (not (> s0 _lbv0)))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term _lbv1
 
 Type of the Scalar Term {v:Ty_int | (v) ==((s0) -- (1))}                                                                                                                                                         
# of Final Z3 expressions 31
 Final solver 
 (declare-sort T188)
(declare-fun tlen (T188) Int)
(declare-fun leaf () T188)
(declare-fun |0| () Int)
(declare-fun _lbv0 () Int)
(declare-fun _lbv2 () Int)
(declare-fun s0 () Int)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun root () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv7 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(assert (= (tlen leaf) 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (or (> _lbv0 |0|) (= _lbv0 |0|)))
(assert (= _lbv2 (- _lbv0 1)))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv4 true) (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv5 true) (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= var_v3 true) (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|)))))
(assert (> s0 s01))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (or (> root |0|) (= root |0|)))
(assert (= _lbv6 (- root 1)))
(assert (= _lbv7 (- s01 1)))
(assert (= _lbv8 (- s 1)))
(assert (= _lbv1 (- s0 1)))
(assert (= var_v3 false))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= var_v3 true) (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|)))))
(assert (= _lbv1 (- s0 1)))
(assert (not (> s0 _lbv1)))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 Enumerating a Scalar Term _lbv2
 
 Type of the Scalar Term {v:Ty_int | (v) ==((_lbv0) -- (1))}                                                                                                                                                         
# of Final Z3 expressions 31
 Final solver 
 (declare-sort T194)
(declare-fun tlen (T194) Int)
(declare-fun leaf () T194)
(declare-fun |0| () Int)
(declare-fun _lbv0 () Int)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv5 () Bool)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun root () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv7 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(assert (= (tlen leaf) 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (or (> _lbv0 |0|) (= _lbv0 |0|)))
(assert (= _lbv1 (- s0 1)))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv4 true) (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv5 true) (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= var_v3 true) (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|)))))
(assert (> s0 s01))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (or (> root |0|) (= root |0|)))
(assert (= _lbv6 (- root 1)))
(assert (= _lbv7 (- s01 1)))
(assert (= _lbv8 (- s 1)))
(assert (= _lbv2 (- _lbv0 1)))
(assert (= var_v3 false))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= var_v3 true) (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|)))))
(assert (= _lbv2 (- _lbv0 1)))
(assert (not (> s0 _lbv2)))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term s
 
 Type of the Scalar Term {var_v0:Ty_int | true}                                                                                                                                                         
# of Final Z3 expressions 30
 Final solver 
 (declare-sort T200)
(declare-fun tlen (T200) Int)
(declare-fun leaf () T200)
(declare-fun |0| () Int)
(declare-fun _lbv0 () Int)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv2 () Int)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv5 () Bool)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun root () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv7 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(assert (= (tlen leaf) 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (or (> _lbv0 |0|) (= _lbv0 |0|)))
(assert (= _lbv1 (- s0 1)))
(assert (= _lbv2 (- _lbv0 1)))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv4 true) (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv5 true) (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= var_v3 true) (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|)))))
(assert (> s0 s01))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (or (> root |0|) (= root |0|)))
(assert (= _lbv6 (- root 1)))
(assert (= _lbv7 (- s01 1)))
(assert (= _lbv8 (- s 1)))
(assert (= var_v3 false))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= var_v3 true) (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|)))))
(assert (not (> s0 s)))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term s01
 
 Type of the Scalar Term {v:Ty_int | 
 	 Conj <c true
 	 , s0 > v >c }
 ################################################
 Skipping Variable s01 As this a  Formal Parameter to the current function Call
 ################################################
 
 Enumerating a Scalar Term root
 
 Type of the Scalar Term {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }                                                                                                                                                                    
# of Final Z3 expressions 33
 Final solver 
 (declare-sort T206)
(declare-fun tlen (T206) Int)
(declare-fun leaf () T206)
(declare-fun |0| () Int)
(declare-fun _lbv0 () Int)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv2 () Int)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv5 () Bool)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun root () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv7 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(assert (= (tlen leaf) 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (or (> _lbv0 |0|) (= _lbv0 |0|)))
(assert (= _lbv1 (- s0 1)))
(assert (= _lbv2 (- _lbv0 1)))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv4 true) (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv5 true) (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= var_v3 true) (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|)))))
(assert (> s0 s01))
(assert (= _lbv6 (- root 1)))
(assert (= _lbv7 (- s01 1)))
(assert (= _lbv8 (- s 1)))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (or (> root |0|) (= root |0|)))
(assert (= var_v3 false))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= var_v3 true) (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (or (> root |0|) (= root |0|)))
(assert (not (> s0 root)))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {v:Ty_int | true}                                                                                                                                                         
# of Final Z3 expressions 30
 Final solver 
 (declare-sort T212)
(declare-fun tlen (T212) Int)
(declare-fun leaf () T212)
(declare-fun |0| () Int)
(declare-fun _lbv0 () Int)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv2 () Int)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv5 () Bool)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun root () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv7 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun n () Int)
(assert (= (tlen leaf) 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (or (> _lbv0 |0|) (= _lbv0 |0|)))
(assert (= _lbv1 (- s0 1)))
(assert (= _lbv2 (- _lbv0 1)))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv4 true) (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv5 true) (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= var_v3 true) (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|)))))
(assert (> s0 s01))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (or (> root |0|) (= root |0|)))
(assert (= _lbv6 (- root 1)))
(assert (= _lbv7 (- s01 1)))
(assert (= _lbv8 (- s 1)))
(assert (= var_v3 false))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= var_v3 true) (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|)))))
(assert (not (> s0 n)))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term _lbv6
 
 Type of the Scalar Term {v:Ty_int | (v) ==((root) -- (1))}                                                                                                                                                         
# of Final Z3 expressions 31
 Final solver 
 (declare-sort T218)
(declare-fun tlen (T218) Int)
(declare-fun leaf () T218)
(declare-fun |0| () Int)
(declare-fun _lbv0 () Int)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv2 () Int)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv5 () Bool)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun root () Int)
(declare-fun _lbv7 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv6 () Int)
(assert (= (tlen leaf) 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (or (> _lbv0 |0|) (= _lbv0 |0|)))
(assert (= _lbv1 (- s0 1)))
(assert (= _lbv2 (- _lbv0 1)))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv4 true) (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv5 true) (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= var_v3 true) (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|)))))
(assert (> s0 s01))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (or (> root |0|) (= root |0|)))
(assert (= _lbv7 (- s01 1)))
(assert (= _lbv8 (- s 1)))
(assert (= _lbv6 (- root 1)))
(assert (= var_v3 false))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= var_v3 true) (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|)))))
(assert (= _lbv6 (- root 1)))
(assert (not (> s0 _lbv6)))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term _lbv7
 
 Type of the Scalar Term {v:Ty_int | (v) ==((s01) -- (1))}                                                                                                                                                         
# of Final Z3 expressions 31
 Final solver 
 (declare-sort T224)
(declare-fun tlen (T224) Int)
(declare-fun leaf () T224)
(declare-fun |0| () Int)
(declare-fun _lbv0 () Int)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv2 () Int)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv5 () Bool)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun root () Int)
(declare-fun _lbv6 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(assert (= (tlen leaf) 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (or (> _lbv0 |0|) (= _lbv0 |0|)))
(assert (= _lbv1 (- s0 1)))
(assert (= _lbv2 (- _lbv0 1)))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv4 true) (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv5 true) (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= var_v3 true) (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|)))))
(assert (> s0 s01))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (or (> root |0|) (= root |0|)))
(assert (= _lbv6 (- root 1)))
(assert (= _lbv8 (- s 1)))
(assert (= _lbv7 (- s01 1)))
(assert (= var_v3 false))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= var_v3 true) (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|)))))
(assert (= _lbv7 (- s01 1)))
(assert (not (> s0 _lbv7)))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 Enumerating a Scalar Term _lbv8
 
 Type of the Scalar Term {v:Ty_int | (v) ==((s) -- (1))}                                                                                                                                                         
# of Final Z3 expressions 31
 Final solver 
 (declare-sort T230)
(declare-fun tlen (T230) Int)
(declare-fun leaf () T230)
(declare-fun |0| () Int)
(declare-fun _lbv0 () Int)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv2 () Int)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv5 () Bool)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun root () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv7 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(assert (= (tlen leaf) 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (or (> _lbv0 |0|) (= _lbv0 |0|)))
(assert (= _lbv1 (- s0 1)))
(assert (= _lbv2 (- _lbv0 1)))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv4 true) (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv5 true) (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= var_v3 true) (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|)))))
(assert (> s0 s01))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (or (> root |0|) (= root |0|)))
(assert (= _lbv6 (- root 1)))
(assert (= _lbv7 (- s01 1)))
(assert (= _lbv8 (- s 1)))
(assert (= var_v3 false))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= var_v3 true) (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|)))))
(assert (= _lbv8 (- s 1)))
(assert (not (> s0 _lbv8)))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term sizel
 
 Type of the Scalar Term {v:Ty_int | true}                                                                                                                                                         
# of Final Z3 expressions 30
 Final solver 
 (declare-sort T236)
(declare-fun tlen (T236) Int)
(declare-fun leaf () T236)
(declare-fun |0| () Int)
(declare-fun _lbv0 () Int)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv2 () Int)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv5 () Bool)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun root () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv7 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun sizel () Int)
(assert (= (tlen leaf) 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (or (> _lbv0 |0|) (= _lbv0 |0|)))
(assert (= _lbv1 (- s0 1)))
(assert (= _lbv2 (- _lbv0 1)))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv4 true) (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv5 true) (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= var_v3 true) (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|)))))
(assert (> s0 s01))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (or (> root |0|) (= root |0|)))
(assert (= _lbv6 (- root 1)))
(assert (= _lbv7 (- s01 1)))
(assert (= _lbv8 (- s 1)))
(assert (= var_v3 false))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= var_v3 true) (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|)))))
(assert (not (> s0 sizel)))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 
 FaileD the subtype check T_vi <: T_goal
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  , 
 subs, 
 int_gen
 ############################################################
  Synthesizing the Function application Pure Component subs
 ############################################################
  *************** Trying Arrow Component ************subs :  Arrow ( ( n : {v:Ty_int | true} ) -> {v:Ty_int | (v) ==((n) -- (1))}
  *************** Synthesizing Args ei : ti for ************subs
 ##################################################################################
  Synthesizing the 1th argument for Function subs
  Trying Arguments in Scalars 
 esynthesizeScalar for {v:Ty_int | true}
 
 Enumerating a Scalar Term s0
 
 Type of the Scalar Term {v:Ty_int | true}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term _lbv0
 
 Type of the Scalar Term {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 Enumerating a Scalar Term _lbv1
 
 Type of the Scalar Term {v:Ty_int | (v) ==((s0) -- (1))}
 ################################################
 Skipping Variable _lbv1 As Outer Function Call is subs
 
 Enumerating a Scalar Term _lbv2
 
 Type of the Scalar Term {v:Ty_int | (v) ==((_lbv0) -- (1))}
 ################################################
 Skipping Variable _lbv2 As Outer Function Call is subs
 
 Enumerating a Scalar Term s
 
 Type of the Scalar Term {var_v0:Ty_int | true}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term s01
 
 Type of the Scalar Term {v:Ty_int | 
 	 Conj <c true
 	 , s0 > v >c }
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term root
 
 Type of the Scalar Term {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {v:Ty_int | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 ################################################
 
 Enumerating a Scalar Term _lbv6
 
 Type of the Scalar Term {v:Ty_int | (v) ==((root) -- (1))}
 ################################################
 Skipping Variable _lbv6 As Outer Function Call is subs
 
 Enumerating a Scalar Term _lbv7
 
 Type of the Scalar Term {v:Ty_int | (v) ==((s01) -- (1))}
 ################################################
 Skipping Variable _lbv7 As Outer Function Call is subs
 
 Enumerating a Scalar Term _lbv8
 
 Type of the Scalar Term {v:Ty_int | (v) ==((s) -- (1))}
 ################################################
 Skipping Variable _lbv8 As Outer Function Call is subs
 
 Enumerating a Scalar Term sizel
 
 Type of the Scalar Term {v:Ty_int | true}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>> 1th Args option for subs : sizel
 >>>>>>>>>>>>>>>>>>> 1th Args option for subs : root
 >>>>>>>>>>>>>>>>>>> 1th Args option for subs : s01
 >>>>>>>>>>>>>>>>>>> 1th Args option for subs : s
 >>>>>>>>>>>>>>>>>>> 1th Args option for subs : apply int_gen  (, dummy )
 >>>>>>>>>>>>>>>>>>> 1th Args option for subs : s0
 TEST Overall List : List of Args for subs
 EI sizel
 EI root
 EI s01
 EI s
 EI apply int_gen  (, dummy )
 EI s0
 ##################################################################################
  *************** Successfully Synthesized Args ei Forall i 
 Ith Argument Options for subs
 EI sizel
 EI root
 EI s01
 EI s
 EI apply int_gen  (, dummy )
 EI s0
 # of Possible Argument Options for subs 6
 Possible Arg Options 
 EI sizel
 Possible Arg Options 
 EI root
 Possible Arg Options 
 EI s01
 Possible Arg Options 
 EI s
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 Possible Arg Options 
 EI s0
 Apply Single Argument Case : f (ei) Case subs
  Case : f (ei) Case subs sizel
 Finding Already seen tree for apply subs  (, sizel )
 Typechecking the Term apply subs  (, sizel )
 Against {v:Ty_int | 
 	 Conj <c true
 	 , s0 > v >c }
 Argument sizel :: {v:Ty_int | true} | true
 AppType Type {v:Ty_int | (v) ==((sizel) -- (1))}                                                                                                                                                         
# of Final Z3 expressions 32
 Final solver 
 (declare-sort T248)
(declare-fun tlen (T248) Int)
(declare-fun leaf () T248)
(declare-fun |0| () Int)
(declare-fun _lbv0 () Int)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv2 () Int)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv5 () Bool)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun root () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv7 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun sizel () Int)
(declare-fun v () Int)
(assert (= (tlen leaf) 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (or (> _lbv0 |0|) (= _lbv0 |0|)))
(assert (= _lbv1 (- s0 1)))
(assert (= _lbv2 (- _lbv0 1)))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv4 true) (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv5 true) (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= var_v3 true) (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|)))))
(assert (> s0 s01))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (or (> root |0|) (= root |0|)))
(assert (= _lbv6 (- root 1)))
(assert (= _lbv7 (- s01 1)))
(assert (= _lbv8 (- s 1)))
(assert (= v (- sizel 1)))
(assert (= var_v3 false))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= var_v3 true) (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|)))))
(assert (= v (- sizel 1)))
(assert (not (> s0 v)))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply subs  (, sizel )
  Case : f (ei) Case subs root
 Finding Already seen tree for apply subs  (, root )
 Found _lbv6
  Case : f (ei) Case subs s01
 Finding Already seen tree for apply subs  (, s01 )
 Found _lbv7
  Case : f (ei) Case subs s
 Finding Already seen tree for apply subs  (, s )
 Found _lbv8
  Case : f (ei) Case subs _lbv0
 Finding Already seen tree for apply subs  (, _lbv0 )
 Found _lbv2
  Case : f (ei) Case subs s0
 Finding Already seen tree for apply subs  (, s0 )
 Found _lbv1
 >>>>>>>>>>>>>>>>>>> 1th Args option for goal : apply subs  (, s01 )
 >>>>>>>>>>>>>>>>>>> 1th Args option for goal : apply subs  (, s0 )
 >>>>>>>>>>>>>>>>>>> 1th Args option for goal : apply subs  (, s0 )
 >>>>>>>>>>>>>>>>>>> 1th Args option for goal : apply subs  (, apply int_gen  (, dummy ) )
 >>>>>>>>>>>>>>>>>>> 1th Args option for goal : apply subs  (, s )
 >>>>>>>>>>>>>>>>>>> 1th Args option for goal : apply subs  (, s01 )
 >>>>>>>>>>>>>>>>>>> 1th Args option for goal : apply subs  (, root )
 TEST Overall List : List of Args for goal
 EI apply subs  (, s01 )
 EI apply subs  (, s0 )
 EI apply subs  (, s0 )
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI apply subs  (, s )
 EI apply subs  (, s01 )
 EI apply subs  (, root )
 ##################################################################################
  *************** Successfully Synthesized Args ei Forall i 
 Ith Argument Options for goal
 EI apply subs  (, s01 )
 EI apply subs  (, s0 )
 EI apply subs  (, s0 )
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI apply subs  (, s )
 EI apply subs  (, s01 )
 EI apply subs  (, root )
 # of Possible Argument Options for goal 7
 Possible Arg Options 
 EI apply subs  (, s01 )
 Possible Arg Options 
 EI apply subs  (, s0 )
 Possible Arg Options 
 EI apply subs  (, s0 )
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 Possible Arg Options 
 EI apply subs  (, s )
 Possible Arg Options 
 EI apply subs  (, s01 )
 Possible Arg Options 
 EI apply subs  (, root )
 Apply Single Argument Case : f (ei) Case goal
  Case : f (ei) Case goal _lbv7
 Finding Already seen tree for apply goal  (, _lbv7 )
 Typechecking the Term apply goal  (, _lbv7 )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv7 :: {v:Ty_int | (v) ==((s01) -- (1))} | (_lbv7) ==((s01) -- (1))
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (tlen)(v) ==(u)
 	 u = _lbv7 > }}                                                                                                                                                                
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T254)
(declare-fun |0| () Int)
(declare-fun _lbv7 () Int)
(declare-fun tlen (T254) Int)
(declare-fun v () T254)
(declare-fun s01 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun root () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T254)
(declare-fun sizel () Int)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u20 Int) (var_u19 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (or (> root |0|) (= root |0|))
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (> s0 s01)
         (=> (= (tlen v) var_u19) (= var_u19 _lbv7))
         (= var_v3 false)
         a!4
         (= _lbv7 (- s01 1))
         (=> (= (tlen v) var_u20) (= var_u20 _lbv7))))))
(assert (not (forall ((var_u21 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply goal  (, _lbv7 )
  Case : f (ei) Case goal _lbv1
 Finding Already seen tree for apply goal  (, _lbv1 )
 Typechecking the Term apply goal  (, _lbv1 )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (tlen)(v) ==(u)
 	 u = _lbv1 > }}                                                                                                                                                                
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T260)
(declare-fun |0| () Int)
(declare-fun _lbv1 () Int)
(declare-fun tlen (T260) Int)
(declare-fun v () T260)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun root () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T260)
(declare-fun sizel () Int)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u23 Int) (var_u22 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (or (> root |0|) (= root |0|))
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (> s0 s01)
         (=> (= (tlen v) var_u22) (= var_u22 _lbv1))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (=> (= (tlen v) var_u23) (= var_u23 _lbv1))))))
(assert (not (forall ((var_u24 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply goal  (, _lbv1 )
  Case : f (ei) Case goal _lbv1
 Finding Already seen tree for apply goal  (, _lbv1 )
 Typechecking the Term apply goal  (, _lbv1 )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (tlen)(v) ==(u)
 	 u = _lbv1 > }}                                                                                                                                                                
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T266)
(declare-fun |0| () Int)
(declare-fun _lbv1 () Int)
(declare-fun tlen (T266) Int)
(declare-fun v () T266)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun root () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T266)
(declare-fun sizel () Int)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u26 Int) (var_u25 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (or (> root |0|) (= root |0|))
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (> s0 s01)
         (=> (= (tlen v) var_u25) (= var_u25 _lbv1))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (=> (= (tlen v) var_u26) (= var_u26 _lbv1))))))
(assert (not (forall ((var_u27 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply goal  (, _lbv1 )
  Case : f (ei) Case goal _lbv2
 Finding Already seen tree for apply goal  (, _lbv2 )
 Typechecking the Term apply goal  (, _lbv2 )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv2 :: {v:Ty_int | (v) ==((_lbv0) -- (1))} | (_lbv2) ==((_lbv0) -- (1))
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (tlen)(v) ==(u)
 	 u = _lbv2 > }}                                                                                                                                                                
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T272)
(declare-fun |0| () Int)
(declare-fun _lbv2 () Int)
(declare-fun tlen (T272) Int)
(declare-fun v () T272)
(declare-fun _lbv0 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun root () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T272)
(declare-fun sizel () Int)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u29 Int) (var_u28 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (or (> root |0|) (= root |0|))
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (> s0 s01)
         (=> (= (tlen v) var_u28) (= var_u28 _lbv2))
         (= var_v3 false)
         a!4
         (= _lbv2 (- _lbv0 1))
         (=> (= (tlen v) var_u29) (= var_u29 _lbv2))))))
(assert (not (forall ((var_u30 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply goal  (, _lbv2 )
  Case : f (ei) Case goal _lbv8
 Finding Already seen tree for apply goal  (, _lbv8 )
 Typechecking the Term apply goal  (, _lbv8 )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv8 :: {v:Ty_int | (v) ==((s) -- (1))} | (_lbv8) ==((s) -- (1))
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (tlen)(v) ==(u)
 	 u = _lbv8 > }}                                                                                                                                                                
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T278)
(declare-fun |0| () Int)
(declare-fun _lbv8 () Int)
(declare-fun tlen (T278) Int)
(declare-fun v () T278)
(declare-fun s () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun _lbv7 () Int)
(declare-fun root () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T278)
(declare-fun sizel () Int)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u32 Int) (var_u31 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (or (> root |0|) (= root |0|))
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (> s0 s01)
         (=> (= (tlen v) var_u31) (= var_u31 _lbv8))
         (= var_v3 false)
         a!4
         (= _lbv8 (- s 1))
         (=> (= (tlen v) var_u32) (= var_u32 _lbv8))))))
(assert (not (forall ((var_u33 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply goal  (, _lbv8 )
  Case : f (ei) Case goal _lbv7
 Finding Already seen tree for apply goal  (, _lbv7 )
 Typechecking the Term apply goal  (, _lbv7 )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv7 :: {v:Ty_int | (v) ==((s01) -- (1))} | (_lbv7) ==((s01) -- (1))
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (tlen)(v) ==(u)
 	 u = _lbv7 > }}                                                                                                                                                                
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T284)
(declare-fun |0| () Int)
(declare-fun _lbv7 () Int)
(declare-fun tlen (T284) Int)
(declare-fun v () T284)
(declare-fun s01 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun root () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T284)
(declare-fun sizel () Int)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u35 Int) (var_u34 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (or (> root |0|) (= root |0|))
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (> s0 s01)
         (=> (= (tlen v) var_u34) (= var_u34 _lbv7))
         (= var_v3 false)
         a!4
         (= _lbv7 (- s01 1))
         (=> (= (tlen v) var_u35) (= var_u35 _lbv7))))))
(assert (not (forall ((var_u36 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply goal  (, _lbv7 )
  Case : f (ei) Case goal _lbv6
 Finding Already seen tree for apply goal  (, _lbv6 )
 Typechecking the Term apply goal  (, _lbv6 )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv6 :: {v:Ty_int | (v) ==((root) -- (1))} | (_lbv6) ==((root) -- (1))
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (tlen)(v) ==(u)
 	 u = _lbv6 > }}                                                                                                                                                                
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T290)
(declare-fun |0| () Int)
(declare-fun _lbv6 () Int)
(declare-fun tlen (T290) Int)
(declare-fun v () T290)
(declare-fun root () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T290)
(declare-fun sizel () Int)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u38 Int) (var_u37 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (or (> root |0|) (= root |0|))
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (> s0 s01)
         (=> (= (tlen v) var_u37) (= var_u37 _lbv6))
         (= var_v3 false)
         a!4
         (= _lbv6 (- root 1))
         (=> (= (tlen v) var_u38) (= var_u38 _lbv6))))))
(assert (not (forall ((var_u39 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply goal  (, _lbv6 )
  ###################################################
  The Choice of Function goal Was Ill Fated Try Next Choice of function
 ############################################################
  Synthesizing the Function application Pure Component node
 ############################################################
  *************** Trying Arrow Component ************node :  Arrow ( ( root : {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } ) ->  Arrow ( ( sizel : {v:Ty_int | true} ) ->  Arrow ( ( ltree : {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} ) ->  Arrow ( ( sizer : {v:Ty_int | true} ) ->  Arrow ( ( rtree : {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} ) -> {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((sizel) + (1))
 	 (tlen)(v) ==(u) > }}
  *************** Synthesizing Args ei : ti for ************node
 ##################################################################################
  Synthesizing the 1th argument for Function node
  Trying Arguments in Scalars 
 esynthesizeScalar for {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }
 
 Enumerating a Scalar Term s0
 
 Type of the Scalar Term {v:Ty_int | true}                                                                                                                                                               
# of Final Z3 expressions 32
 Final solver 
 (declare-sort T296)
(declare-fun tlen (T296) Int)
(declare-fun leaf () T296)
(declare-fun |0| () Int)
(declare-fun _lbv0 () Int)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv2 () Int)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv5 () Bool)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun _lbv6 () Int)
(declare-fun s01 () Int)
(declare-fun _lbv7 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(assert (= (tlen leaf) 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (or (> _lbv0 |0|) (= _lbv0 |0|)))
(assert (= _lbv1 (- s0 1)))
(assert (= _lbv2 (- _lbv0 1)))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv4 true) (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv5 true) (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= var_v3 true) (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (or (> root |0|) (= root |0|)))
(assert (= _lbv6 (- root 1)))
(assert (= _lbv7 (- s01 1)))
(assert (= _lbv8 (- s 1)))
(assert (> s0 s01))
(assert (= var_v3 false))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= var_v3 true) (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (not (or (> s0 |0|) (= s0 |0|))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term _lbv0
 
 Type of the Scalar Term {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }                                                                                                                                                                          
# of Final Z3 expressions 35
 Final solver 
 (declare-sort T302)
(declare-fun tlen (T302) Int)
(declare-fun leaf () T302)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv0 () Int)
(declare-fun _lbv2 () Int)
(declare-fun |0| () Int)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv5 () Bool)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun _lbv6 () Int)
(declare-fun s01 () Int)
(declare-fun _lbv7 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(assert (= (tlen leaf) 0))
(assert (= _lbv1 (- s0 1)))
(assert (= _lbv2 (- _lbv0 1)))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv4 true) (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv5 true) (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= var_v3 true) (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (or (> root |0|) (= root |0|)))
(assert (= _lbv6 (- root 1)))
(assert (= _lbv7 (- s01 1)))
(assert (= _lbv8 (- s 1)))
(assert (> s0 s01))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (or (> _lbv0 |0|) (= _lbv0 |0|)))
(assert (= var_v3 false))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= var_v3 true) (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (or (> _lbv0 |0|) (= _lbv0 |0|)))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (not (or (> _lbv0 |0|) (= _lbv0 |0|))))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 Enumerating a Scalar Term _lbv1
 
 Type of the Scalar Term {v:Ty_int | (v) ==((s0) -- (1))}                                                                                                                                                               
# of Final Z3 expressions 33
 Final solver 
 (declare-sort T308)
(declare-fun tlen (T308) Int)
(declare-fun leaf () T308)
(declare-fun |0| () Int)
(declare-fun _lbv0 () Int)
(declare-fun _lbv2 () Int)
(declare-fun s0 () Int)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun _lbv6 () Int)
(declare-fun s01 () Int)
(declare-fun _lbv7 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(assert (= (tlen leaf) 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (or (> _lbv0 |0|) (= _lbv0 |0|)))
(assert (= _lbv2 (- _lbv0 1)))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv4 true) (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv5 true) (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= var_v3 true) (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (or (> root |0|) (= root |0|)))
(assert (= _lbv6 (- root 1)))
(assert (= _lbv7 (- s01 1)))
(assert (= _lbv8 (- s 1)))
(assert (> s0 s01))
(assert (= _lbv1 (- s0 1)))
(assert (= var_v3 false))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= var_v3 true) (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|)))))
(assert (= _lbv1 (- s0 1)))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (not (or (> _lbv1 |0|) (= _lbv1 |0|))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term _lbv2
 
 Type of the Scalar Term {v:Ty_int | (v) ==((_lbv0) -- (1))}                                                                                                                                                               
# of Final Z3 expressions 33
 Final solver 
 (declare-sort T314)
(declare-fun tlen (T314) Int)
(declare-fun leaf () T314)
(declare-fun |0| () Int)
(declare-fun _lbv0 () Int)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv5 () Bool)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun _lbv6 () Int)
(declare-fun s01 () Int)
(declare-fun _lbv7 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(assert (= (tlen leaf) 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (or (> _lbv0 |0|) (= _lbv0 |0|)))
(assert (= _lbv1 (- s0 1)))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv4 true) (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv5 true) (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= var_v3 true) (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (or (> root |0|) (= root |0|)))
(assert (= _lbv6 (- root 1)))
(assert (= _lbv7 (- s01 1)))
(assert (= _lbv8 (- s 1)))
(assert (> s0 s01))
(assert (= _lbv2 (- _lbv0 1)))
(assert (= var_v3 false))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= var_v3 true) (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|)))))
(assert (= _lbv2 (- _lbv0 1)))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (not (or (> _lbv2 |0|) (= _lbv2 |0|))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term s
 
 Type of the Scalar Term {var_v0:Ty_int | true}                                                                                                                                                               
# of Final Z3 expressions 32
 Final solver 
 (declare-sort T320)
(declare-fun tlen (T320) Int)
(declare-fun leaf () T320)
(declare-fun |0| () Int)
(declare-fun _lbv0 () Int)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv2 () Int)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv5 () Bool)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun _lbv6 () Int)
(declare-fun s01 () Int)
(declare-fun _lbv7 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(assert (= (tlen leaf) 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (or (> _lbv0 |0|) (= _lbv0 |0|)))
(assert (= _lbv1 (- s0 1)))
(assert (= _lbv2 (- _lbv0 1)))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv4 true) (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv5 true) (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= var_v3 true) (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (or (> root |0|) (= root |0|)))
(assert (= _lbv6 (- root 1)))
(assert (= _lbv7 (- s01 1)))
(assert (= _lbv8 (- s 1)))
(assert (> s0 s01))
(assert (= var_v3 false))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= var_v3 true) (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (not (or (> s |0|) (= s |0|))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term root
 
 Type of the Scalar Term {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }
 ################################################
 Skipping Variable root As this a  Formal Parameter to the current function Call
 ################################################
 
 Enumerating a Scalar Term _lbv6
 
 Type of the Scalar Term {v:Ty_int | (v) ==((root) -- (1))}                                                                                                                                                               
# of Final Z3 expressions 33
 Final solver 
 (declare-sort T326)
(declare-fun tlen (T326) Int)
(declare-fun leaf () T326)
(declare-fun |0| () Int)
(declare-fun _lbv0 () Int)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv2 () Int)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv5 () Bool)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv7 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv6 () Int)
(assert (= (tlen leaf) 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (or (> _lbv0 |0|) (= _lbv0 |0|)))
(assert (= _lbv1 (- s0 1)))
(assert (= _lbv2 (- _lbv0 1)))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv4 true) (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv5 true) (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= var_v3 true) (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (or (> root |0|) (= root |0|)))
(assert (= _lbv7 (- s01 1)))
(assert (= _lbv8 (- s 1)))
(assert (> s0 s01))
(assert (= _lbv6 (- root 1)))
(assert (= var_v3 false))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= var_v3 true) (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|)))))
(assert (= _lbv6 (- root 1)))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (not (or (> _lbv6 |0|) (= _lbv6 |0|))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term _lbv7
 
 Type of the Scalar Term {v:Ty_int | (v) ==((s01) -- (1))}                                                                                                                                                               
# of Final Z3 expressions 33
 Final solver 
 (declare-sort T332)
(declare-fun tlen (T332) Int)
(declare-fun leaf () T332)
(declare-fun |0| () Int)
(declare-fun _lbv0 () Int)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv2 () Int)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv5 () Bool)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun _lbv6 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun s01 () Int)
(declare-fun _lbv7 () Int)
(assert (= (tlen leaf) 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (or (> _lbv0 |0|) (= _lbv0 |0|)))
(assert (= _lbv1 (- s0 1)))
(assert (= _lbv2 (- _lbv0 1)))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv4 true) (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv5 true) (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= var_v3 true) (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (or (> root |0|) (= root |0|)))
(assert (= _lbv6 (- root 1)))
(assert (= _lbv8 (- s 1)))
(assert (> s0 s01))
(assert (= _lbv7 (- s01 1)))
(assert (= var_v3 false))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= var_v3 true) (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|)))))
(assert (= _lbv7 (- s01 1)))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (not (or (> _lbv7 |0|) (= _lbv7 |0|))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term _lbv8
 
 Type of the Scalar Term {v:Ty_int | (v) ==((s) -- (1))}                                                                                                                                                               
# of Final Z3 expressions 33
 Final solver 
 (declare-sort T338)
(declare-fun tlen (T338) Int)
(declare-fun leaf () T338)
(declare-fun |0| () Int)
(declare-fun _lbv0 () Int)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv2 () Int)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv5 () Bool)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun _lbv6 () Int)
(declare-fun s01 () Int)
(declare-fun _lbv7 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(assert (= (tlen leaf) 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (or (> _lbv0 |0|) (= _lbv0 |0|)))
(assert (= _lbv1 (- s0 1)))
(assert (= _lbv2 (- _lbv0 1)))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv4 true) (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv5 true) (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= var_v3 true) (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (or (> root |0|) (= root |0|)))
(assert (= _lbv6 (- root 1)))
(assert (= _lbv7 (- s01 1)))
(assert (> s0 s01))
(assert (= _lbv8 (- s 1)))
(assert (= var_v3 false))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= var_v3 true) (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|)))))
(assert (= _lbv8 (- s 1)))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (not (or (> _lbv8 |0|) (= _lbv8 |0|))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term sizel
 
 Type of the Scalar Term {v:Ty_int | true}
 ################################################
 Skipping Variable sizel As this a  Formal Parameter to the current function Call
 ################################################
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {v:Ty_int | true}                                                                                                                                                               
# of Final Z3 expressions 32
 Final solver 
 (declare-sort T344)
(declare-fun tlen (T344) Int)
(declare-fun leaf () T344)
(declare-fun |0| () Int)
(declare-fun _lbv0 () Int)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv2 () Int)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv5 () Bool)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun _lbv6 () Int)
(declare-fun s01 () Int)
(declare-fun _lbv7 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun n () Int)
(assert (= (tlen leaf) 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (or (> _lbv0 |0|) (= _lbv0 |0|)))
(assert (= _lbv1 (- s0 1)))
(assert (= _lbv2 (- _lbv0 1)))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv4 true) (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv5 true) (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= var_v3 true) (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (or (> root |0|) (= root |0|)))
(assert (= _lbv6 (- root 1)))
(assert (= _lbv7 (- s01 1)))
(assert (= _lbv8 (- s 1)))
(assert (> s0 s01))
(assert (= var_v3 false))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= var_v3 true) (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (not (or (> n |0|) (= n |0|))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term s01
 
 Type of the Scalar Term {v:Ty_int | 
 	 Conj <c true
 	 , s0 > v >c }                                                                                                                                                                    
# of Final Z3 expressions 33
 Final solver 
 (declare-sort T350)
(declare-fun tlen (T350) Int)
(declare-fun leaf () T350)
(declare-fun |0| () Int)
(declare-fun _lbv0 () Int)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv2 () Int)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv5 () Bool)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun _lbv6 () Int)
(declare-fun s01 () Int)
(declare-fun _lbv7 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(assert (= (tlen leaf) 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (or (> _lbv0 |0|) (= _lbv0 |0|)))
(assert (= _lbv1 (- s0 1)))
(assert (= _lbv2 (- _lbv0 1)))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv4 true) (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv5 true) (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= var_v3 true) (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (or (> root |0|) (= root |0|)))
(assert (= _lbv6 (- root 1)))
(assert (= _lbv7 (- s01 1)))
(assert (= _lbv8 (- s 1)))
(assert (> s0 s01))
(assert (= var_v3 false))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= var_v3 true) (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|)))))
(assert (> s0 s01))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (not (or (> s01 |0|) (= s01 |0|))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 
 FaileD the subtype check T_vi <: T_goal
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  , 
 subs, 
 int_gen
 ############################################################
  Synthesizing the Function application Pure Component subs
 ############################################################
  *************** Trying Arrow Component ************subs :  Arrow ( ( n : {v:Ty_int | true} ) -> {v:Ty_int | (v) ==((n) -- (1))}
  *************** Synthesizing Args ei : ti for ************subs
 ##################################################################################
  Synthesizing the 1th argument for Function subs
  Trying Arguments in Scalars 
 esynthesizeScalar for {v:Ty_int | true}
 
 Enumerating a Scalar Term s0
 
 Type of the Scalar Term {v:Ty_int | true}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term _lbv0
 
 Type of the Scalar Term {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 Enumerating a Scalar Term _lbv1
 
 Type of the Scalar Term {v:Ty_int | (v) ==((s0) -- (1))}
 ################################################
 Skipping Variable _lbv1 As Outer Function Call is subs
 
 Enumerating a Scalar Term _lbv2
 
 Type of the Scalar Term {v:Ty_int | (v) ==((_lbv0) -- (1))}
 ################################################
 Skipping Variable _lbv2 As Outer Function Call is subs
 
 Enumerating a Scalar Term s
 
 Type of the Scalar Term {var_v0:Ty_int | true}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term root
 
 Type of the Scalar Term {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term _lbv6
 
 Type of the Scalar Term {v:Ty_int | (v) ==((root) -- (1))}
 ################################################
 Skipping Variable _lbv6 As Outer Function Call is subs
 
 Enumerating a Scalar Term _lbv7
 
 Type of the Scalar Term {v:Ty_int | (v) ==((s01) -- (1))}
 ################################################
 Skipping Variable _lbv7 As Outer Function Call is subs
 
 Enumerating a Scalar Term _lbv8
 
 Type of the Scalar Term {v:Ty_int | (v) ==((s) -- (1))}
 ################################################
 Skipping Variable _lbv8 As Outer Function Call is subs
 
 Enumerating a Scalar Term sizel
 
 Type of the Scalar Term {v:Ty_int | true}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {v:Ty_int | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 ################################################
 
 Enumerating a Scalar Term s01
 
 Type of the Scalar Term {v:Ty_int | 
 	 Conj <c true
 	 , s0 > v >c }
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>> 1th Args option for subs : s01
 >>>>>>>>>>>>>>>>>>> 1th Args option for subs : sizel
 >>>>>>>>>>>>>>>>>>> 1th Args option for subs : root
 >>>>>>>>>>>>>>>>>>> 1th Args option for subs : s
 >>>>>>>>>>>>>>>>>>> 1th Args option for subs : apply int_gen  (, dummy )
 >>>>>>>>>>>>>>>>>>> 1th Args option for subs : s0
 TEST Overall List : List of Args for subs
 EI s01
 EI sizel
 EI root
 EI s
 EI apply int_gen  (, dummy )
 EI s0
 ##################################################################################
  *************** Successfully Synthesized Args ei Forall i 
 Ith Argument Options for subs
 EI s01
 EI sizel
 EI root
 EI s
 EI apply int_gen  (, dummy )
 EI s0
 # of Possible Argument Options for subs 6
 Possible Arg Options 
 EI s01
 Possible Arg Options 
 EI sizel
 Possible Arg Options 
 EI root
 Possible Arg Options 
 EI s
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 Possible Arg Options 
 EI s0
 Apply Single Argument Case : f (ei) Case subs
  Case : f (ei) Case subs s01
 Finding Already seen tree for apply subs  (, s01 )
 Found _lbv7
  Case : f (ei) Case subs sizel
 Finding Already seen tree for apply subs  (, sizel )
 Typechecking the Term apply subs  (, sizel )
 Against {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }
 Argument sizel :: {v:Ty_int | true} | true
 AppType Type {v:Ty_int | (v) ==((sizel) -- (1))}                                                                                                                                                               
# of Final Z3 expressions 34
 Final solver 
 (declare-sort T362)
(declare-fun tlen (T362) Int)
(declare-fun leaf () T362)
(declare-fun |0| () Int)
(declare-fun _lbv0 () Int)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv2 () Int)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv5 () Bool)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun _lbv6 () Int)
(declare-fun s01 () Int)
(declare-fun _lbv7 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun sizel () Int)
(declare-fun v () Int)
(assert (= (tlen leaf) 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (or (> _lbv0 |0|) (= _lbv0 |0|)))
(assert (= _lbv1 (- s0 1)))
(assert (= _lbv2 (- _lbv0 1)))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv4 true) (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv5 true) (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= var_v3 true) (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (or (> root |0|) (= root |0|)))
(assert (= _lbv6 (- root 1)))
(assert (= _lbv7 (- s01 1)))
(assert (= _lbv8 (- s 1)))
(assert (> s0 s01))
(assert (= v (- sizel 1)))
(assert (= var_v3 false))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= var_v3 true) (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|)))))
(assert (= v (- sizel 1)))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (not (or (> v |0|) (= v |0|))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply subs  (, sizel )
  Case : f (ei) Case subs root
 Finding Already seen tree for apply subs  (, root )
 Found _lbv6
  Case : f (ei) Case subs s
 Finding Already seen tree for apply subs  (, s )
 Found _lbv8
  Case : f (ei) Case subs _lbv0
 Finding Already seen tree for apply subs  (, _lbv0 )
 Found _lbv2
  Case : f (ei) Case subs s0
 Finding Already seen tree for apply subs  (, s0 )
 Found _lbv1
 >>>>>>>>>>>>>>>>>>> 1th Args option for node : apply int_gen  (, dummy )
 >>>>>>>>>>>>>>>>>>> 1th Args option for node : apply subs  (, s0 )
 >>>>>>>>>>>>>>>>>>> 1th Args option for node : apply subs  (, apply int_gen  (, dummy ) )
 >>>>>>>>>>>>>>>>>>> 1th Args option for node : apply subs  (, s )
 >>>>>>>>>>>>>>>>>>> 1th Args option for node : apply subs  (, root )
 >>>>>>>>>>>>>>>>>>> 1th Args option for node : apply subs  (, s01 )
 TEST Overall List : List of Args for node
 EI apply int_gen  (, dummy )
 EI apply subs  (, s0 )
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI apply subs  (, s )
 EI apply subs  (, root )
 EI apply subs  (, s01 )
 ##################################################################################
  Synthesizing the 2th argument for Function node
  Trying Arguments in Scalars 
 esynthesizeScalar for {v:Ty_int | true}
 
 Enumerating a Scalar Term s0
 
 Type of the Scalar Term {v:Ty_int | true}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term _lbv0
 
 Type of the Scalar Term {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 Enumerating a Scalar Term _lbv1
 
 Type of the Scalar Term {v:Ty_int | (v) ==((s0) -- (1))}
 ################################################
 Skipping Variable _lbv1 As Outer Function Call is subs
 
 Enumerating a Scalar Term _lbv2
 
 Type of the Scalar Term {v:Ty_int | (v) ==((_lbv0) -- (1))}
 ################################################
 Skipping Variable _lbv2 As Outer Function Call is subs
 
 Enumerating a Scalar Term s
 
 Type of the Scalar Term {var_v0:Ty_int | true}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term _lbv6
 
 Type of the Scalar Term {v:Ty_int | (v) ==((root) -- (1))}
 ################################################
 Skipping Variable _lbv6 As Outer Function Call is subs
 
 Enumerating a Scalar Term _lbv7
 
 Type of the Scalar Term {v:Ty_int | (v) ==((s01) -- (1))}
 ################################################
 Skipping Variable _lbv7 As Outer Function Call is subs
 
 Enumerating a Scalar Term _lbv8
 
 Type of the Scalar Term {v:Ty_int | (v) ==((s) -- (1))}
 ################################################
 Skipping Variable _lbv8 As Outer Function Call is subs
 
 Enumerating a Scalar Term sizel
 
 Type of the Scalar Term {v:Ty_int | true}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term s01
 
 Type of the Scalar Term {v:Ty_int | 
 	 Conj <c true
 	 , s0 > v >c }
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {v:Ty_int | true}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term root
 
 Type of the Scalar Term {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  , 
 subs, 
 int_gen
 ############################################################
  Synthesizing the Function application Pure Component subs
 ############################################################
 ############################################################
  Synthesizing the Function application Pure Component int_gen
 ############################################################
  *************** Trying Arrow Component ************int_gen :  Arrow ( ( d : {var_v1:Ty_unit | true} ) -> {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }
  *************** Synthesizing Args ei : ti for ************int_gen
 ##################################################################################
  Synthesizing the 1th argument for Function int_gen
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v1:Ty_unit | true}
 
 Enumerating a Scalar Term dummy
 
 Type of the Scalar Term {v:Ty_unit | true}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term d
 
 Type of the Scalar Term {var_v1:Ty_unit | true}
 ################################################
 Skipping Variable d As this a  Formal Parameter to the current function Call
 ################################################
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>> 1th Args option for int_gen : dummy
 TEST Overall List : List of Args for int_gen
 EI dummy
 ##################################################################################
  *************** Successfully Synthesized Args ei Forall i 
 Ith Argument Options for int_gen
 EI dummy
 # of Possible Argument Options for int_gen 1
 Possible Arg Options 
 EI dummy
 Apply Single Argument Case : f (ei) Case int_gen
  Case : f (ei) Case int_gen dummy
 Finding Already seen tree for apply int_gen  (, dummy )
 Found _lbv0
 >>>>>>>>>>>>>>>>>>> 2th Args option for node : root
 >>>>>>>>>>>>>>>>>>> 2th Args option for node : n
 >>>>>>>>>>>>>>>>>>> 2th Args option for node : s01
 >>>>>>>>>>>>>>>>>>> 2th Args option for node : sizel
 >>>>>>>>>>>>>>>>>>> 2th Args option for node : s
 >>>>>>>>>>>>>>>>>>> 2th Args option for node : apply int_gen  (, dummy )
 >>>>>>>>>>>>>>>>>>> 2th Args option for node : s0
 >>>>>>>>>>>>>>>>>>> 2th Args option for node : apply int_gen  (, dummy )
 TEST Overall List : List of Args for node
 EI root
 EI n
 EI s01
 EI sizel
 EI s
 EI apply int_gen  (, dummy )
 EI s0
 EI apply int_gen  (, dummy )
 TEST Overall List : List of Args for node
 EI apply int_gen  (, dummy )
 EI apply subs  (, s0 )
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI apply subs  (, s )
 EI apply subs  (, root )
 EI apply subs  (, s01 )
 ##################################################################################
  Synthesizing the 3th argument for Function node
  Trying Arguments in Scalars 
 esynthesizeScalar for {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 
 Enumerating a Scalar Term leaf
 
 Type of the Scalar Term {v:Ty_alphatree | (tlen)(v) ==(0)}                                                                                                                                                    
# of Final Z3 expressions 31
 Final solver 
 (declare-sort T377)
(declare-fun |0| () Int)
(declare-fun _lbv0 () Int)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv2 () Int)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv5 () Bool)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun _lbv6 () Int)
(declare-fun s01 () Int)
(declare-fun _lbv7 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun tlen (T377) Int)
(declare-fun leaf () T377)
(declare-fun sizel () Int)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (or (> _lbv0 |0|) (= _lbv0 |0|)))
(assert (= _lbv1 (- s0 1)))
(assert (= _lbv2 (- _lbv0 1)))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv4 true) (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv5 true) (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= var_v3 true) (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|)))))
(assert (= _lbv6 (- root 1)))
(assert (= _lbv7 (- s01 1)))
(assert (= _lbv8 (- s 1)))
(assert (> s0 s01))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (or (> root |0|) (= root |0|)))
(assert (= (tlen leaf) 0))
(assert (= var_v3 false))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= var_v3 true) (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|)))))
(assert (= (tlen leaf) 0))
(assert (not (forall ((var_u40 Int)) (= (tlen leaf) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 
 FaileD the subtype check T_vi <: T_goal
 >>>>>>>>>>>>>>>>>> No Scalar found in Environment, Trying esynthesizePureApp <<<<<<<<<<<<<<<<<< 
  Entering Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  , 
 goal, 
 node
 ############################################################
  Synthesizing the Function application Pure Component goal
 ############################################################
  *************** Trying Arrow Component ************goal :  Arrow ( ( s01 : {v:Ty_int | 
 	 Conj <c true
 	 , s0 > v >c } ) -> {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (tlen)(v) ==(u)
 	 u = s01 > }}
  *************** Synthesizing Args ei : ti for ************goal
 ##################################################################################
  Synthesizing the 1th argument for Function goal
  Trying Arguments in Scalars 
 esynthesizeScalar for {v:Ty_int | 
 	 Conj <c true
 	 , s0 > v >c }
 
 Enumerating a Scalar Term s0
 
 Type of the Scalar Term {v:Ty_int | true}                                                                                                                                                         
# of Final Z3 expressions 30
 Final solver 
 (declare-sort T382)
(declare-fun tlen (T382) Int)
(declare-fun leaf () T382)
(declare-fun |0| () Int)
(declare-fun _lbv0 () Int)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv2 () Int)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv5 () Bool)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun _lbv6 () Int)
(declare-fun s01 () Int)
(declare-fun _lbv7 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(assert (= (tlen leaf) 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (or (> _lbv0 |0|) (= _lbv0 |0|)))
(assert (= _lbv1 (- s0 1)))
(assert (= _lbv2 (- _lbv0 1)))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv4 true) (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv5 true) (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= var_v3 true) (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|)))))
(assert (= _lbv6 (- root 1)))
(assert (= _lbv7 (- s01 1)))
(assert (= _lbv8 (- s 1)))
(assert (> s0 s01))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (or (> root |0|) (= root |0|)))
(assert (= var_v3 false))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= var_v3 true) (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|)))))
(assert (not (> s0 s0)))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term _lbv0
 
 Type of the Scalar Term {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }                                                                                                                                                                    
# of Final Z3 expressions 33
 Final solver 
 (declare-sort T388)
(declare-fun tlen (T388) Int)
(declare-fun leaf () T388)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv0 () Int)
(declare-fun _lbv2 () Int)
(declare-fun |0| () Int)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv5 () Bool)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun _lbv6 () Int)
(declare-fun s01 () Int)
(declare-fun _lbv7 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(assert (= (tlen leaf) 0))
(assert (= _lbv1 (- s0 1)))
(assert (= _lbv2 (- _lbv0 1)))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv4 true) (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv5 true) (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= var_v3 true) (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|)))))
(assert (= _lbv6 (- root 1)))
(assert (= _lbv7 (- s01 1)))
(assert (= _lbv8 (- s 1)))
(assert (> s0 s01))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (or (> root |0|) (= root |0|)))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (or (> _lbv0 |0|) (= _lbv0 |0|)))
(assert (= var_v3 false))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= var_v3 true) (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (or (> _lbv0 |0|) (= _lbv0 |0|)))
(assert (not (> s0 _lbv0)))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term _lbv1
 
 Type of the Scalar Term {v:Ty_int | (v) ==((s0) -- (1))}                                                                                                                                                         
# of Final Z3 expressions 31
 Final solver 
 (declare-sort T394)
(declare-fun tlen (T394) Int)
(declare-fun leaf () T394)
(declare-fun |0| () Int)
(declare-fun _lbv0 () Int)
(declare-fun _lbv2 () Int)
(declare-fun s0 () Int)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun _lbv6 () Int)
(declare-fun s01 () Int)
(declare-fun _lbv7 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(assert (= (tlen leaf) 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (or (> _lbv0 |0|) (= _lbv0 |0|)))
(assert (= _lbv2 (- _lbv0 1)))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv4 true) (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv5 true) (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= var_v3 true) (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|)))))
(assert (= _lbv6 (- root 1)))
(assert (= _lbv7 (- s01 1)))
(assert (= _lbv8 (- s 1)))
(assert (> s0 s01))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (or (> root |0|) (= root |0|)))
(assert (= _lbv1 (- s0 1)))
(assert (= var_v3 false))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= var_v3 true) (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|)))))
(assert (= _lbv1 (- s0 1)))
(assert (not (> s0 _lbv1)))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 Enumerating a Scalar Term _lbv2
 
 Type of the Scalar Term {v:Ty_int | (v) ==((_lbv0) -- (1))}                                                                                                                                                         
# of Final Z3 expressions 31
 Final solver 
 (declare-sort T400)
(declare-fun tlen (T400) Int)
(declare-fun leaf () T400)
(declare-fun |0| () Int)
(declare-fun _lbv0 () Int)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv5 () Bool)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun _lbv6 () Int)
(declare-fun s01 () Int)
(declare-fun _lbv7 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(assert (= (tlen leaf) 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (or (> _lbv0 |0|) (= _lbv0 |0|)))
(assert (= _lbv1 (- s0 1)))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv4 true) (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv5 true) (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= var_v3 true) (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|)))))
(assert (= _lbv6 (- root 1)))
(assert (= _lbv7 (- s01 1)))
(assert (= _lbv8 (- s 1)))
(assert (> s0 s01))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (or (> root |0|) (= root |0|)))
(assert (= _lbv2 (- _lbv0 1)))
(assert (= var_v3 false))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= var_v3 true) (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|)))))
(assert (= _lbv2 (- _lbv0 1)))
(assert (not (> s0 _lbv2)))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term s
 
 Type of the Scalar Term {var_v0:Ty_int | true}                                                                                                                                                         
# of Final Z3 expressions 30
 Final solver 
 (declare-sort T406)
(declare-fun tlen (T406) Int)
(declare-fun leaf () T406)
(declare-fun |0| () Int)
(declare-fun _lbv0 () Int)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv2 () Int)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv5 () Bool)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun _lbv6 () Int)
(declare-fun s01 () Int)
(declare-fun _lbv7 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(assert (= (tlen leaf) 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (or (> _lbv0 |0|) (= _lbv0 |0|)))
(assert (= _lbv1 (- s0 1)))
(assert (= _lbv2 (- _lbv0 1)))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv4 true) (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv5 true) (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= var_v3 true) (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|)))))
(assert (= _lbv6 (- root 1)))
(assert (= _lbv7 (- s01 1)))
(assert (= _lbv8 (- s 1)))
(assert (> s0 s01))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (or (> root |0|) (= root |0|)))
(assert (= var_v3 false))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= var_v3 true) (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|)))))
(assert (not (> s0 s)))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term _lbv6
 
 Type of the Scalar Term {v:Ty_int | (v) ==((root) -- (1))}                                                                                                                                                         
# of Final Z3 expressions 31
 Final solver 
 (declare-sort T412)
(declare-fun tlen (T412) Int)
(declare-fun leaf () T412)
(declare-fun |0| () Int)
(declare-fun _lbv0 () Int)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv2 () Int)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv5 () Bool)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun _lbv7 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun root () Int)
(declare-fun _lbv6 () Int)
(assert (= (tlen leaf) 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (or (> _lbv0 |0|) (= _lbv0 |0|)))
(assert (= _lbv1 (- s0 1)))
(assert (= _lbv2 (- _lbv0 1)))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv4 true) (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv5 true) (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= var_v3 true) (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|)))))
(assert (= _lbv7 (- s01 1)))
(assert (= _lbv8 (- s 1)))
(assert (> s0 s01))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (or (> root |0|) (= root |0|)))
(assert (= _lbv6 (- root 1)))
(assert (= var_v3 false))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= var_v3 true) (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|)))))
(assert (= _lbv6 (- root 1)))
(assert (not (> s0 _lbv6)))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term _lbv7
 
 Type of the Scalar Term {v:Ty_int | (v) ==((s01) -- (1))}                                                                                                                                                         
# of Final Z3 expressions 31
 Final solver 
 (declare-sort T418)
(declare-fun tlen (T418) Int)
(declare-fun leaf () T418)
(declare-fun |0| () Int)
(declare-fun _lbv0 () Int)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv2 () Int)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv5 () Bool)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun _lbv6 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun s01 () Int)
(declare-fun _lbv7 () Int)
(assert (= (tlen leaf) 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (or (> _lbv0 |0|) (= _lbv0 |0|)))
(assert (= _lbv1 (- s0 1)))
(assert (= _lbv2 (- _lbv0 1)))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv4 true) (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv5 true) (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= var_v3 true) (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|)))))
(assert (= _lbv6 (- root 1)))
(assert (= _lbv8 (- s 1)))
(assert (> s0 s01))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (or (> root |0|) (= root |0|)))
(assert (= _lbv7 (- s01 1)))
(assert (= var_v3 false))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= var_v3 true) (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|)))))
(assert (= _lbv7 (- s01 1)))
(assert (not (> s0 _lbv7)))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 Enumerating a Scalar Term _lbv8
 
 Type of the Scalar Term {v:Ty_int | (v) ==((s) -- (1))}                                                                                                                                                         
# of Final Z3 expressions 31
 Final solver 
 (declare-sort T424)
(declare-fun tlen (T424) Int)
(declare-fun leaf () T424)
(declare-fun |0| () Int)
(declare-fun _lbv0 () Int)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv2 () Int)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv5 () Bool)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun _lbv6 () Int)
(declare-fun s01 () Int)
(declare-fun _lbv7 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(assert (= (tlen leaf) 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (or (> _lbv0 |0|) (= _lbv0 |0|)))
(assert (= _lbv1 (- s0 1)))
(assert (= _lbv2 (- _lbv0 1)))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv4 true) (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv5 true) (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= var_v3 true) (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|)))))
(assert (= _lbv6 (- root 1)))
(assert (= _lbv7 (- s01 1)))
(assert (> s0 s01))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (or (> root |0|) (= root |0|)))
(assert (= _lbv8 (- s 1)))
(assert (= var_v3 false))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= var_v3 true) (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|)))))
(assert (= _lbv8 (- s 1)))
(assert (not (> s0 _lbv8)))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term s01
 
 Type of the Scalar Term {v:Ty_int | 
 	 Conj <c true
 	 , s0 > v >c }
 ################################################
 Skipping Variable s01 As this a  Formal Parameter to the current function Call
 ################################################
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {v:Ty_int | true}                                                                                                                                                         
# of Final Z3 expressions 30
 Final solver 
 (declare-sort T430)
(declare-fun tlen (T430) Int)
(declare-fun leaf () T430)
(declare-fun |0| () Int)
(declare-fun _lbv0 () Int)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv2 () Int)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv5 () Bool)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun _lbv6 () Int)
(declare-fun s01 () Int)
(declare-fun _lbv7 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun n () Int)
(assert (= (tlen leaf) 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (or (> _lbv0 |0|) (= _lbv0 |0|)))
(assert (= _lbv1 (- s0 1)))
(assert (= _lbv2 (- _lbv0 1)))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv4 true) (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv5 true) (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= var_v3 true) (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|)))))
(assert (= _lbv6 (- root 1)))
(assert (= _lbv7 (- s01 1)))
(assert (= _lbv8 (- s 1)))
(assert (> s0 s01))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (or (> root |0|) (= root |0|)))
(assert (= var_v3 false))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= var_v3 true) (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|)))))
(assert (not (> s0 n)))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term root
 
 Type of the Scalar Term {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }                                                                                                                                                                    
# of Final Z3 expressions 33
 Final solver 
 (declare-sort T436)
(declare-fun tlen (T436) Int)
(declare-fun leaf () T436)
(declare-fun |0| () Int)
(declare-fun _lbv0 () Int)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv2 () Int)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv5 () Bool)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun _lbv6 () Int)
(declare-fun s01 () Int)
(declare-fun _lbv7 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(assert (= (tlen leaf) 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (or (> _lbv0 |0|) (= _lbv0 |0|)))
(assert (= _lbv1 (- s0 1)))
(assert (= _lbv2 (- _lbv0 1)))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv4 true) (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv5 true) (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= var_v3 true) (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|)))))
(assert (= _lbv6 (- root 1)))
(assert (= _lbv7 (- s01 1)))
(assert (= _lbv8 (- s 1)))
(assert (> s0 s01))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (or (> root |0|) (= root |0|)))
(assert (= var_v3 false))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= var_v3 true) (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (or (> root |0|) (= root |0|)))
(assert (not (> s0 root)))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term sizel
 
 Type of the Scalar Term {v:Ty_int | true}                                                                                                                                                         
# of Final Z3 expressions 30
 Final solver 
 (declare-sort T442)
(declare-fun tlen (T442) Int)
(declare-fun leaf () T442)
(declare-fun |0| () Int)
(declare-fun _lbv0 () Int)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv2 () Int)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv5 () Bool)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun _lbv6 () Int)
(declare-fun s01 () Int)
(declare-fun _lbv7 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun sizel () Int)
(assert (= (tlen leaf) 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (or (> _lbv0 |0|) (= _lbv0 |0|)))
(assert (= _lbv1 (- s0 1)))
(assert (= _lbv2 (- _lbv0 1)))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv4 true) (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv5 true) (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= var_v3 true) (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|)))))
(assert (= _lbv6 (- root 1)))
(assert (= _lbv7 (- s01 1)))
(assert (= _lbv8 (- s 1)))
(assert (> s0 s01))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (or (> root |0|) (= root |0|)))
(assert (= var_v3 false))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= var_v3 true) (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|)))))
(assert (not (> s0 sizel)))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 
 FaileD the subtype check T_vi <: T_goal
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>> 1th Args option for goal : apply subs  (, s01 )
 >>>>>>>>>>>>>>>>>>> 1th Args option for goal : apply subs  (, s0 )
 TEST Overall List : List of Args for goal
 EI apply subs  (, s01 )
 EI apply subs  (, s0 )
 ##################################################################################
  *************** Successfully Synthesized Args ei Forall i 
 Ith Argument Options for goal
 EI apply subs  (, s01 )
 EI apply subs  (, s0 )
 # of Possible Argument Options for goal 2
 Possible Arg Options 
 EI apply subs  (, s01 )
 Possible Arg Options 
 EI apply subs  (, s0 )
 Apply Single Argument Case : f (ei) Case goal
  Case : f (ei) Case goal _lbv7
 Finding Already seen tree for apply goal  (, _lbv7 )
 Typechecking the Term apply goal  (, _lbv7 )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv7 :: {v:Ty_int | (v) ==((s01) -- (1))} | (_lbv7) ==((s01) -- (1))
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (tlen)(v) ==(u)
 	 u = _lbv7 > }}                                                                                                                                                                
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T448)
(declare-fun |0| () Int)
(declare-fun _lbv7 () Int)
(declare-fun tlen (T448) Int)
(declare-fun v () T448)
(declare-fun s01 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T448)
(declare-fun sizel () Int)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u42 Int) (var_u41 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (or (> root |0|) (= root |0|))
         (> s0 s01)
         (=> (= (tlen v) var_u41) (= var_u41 _lbv7))
         (= var_v3 false)
         a!4
         (= _lbv7 (- s01 1))
         (=> (= (tlen v) var_u42) (= var_u42 _lbv7))))))
(assert (not (forall ((var_u43 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply goal  (, _lbv7 )
  Case : f (ei) Case goal _lbv1
 Finding Already seen tree for apply goal  (, _lbv1 )
 Typechecking the Term apply goal  (, _lbv1 )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (tlen)(v) ==(u)
 	 u = _lbv1 > }}                                                                                                                                                                
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T454)
(declare-fun |0| () Int)
(declare-fun _lbv1 () Int)
(declare-fun tlen (T454) Int)
(declare-fun v () T454)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun root () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T454)
(declare-fun sizel () Int)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u45 Int) (var_u44 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (or (> root |0|) (= root |0|))
         (> s0 s01)
         (=> (= (tlen v) var_u44) (= var_u44 _lbv1))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (=> (= (tlen v) var_u45) (= var_u45 _lbv1))))))
(assert (not (forall ((var_u46 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply goal  (, _lbv1 )
  ###################################################
  The Choice of Function goal Was Ill Fated Try Next Choice of function
 ############################################################
  Synthesizing the Function application Pure Component node
 ############################################################
  *************** Trying Arrow Component ************node :  Arrow ( ( root : {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } ) ->  Arrow ( ( sizel : {v:Ty_int | true} ) ->  Arrow ( ( ltree : {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} ) ->  Arrow ( ( sizer : {v:Ty_int | true} ) ->  Arrow ( ( rtree : {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} ) -> {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((sizel) + (1))
 	 (tlen)(v) ==(u) > }}
  *************** Synthesizing Args ei : ti for ************node
 ##################################################################################
  Synthesizing the 1th argument for Function node
  Trying Arguments in Scalars 
 esynthesizeScalar for {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }
 
 Enumerating a Scalar Term s0
 
 Type of the Scalar Term {v:Ty_int | true}                                                                                                                                                               
# of Final Z3 expressions 32
 Final solver 
 (declare-sort T460)
(declare-fun tlen (T460) Int)
(declare-fun leaf () T460)
(declare-fun |0| () Int)
(declare-fun _lbv0 () Int)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv2 () Int)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv5 () Bool)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun _lbv6 () Int)
(declare-fun s01 () Int)
(declare-fun _lbv7 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(assert (= (tlen leaf) 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (or (> _lbv0 |0|) (= _lbv0 |0|)))
(assert (= _lbv1 (- s0 1)))
(assert (= _lbv2 (- _lbv0 1)))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv4 true) (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv5 true) (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= var_v3 true) (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|)))))
(assert (= _lbv6 (- root 1)))
(assert (= _lbv7 (- s01 1)))
(assert (= _lbv8 (- s 1)))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (or (> root |0|) (= root |0|)))
(assert (> s0 s01))
(assert (= var_v3 false))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= var_v3 true) (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (not (or (> s0 |0|) (= s0 |0|))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term _lbv0
 
 Type of the Scalar Term {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }                                                                                                                                                                          
# of Final Z3 expressions 35
 Final solver 
 (declare-sort T466)
(declare-fun tlen (T466) Int)
(declare-fun leaf () T466)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv0 () Int)
(declare-fun _lbv2 () Int)
(declare-fun |0| () Int)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv5 () Bool)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun _lbv6 () Int)
(declare-fun s01 () Int)
(declare-fun _lbv7 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(assert (= (tlen leaf) 0))
(assert (= _lbv1 (- s0 1)))
(assert (= _lbv2 (- _lbv0 1)))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv4 true) (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv5 true) (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= var_v3 true) (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|)))))
(assert (= _lbv6 (- root 1)))
(assert (= _lbv7 (- s01 1)))
(assert (= _lbv8 (- s 1)))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (or (> root |0|) (= root |0|)))
(assert (> s0 s01))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (or (> _lbv0 |0|) (= _lbv0 |0|)))
(assert (= var_v3 false))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= var_v3 true) (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (or (> _lbv0 |0|) (= _lbv0 |0|)))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (not (or (> _lbv0 |0|) (= _lbv0 |0|))))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 Enumerating a Scalar Term _lbv1
 
 Type of the Scalar Term {v:Ty_int | (v) ==((s0) -- (1))}                                                                                                                                                               
# of Final Z3 expressions 33
 Final solver 
 (declare-sort T472)
(declare-fun tlen (T472) Int)
(declare-fun leaf () T472)
(declare-fun |0| () Int)
(declare-fun _lbv0 () Int)
(declare-fun _lbv2 () Int)
(declare-fun s0 () Int)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun _lbv6 () Int)
(declare-fun s01 () Int)
(declare-fun _lbv7 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(assert (= (tlen leaf) 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (or (> _lbv0 |0|) (= _lbv0 |0|)))
(assert (= _lbv2 (- _lbv0 1)))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv4 true) (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv5 true) (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= var_v3 true) (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|)))))
(assert (= _lbv6 (- root 1)))
(assert (= _lbv7 (- s01 1)))
(assert (= _lbv8 (- s 1)))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (or (> root |0|) (= root |0|)))
(assert (> s0 s01))
(assert (= _lbv1 (- s0 1)))
(assert (= var_v3 false))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= var_v3 true) (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|)))))
(assert (= _lbv1 (- s0 1)))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (not (or (> _lbv1 |0|) (= _lbv1 |0|))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term _lbv2
 
 Type of the Scalar Term {v:Ty_int | (v) ==((_lbv0) -- (1))}                                                                                                                                                               
# of Final Z3 expressions 33
 Final solver 
 (declare-sort T478)
(declare-fun tlen (T478) Int)
(declare-fun leaf () T478)
(declare-fun |0| () Int)
(declare-fun _lbv0 () Int)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv5 () Bool)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun _lbv6 () Int)
(declare-fun s01 () Int)
(declare-fun _lbv7 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(assert (= (tlen leaf) 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (or (> _lbv0 |0|) (= _lbv0 |0|)))
(assert (= _lbv1 (- s0 1)))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv4 true) (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv5 true) (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= var_v3 true) (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|)))))
(assert (= _lbv6 (- root 1)))
(assert (= _lbv7 (- s01 1)))
(assert (= _lbv8 (- s 1)))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (or (> root |0|) (= root |0|)))
(assert (> s0 s01))
(assert (= _lbv2 (- _lbv0 1)))
(assert (= var_v3 false))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= var_v3 true) (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|)))))
(assert (= _lbv2 (- _lbv0 1)))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (not (or (> _lbv2 |0|) (= _lbv2 |0|))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term s
 
 Type of the Scalar Term {var_v0:Ty_int | true}                                                                                                                                                               
# of Final Z3 expressions 32
 Final solver 
 (declare-sort T484)
(declare-fun tlen (T484) Int)
(declare-fun leaf () T484)
(declare-fun |0| () Int)
(declare-fun _lbv0 () Int)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv2 () Int)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv5 () Bool)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun _lbv6 () Int)
(declare-fun s01 () Int)
(declare-fun _lbv7 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(assert (= (tlen leaf) 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (or (> _lbv0 |0|) (= _lbv0 |0|)))
(assert (= _lbv1 (- s0 1)))
(assert (= _lbv2 (- _lbv0 1)))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv4 true) (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv5 true) (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= var_v3 true) (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|)))))
(assert (= _lbv6 (- root 1)))
(assert (= _lbv7 (- s01 1)))
(assert (= _lbv8 (- s 1)))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (or (> root |0|) (= root |0|)))
(assert (> s0 s01))
(assert (= var_v3 false))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= var_v3 true) (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (not (or (> s |0|) (= s |0|))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term _lbv6
 
 Type of the Scalar Term {v:Ty_int | (v) ==((root) -- (1))}                                                                                                                                                               
# of Final Z3 expressions 33
 Final solver 
 (declare-sort T490)
(declare-fun tlen (T490) Int)
(declare-fun leaf () T490)
(declare-fun |0| () Int)
(declare-fun _lbv0 () Int)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv2 () Int)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv5 () Bool)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun _lbv7 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun root () Int)
(declare-fun _lbv6 () Int)
(assert (= (tlen leaf) 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (or (> _lbv0 |0|) (= _lbv0 |0|)))
(assert (= _lbv1 (- s0 1)))
(assert (= _lbv2 (- _lbv0 1)))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv4 true) (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv5 true) (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= var_v3 true) (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|)))))
(assert (= _lbv7 (- s01 1)))
(assert (= _lbv8 (- s 1)))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (or (> root |0|) (= root |0|)))
(assert (> s0 s01))
(assert (= _lbv6 (- root 1)))
(assert (= var_v3 false))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= var_v3 true) (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|)))))
(assert (= _lbv6 (- root 1)))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (not (or (> _lbv6 |0|) (= _lbv6 |0|))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term _lbv7
 
 Type of the Scalar Term {v:Ty_int | (v) ==((s01) -- (1))}                                                                                                                                                               
# of Final Z3 expressions 33
 Final solver 
 (declare-sort T496)
(declare-fun tlen (T496) Int)
(declare-fun leaf () T496)
(declare-fun |0| () Int)
(declare-fun _lbv0 () Int)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv2 () Int)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv5 () Bool)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun _lbv6 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun s01 () Int)
(declare-fun _lbv7 () Int)
(assert (= (tlen leaf) 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (or (> _lbv0 |0|) (= _lbv0 |0|)))
(assert (= _lbv1 (- s0 1)))
(assert (= _lbv2 (- _lbv0 1)))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv4 true) (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv5 true) (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= var_v3 true) (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|)))))
(assert (= _lbv6 (- root 1)))
(assert (= _lbv8 (- s 1)))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (or (> root |0|) (= root |0|)))
(assert (> s0 s01))
(assert (= _lbv7 (- s01 1)))
(assert (= var_v3 false))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= var_v3 true) (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|)))))
(assert (= _lbv7 (- s01 1)))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (not (or (> _lbv7 |0|) (= _lbv7 |0|))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term _lbv8
 
 Type of the Scalar Term {v:Ty_int | (v) ==((s) -- (1))}                                                                                                                                                               
# of Final Z3 expressions 33
 Final solver 
 (declare-sort T502)
(declare-fun tlen (T502) Int)
(declare-fun leaf () T502)
(declare-fun |0| () Int)
(declare-fun _lbv0 () Int)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv2 () Int)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv5 () Bool)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun _lbv6 () Int)
(declare-fun s01 () Int)
(declare-fun _lbv7 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(assert (= (tlen leaf) 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (or (> _lbv0 |0|) (= _lbv0 |0|)))
(assert (= _lbv1 (- s0 1)))
(assert (= _lbv2 (- _lbv0 1)))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv4 true) (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv5 true) (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= var_v3 true) (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|)))))
(assert (= _lbv6 (- root 1)))
(assert (= _lbv7 (- s01 1)))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (or (> root |0|) (= root |0|)))
(assert (> s0 s01))
(assert (= _lbv8 (- s 1)))
(assert (= var_v3 false))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= var_v3 true) (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|)))))
(assert (= _lbv8 (- s 1)))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (not (or (> _lbv8 |0|) (= _lbv8 |0|))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {v:Ty_int | true}                                                                                                                                                               
# of Final Z3 expressions 32
 Final solver 
 (declare-sort T508)
(declare-fun tlen (T508) Int)
(declare-fun leaf () T508)
(declare-fun |0| () Int)
(declare-fun _lbv0 () Int)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv2 () Int)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv5 () Bool)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun _lbv6 () Int)
(declare-fun s01 () Int)
(declare-fun _lbv7 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun n () Int)
(assert (= (tlen leaf) 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (or (> _lbv0 |0|) (= _lbv0 |0|)))
(assert (= _lbv1 (- s0 1)))
(assert (= _lbv2 (- _lbv0 1)))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv4 true) (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv5 true) (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= var_v3 true) (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|)))))
(assert (= _lbv6 (- root 1)))
(assert (= _lbv7 (- s01 1)))
(assert (= _lbv8 (- s 1)))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (or (> root |0|) (= root |0|)))
(assert (> s0 s01))
(assert (= var_v3 false))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= var_v3 true) (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (not (or (> n |0|) (= n |0|))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term root
 
 Type of the Scalar Term {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }
 ################################################
 Skipping Variable root As this a  Formal Parameter to the current function Call
 ################################################
 
 Enumerating a Scalar Term sizel
 
 Type of the Scalar Term {v:Ty_int | true}
 ################################################
 Skipping Variable sizel As this a  Formal Parameter to the current function Call
 ################################################
 
 Enumerating a Scalar Term s01
 
 Type of the Scalar Term {v:Ty_int | 
 	 Conj <c true
 	 , s0 > v >c }                                                                                                                                                                    
# of Final Z3 expressions 33
 Final solver 
 (declare-sort T514)
(declare-fun tlen (T514) Int)
(declare-fun leaf () T514)
(declare-fun |0| () Int)
(declare-fun _lbv0 () Int)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv2 () Int)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv5 () Bool)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun _lbv6 () Int)
(declare-fun s01 () Int)
(declare-fun _lbv7 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(assert (= (tlen leaf) 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (or (> _lbv0 |0|) (= _lbv0 |0|)))
(assert (= _lbv1 (- s0 1)))
(assert (= _lbv2 (- _lbv0 1)))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv4 true) (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv5 true) (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= var_v3 true) (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|)))))
(assert (= _lbv6 (- root 1)))
(assert (= _lbv7 (- s01 1)))
(assert (= _lbv8 (- s 1)))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (or (> root |0|) (= root |0|)))
(assert (> s0 s01))
(assert (= var_v3 false))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= var_v3 true) (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|)))))
(assert (> s0 s01))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (not (or (> s01 |0|) (= s01 |0|))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 
 FaileD the subtype check T_vi <: T_goal
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>> 1th Args option for node : apply int_gen  (, dummy )
 TEST Overall List : List of Args for node
 EI apply int_gen  (, dummy )
 ##################################################################################
  Synthesizing the 2th argument for Function node
  Trying Arguments in Scalars 
 esynthesizeScalar for {v:Ty_int | true}
 
 Enumerating a Scalar Term s0
 
 Type of the Scalar Term {v:Ty_int | true}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term _lbv0
 
 Type of the Scalar Term {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 Enumerating a Scalar Term _lbv1
 
 Type of the Scalar Term {v:Ty_int | (v) ==((s0) -- (1))}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 Enumerating a Scalar Term _lbv2
 
 Type of the Scalar Term {v:Ty_int | (v) ==((_lbv0) -- (1))}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 Enumerating a Scalar Term s
 
 Type of the Scalar Term {var_v0:Ty_int | true}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term _lbv6
 
 Type of the Scalar Term {v:Ty_int | (v) ==((root) -- (1))}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 Enumerating a Scalar Term _lbv7
 
 Type of the Scalar Term {v:Ty_int | (v) ==((s01) -- (1))}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 Enumerating a Scalar Term _lbv8
 
 Type of the Scalar Term {v:Ty_int | (v) ==((s) -- (1))}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {v:Ty_int | true}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term sizel
 
 Type of the Scalar Term {v:Ty_int | true}
 ################################################
 Skipping Variable sizel As this a  Formal Parameter to the current function Call
 ################################################
 
 Enumerating a Scalar Term s01
 
 Type of the Scalar Term {v:Ty_int | 
 	 Conj <c true
 	 , s0 > v >c }
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term root
 
 Type of the Scalar Term {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }
 ################################################
 Skipping Variable root As this a  Formal Parameter to the current function Call
 ################################################
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>> 2th Args option for node : s01
 >>>>>>>>>>>>>>>>>>> 2th Args option for node : n
 >>>>>>>>>>>>>>>>>>> 2th Args option for node : apply subs  (, s )
 >>>>>>>>>>>>>>>>>>> 2th Args option for node : apply subs  (, s01 )
 >>>>>>>>>>>>>>>>>>> 2th Args option for node : apply subs  (, root )
 >>>>>>>>>>>>>>>>>>> 2th Args option for node : s
 >>>>>>>>>>>>>>>>>>> 2th Args option for node : apply subs  (, apply int_gen  (, dummy ) )
 >>>>>>>>>>>>>>>>>>> 2th Args option for node : apply subs  (, s0 )
 >>>>>>>>>>>>>>>>>>> 2th Args option for node : apply int_gen  (, dummy )
 >>>>>>>>>>>>>>>>>>> 2th Args option for node : s0
 TEST Overall List : List of Args for node
 EI s01
 EI n
 EI apply subs  (, s )
 EI apply subs  (, s01 )
 EI apply subs  (, root )
 EI s
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI apply subs  (, s0 )
 EI apply int_gen  (, dummy )
 EI s0
 TEST Overall List : List of Args for node
 EI apply int_gen  (, dummy )
 ##################################################################################
  Synthesizing the 3th argument for Function node
  Trying Arguments in Scalars 
 esynthesizeScalar for {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 
 Enumerating a Scalar Term leaf
 
 Type of the Scalar Term {v:Ty_alphatree | (tlen)(v) ==(0)}                                                                                                                                                    
# of Final Z3 expressions 31
 Final solver 
 (declare-sort T531)
(declare-fun |0| () Int)
(declare-fun _lbv0 () Int)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv2 () Int)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv5 () Bool)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun _lbv6 () Int)
(declare-fun s01 () Int)
(declare-fun _lbv7 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun tlen (T531) Int)
(declare-fun leaf () T531)
(declare-fun sizel () Int)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (or (> _lbv0 |0|) (= _lbv0 |0|)))
(assert (= _lbv1 (- s0 1)))
(assert (= _lbv2 (- _lbv0 1)))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv4 true) (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= _lbv5 true) (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= var_v3 true) (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|)))))
(assert (= _lbv6 (- root 1)))
(assert (= _lbv7 (- s01 1)))
(assert (= _lbv8 (- s 1)))
(assert (> s0 s01))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (or (> root |0|) (= root |0|)))
(assert (= (tlen leaf) 0))
(assert (= var_v3 false))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= (= var_v3 true) (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|)))))
(assert (= (tlen leaf) 0))
(assert (not (forall ((var_u47 Int)) (= (tlen leaf) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 
 FaileD the subtype check T_vi <: T_goal
 >>>>>>>>>>>>>>>>>> No Scalar found in Environment, Trying esynthesizePureApp <<<<<<<<<<<<<<<<<< 
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 TEST Overall List : List of Args for node
 TEST Overall List : List of Args for node
 EI s01
 EI n
 EI apply subs  (, s )
 EI apply subs  (, s01 )
 EI apply subs  (, root )
 EI s
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI apply subs  (, s0 )
 EI apply int_gen  (, dummy )
 EI s0
 TEST Overall List : List of Args for node
 EI apply int_gen  (, dummy )
 ##################################################################################
  Synthesizing the 4th argument for Function node
  Trying Arguments in Scalars 
 esynthesizeScalar for {v:Ty_int | true}
 
 Enumerating a Scalar Term s0
 
 Type of the Scalar Term {v:Ty_int | true}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term _lbv0
 
 Type of the Scalar Term {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 Enumerating a Scalar Term _lbv1
 
 Type of the Scalar Term {v:Ty_int | (v) ==((s0) -- (1))}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 Enumerating a Scalar Term _lbv2
 
 Type of the Scalar Term {v:Ty_int | (v) ==((_lbv0) -- (1))}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 Enumerating a Scalar Term s
 
 Type of the Scalar Term {var_v0:Ty_int | true}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term _lbv6
 
 Type of the Scalar Term {v:Ty_int | (v) ==((root) -- (1))}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 Enumerating a Scalar Term _lbv7
 
 Type of the Scalar Term {v:Ty_int | (v) ==((s01) -- (1))}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 Enumerating a Scalar Term _lbv8
 
 Type of the Scalar Term {v:Ty_int | (v) ==((s) -- (1))}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {v:Ty_int | true}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term s01
 
 Type of the Scalar Term {v:Ty_int | 
 	 Conj <c true
 	 , s0 > v >c }
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term root
 
 Type of the Scalar Term {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }
 ################################################
 Skipping Variable root As this a  Formal Parameter to the current function Call
 ################################################
 
 Enumerating a Scalar Term sizel
 
 Type of the Scalar Term {v:Ty_int | true}
 ################################################
 Skipping Variable sizel As this a  Formal Parameter to the current function Call
 ################################################
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>> 4th Args option for node : s01
 >>>>>>>>>>>>>>>>>>> 4th Args option for node : n
 >>>>>>>>>>>>>>>>>>> 4th Args option for node : apply subs  (, s )
 >>>>>>>>>>>>>>>>>>> 4th Args option for node : apply subs  (, s01 )
 >>>>>>>>>>>>>>>>>>> 4th Args option for node : apply subs  (, root )
 >>>>>>>>>>>>>>>>>>> 4th Args option for node : s
 >>>>>>>>>>>>>>>>>>> 4th Args option for node : apply subs  (, apply int_gen  (, dummy ) )
 >>>>>>>>>>>>>>>>>>> 4th Args option for node : apply subs  (, s0 )
 >>>>>>>>>>>>>>>>>>> 4th Args option for node : apply int_gen  (, dummy )
 >>>>>>>>>>>>>>>>>>> 4th Args option for node : s0
 TEST Overall List : List of Args for node
 EI s01
 EI n
 EI apply subs  (, s )
 EI apply subs  (, s01 )
 EI apply subs  (, root )
 EI s
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI apply subs  (, s0 )
 EI apply int_gen  (, dummy )
 EI s0
 TEST Overall List : List of Args for node
 TEST Overall List : List of Args for node
 EI s01
 EI n
 EI apply subs  (, s )
 EI apply subs  (, s01 )
 EI apply subs  (, root )
 EI s
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI apply subs  (, s0 )
 EI apply int_gen  (, dummy )
 EI s0
 TEST Overall List : List of Args for node
 EI apply int_gen  (, dummy )
 ##################################################################################
  Synthesizing the 5th argument for Function node
  Trying Arguments in Scalars 
 esynthesizeScalar for {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }}
 
 Enumerating a Scalar Term leaf
 
 Type of the Scalar Term {v:Ty_alphatree | (tlen)(v) ==(0)}                                                                                                                                                    
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T547)
(declare-fun |0| () Int)
(declare-fun tlen (T547) Int)
(declare-fun leaf () T547)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun sizel () Int)
(declare-fun ltree () T547)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun sizer () Int)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u48 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen leaf) 0)
         (= var_v3 false)
         a!4
         (= (tlen leaf) 0)))))
(assert (not (forall ((var_u49 Int)) (= (tlen leaf) sizer))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term ltree
 
 Type of the Scalar Term {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 ################################################
 Skipping Variable ltree As this a  Formal Parameter to the current function Call
 ################################################
 >>>>>>>>>>>>>>>>>> No Scalar found in Environment, Trying esynthesizePureApp <<<<<<<<<<<<<<<<<< 
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 TEST Overall List : List of Args for node
 TEST Overall List : List of Args for node
 EI s01
 EI n
 EI apply subs  (, s )
 EI apply subs  (, s01 )
 EI apply subs  (, root )
 EI s
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI apply subs  (, s0 )
 EI apply int_gen  (, dummy )
 EI s0
 TEST Overall List : List of Args for node
 TEST Overall List : List of Args for node
 EI s01
 EI n
 EI apply subs  (, s )
 EI apply subs  (, s01 )
 EI apply subs  (, root )
 EI s
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI apply subs  (, s0 )
 EI apply int_gen  (, dummy )
 EI s0
 TEST Overall List : List of Args for node
 EI apply int_gen  (, dummy )
 ##################################################################################
  *************** Synthesizing Args ei : Failed for some  arg
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 Found Constructors with required return type
  
 ********************** HERE BEFORE 
 Show No more choices for ConsApp
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  , 
 goal, 
 node
 ############################################################
  Synthesizing the Function application Pure Component goal
 ############################################################
  *************** Trying Arrow Component ************goal :  Arrow ( ( s01 : {v:Ty_int | 
 	 Conj <c true
 	 , s0 > v >c } ) -> {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (tlen)(v) ==(u)
 	 u = s01 > }}
  *************** Synthesizing Args ei : ti for ************goal
 ##################################################################################
  Synthesizing the 1th argument for Function goal
  Trying Arguments in Scalars 
 esynthesizeScalar for {v:Ty_int | 
 	 Conj <c true
 	 , s0 > v >c }
 
 Enumerating a Scalar Term s0
 
 Type of the Scalar Term {v:Ty_int | true}                                                                                                                                                         
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T552)
(declare-fun |0| () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun sizer () Int)
(declare-fun tlen (T552) Int)
(declare-fun rtree () T552)
(declare-fun sizel () Int)
(declare-fun ltree () T552)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T552)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u51 Int) (var_u50 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (= var_v3 false)
         a!4))))
(assert (not (> s0 s0)))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term _lbv0
 
 Type of the Scalar Term {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }                                                                                                                                                                    
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T558)
(declare-fun |0| () Int)
(declare-fun _lbv0 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun sizer () Int)
(declare-fun tlen (T558) Int)
(declare-fun rtree () T558)
(declare-fun sizel () Int)
(declare-fun ltree () T558)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T558)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u53 Int) (var_u52 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))))))
(assert (not (> s0 _lbv0)))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term _lbv1
 
 Type of the Scalar Term {v:Ty_int | (v) ==((s0) -- (1))}                                                                                                                                                         
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T564)
(declare-fun |0| () Int)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun sizer () Int)
(declare-fun tlen (T564) Int)
(declare-fun rtree () T564)
(declare-fun sizel () Int)
(declare-fun ltree () T564)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T564)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u55 Int) (var_u54 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (= _lbv1 (- s0 1))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))))))
(assert (not (> s0 _lbv1)))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 Enumerating a Scalar Term _lbv2
 
 Type of the Scalar Term {v:Ty_int | (v) ==((_lbv0) -- (1))}                                                                                                                                                         
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T570)
(declare-fun |0| () Int)
(declare-fun _lbv0 () Int)
(declare-fun _lbv2 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun sizer () Int)
(declare-fun tlen (T570) Int)
(declare-fun rtree () T570)
(declare-fun sizel () Int)
(declare-fun ltree () T570)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T570)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u57 Int) (var_u56 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (= _lbv2 (- _lbv0 1))
         (= var_v3 false)
         a!4
         (= _lbv2 (- _lbv0 1))))))
(assert (not (> s0 _lbv2)))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term s
 
 Type of the Scalar Term {var_v0:Ty_int | true}                                                                                                                                                         
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T576)
(declare-fun |0| () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun sizer () Int)
(declare-fun tlen (T576) Int)
(declare-fun rtree () T576)
(declare-fun sizel () Int)
(declare-fun ltree () T576)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T576)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u59 Int) (var_u58 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (= var_v3 false)
         a!4))))
(assert (not (> s0 s)))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term _lbv6
 
 Type of the Scalar Term {v:Ty_int | (v) ==((root) -- (1))}                                                                                                                                                         
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T582)
(declare-fun |0| () Int)
(declare-fun root () Int)
(declare-fun _lbv6 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun sizer () Int)
(declare-fun tlen (T582) Int)
(declare-fun rtree () T582)
(declare-fun sizel () Int)
(declare-fun ltree () T582)
(declare-fun s01 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T582)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u61 Int) (var_u60 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (= _lbv6 (- root 1))
         (= var_v3 false)
         a!4
         (= _lbv6 (- root 1))))))
(assert (not (> s0 _lbv6)))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term _lbv7
 
 Type of the Scalar Term {v:Ty_int | (v) ==((s01) -- (1))}                                                                                                                                                         
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T588)
(declare-fun |0| () Int)
(declare-fun s01 () Int)
(declare-fun _lbv7 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun sizer () Int)
(declare-fun tlen (T588) Int)
(declare-fun rtree () T588)
(declare-fun sizel () Int)
(declare-fun ltree () T588)
(declare-fun root () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T588)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u63 Int) (var_u62 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv8 (- s 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (= _lbv7 (- s01 1))
         (= var_v3 false)
         a!4
         (= _lbv7 (- s01 1))))))
(assert (not (> s0 _lbv7)))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 Enumerating a Scalar Term _lbv8
 
 Type of the Scalar Term {v:Ty_int | (v) ==((s) -- (1))}                                                                                                                                                         
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T594)
(declare-fun |0| () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun sizer () Int)
(declare-fun tlen (T594) Int)
(declare-fun rtree () T594)
(declare-fun sizel () Int)
(declare-fun ltree () T594)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T594)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u65 Int) (var_u64 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (= _lbv8 (- s 1))
         (= var_v3 false)
         a!4
         (= _lbv8 (- s 1))))))
(assert (not (> s0 _lbv8)))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {v:Ty_int | true}                                                                                                                                                         
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T600)
(declare-fun |0| () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun sizer () Int)
(declare-fun tlen (T600) Int)
(declare-fun rtree () T600)
(declare-fun sizel () Int)
(declare-fun ltree () T600)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T600)
(declare-fun n () Int)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u67 Int) (var_u66 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (= var_v3 false)
         a!4))))
(assert (not (> s0 n)))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term s01
 
 Type of the Scalar Term {v:Ty_int | 
 	 Conj <c true
 	 , s0 > v >c }
 ################################################
 Skipping Variable s01 As this a  Formal Parameter to the current function Call
 ################################################
 
 Enumerating a Scalar Term root
 
 Type of the Scalar Term {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }                                                                                                                                                                    
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T606)
(declare-fun |0| () Int)
(declare-fun root () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun sizer () Int)
(declare-fun tlen (T606) Int)
(declare-fun rtree () T606)
(declare-fun sizel () Int)
(declare-fun ltree () T606)
(declare-fun s01 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T606)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u69 Int) (var_u68 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (> s0 s01)
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (or (> root |0|) (= root |0|))
         (= var_v3 false)
         a!4
         (or (> root |0|) (= root |0|))))))
(assert (not (> s0 root)))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term sizel
 
 Type of the Scalar Term {v:Ty_int | true}                                                                                                                                                         
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T612)
(declare-fun |0| () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun sizer () Int)
(declare-fun tlen (T612) Int)
(declare-fun rtree () T612)
(declare-fun sizel () Int)
(declare-fun ltree () T612)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T612)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u71 Int) (var_u70 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (= var_v3 false)
         a!4))))
(assert (not (> s0 sizel)))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term sizer
 
 Type of the Scalar Term {v:Ty_int | true}                                                                                                                                                         
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T618)
(declare-fun |0| () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun sizer () Int)
(declare-fun tlen (T618) Int)
(declare-fun rtree () T618)
(declare-fun sizel () Int)
(declare-fun ltree () T618)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T618)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u73 Int) (var_u72 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (= var_v3 false)
         a!4))))
(assert (not (> s0 sizer)))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 
 FaileD the subtype check T_vi <: T_goal
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>> 1th Args option for goal : apply subs  (, s01 )
 >>>>>>>>>>>>>>>>>>> 1th Args option for goal : apply subs  (, s0 )
 TEST Overall List : List of Args for goal
 EI apply subs  (, s01 )
 EI apply subs  (, s0 )
 ##################################################################################
  *************** Successfully Synthesized Args ei Forall i 
 Ith Argument Options for goal
 EI apply subs  (, s01 )
 EI apply subs  (, s0 )
 # of Possible Argument Options for goal 2
 Possible Arg Options 
 EI apply subs  (, s01 )
 Possible Arg Options 
 EI apply subs  (, s0 )
 Apply Single Argument Case : f (ei) Case goal
  Case : f (ei) Case goal _lbv7
 Finding Already seen tree for apply goal  (, _lbv7 )
 Typechecking the Term apply goal  (, _lbv7 )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv7 :: {v:Ty_int | (v) ==((s01) -- (1))} | (_lbv7) ==((s01) -- (1))
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (tlen)(v) ==(u)
 	 u = _lbv7 > }}                                                                                                                                                                
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T624)
(declare-fun |0| () Int)
(declare-fun _lbv7 () Int)
(declare-fun tlen (T624) Int)
(declare-fun v () T624)
(declare-fun s01 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun sizer () Int)
(declare-fun rtree () T624)
(declare-fun sizel () Int)
(declare-fun ltree () T624)
(declare-fun root () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T624)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u77 Int) (var_u76 Int) (var_u75 Int) (var_u74 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (> s0 s01)
         (=> (= (tlen v) var_u76) (= var_u76 _lbv7))
         (= var_v3 false)
         a!4
         (= _lbv7 (- s01 1))
         (=> (= (tlen v) var_u77) (= var_u77 _lbv7))))))
(assert (not (forall ((var_u78 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply goal  (, _lbv7 )
  Case : f (ei) Case goal _lbv1
 Finding Already seen tree for apply goal  (, _lbv1 )
 Typechecking the Term apply goal  (, _lbv1 )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (tlen)(v) ==(u)
 	 u = _lbv1 > }}                                                                                                                                                                
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T630)
(declare-fun |0| () Int)
(declare-fun _lbv1 () Int)
(declare-fun tlen (T630) Int)
(declare-fun v () T630)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T630)
(declare-fun sizel () Int)
(declare-fun ltree () T630)
(declare-fun root () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T630)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u82 Int) (var_u81 Int) (var_u80 Int) (var_u79 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (> s0 s01)
         (=> (= (tlen v) var_u81) (= var_u81 _lbv1))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (=> (= (tlen v) var_u82) (= var_u82 _lbv1))))))
(assert (not (forall ((var_u83 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply goal  (, _lbv1 )
  ###################################################
  The Choice of Function goal Was Ill Fated Try Next Choice of function
 ############################################################
  Synthesizing the Function application Pure Component node
 ############################################################
  *************** Trying Arrow Component ************node :  Arrow ( ( root : {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } ) ->  Arrow ( ( sizel : {v:Ty_int | true} ) ->  Arrow ( ( ltree : {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} ) ->  Arrow ( ( sizer : {v:Ty_int | true} ) ->  Arrow ( ( rtree : {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} ) -> {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((sizel) + (1))
 	 (tlen)(v) ==(u) > }}
  *************** Synthesizing Args ei : ti for ************node
 ##################################################################################
  Synthesizing the 1th argument for Function node
  Trying Arguments in Scalars 
 esynthesizeScalar for {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }
 
 Enumerating a Scalar Term s0
 
 Type of the Scalar Term {v:Ty_int | true}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T636)
(declare-fun |0| () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun sizer () Int)
(declare-fun tlen (T636) Int)
(declare-fun rtree () T636)
(declare-fun sizel () Int)
(declare-fun ltree () T636)
(declare-fun root () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T636)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u85 Int) (var_u84 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (> s0 s01)
         (= var_v3 false)
         a!4))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (not (or (> s0 |0|) (= s0 |0|))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term _lbv0
 
 Type of the Scalar Term {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }                                                                                                                                                                          
# of Final Z3 expressions 20
 Final solver 
 (declare-sort T642)
(declare-fun |0| () Int)
(declare-fun _lbv0 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun sizer () Int)
(declare-fun tlen (T642) Int)
(declare-fun rtree () T642)
(declare-fun sizel () Int)
(declare-fun ltree () T642)
(declare-fun root () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T642)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u87 Int) (var_u86 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (> s0 s01)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (not (or (> _lbv0 |0|) (= _lbv0 |0|))))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 Enumerating a Scalar Term _lbv1
 
 Type of the Scalar Term {v:Ty_int | (v) ==((s0) -- (1))}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T648)
(declare-fun |0| () Int)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun sizer () Int)
(declare-fun tlen (T648) Int)
(declare-fun rtree () T648)
(declare-fun sizel () Int)
(declare-fun ltree () T648)
(declare-fun root () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T648)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u89 Int) (var_u88 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (> s0 s01)
         (= _lbv1 (- s0 1))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (not (or (> _lbv1 |0|) (= _lbv1 |0|))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term _lbv2
 
 Type of the Scalar Term {v:Ty_int | (v) ==((_lbv0) -- (1))}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T654)
(declare-fun |0| () Int)
(declare-fun _lbv0 () Int)
(declare-fun _lbv2 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun sizer () Int)
(declare-fun tlen (T654) Int)
(declare-fun rtree () T654)
(declare-fun sizel () Int)
(declare-fun ltree () T654)
(declare-fun root () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T654)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u91 Int) (var_u90 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (> s0 s01)
         (= _lbv2 (- _lbv0 1))
         (= var_v3 false)
         a!4
         (= _lbv2 (- _lbv0 1))))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (not (or (> _lbv2 |0|) (= _lbv2 |0|))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term s
 
 Type of the Scalar Term {var_v0:Ty_int | true}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T660)
(declare-fun |0| () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun sizer () Int)
(declare-fun tlen (T660) Int)
(declare-fun rtree () T660)
(declare-fun sizel () Int)
(declare-fun ltree () T660)
(declare-fun root () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T660)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u93 Int) (var_u92 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (> s0 s01)
         (= var_v3 false)
         a!4))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (not (or (> s |0|) (= s |0|))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term _lbv6
 
 Type of the Scalar Term {v:Ty_int | (v) ==((root) -- (1))}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T666)
(declare-fun |0| () Int)
(declare-fun root () Int)
(declare-fun _lbv6 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun sizer () Int)
(declare-fun tlen (T666) Int)
(declare-fun rtree () T666)
(declare-fun sizel () Int)
(declare-fun ltree () T666)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T666)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u95 Int) (var_u94 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (> s0 s01)
         (= _lbv6 (- root 1))
         (= var_v3 false)
         a!4
         (= _lbv6 (- root 1))))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (not (or (> _lbv6 |0|) (= _lbv6 |0|))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term _lbv7
 
 Type of the Scalar Term {v:Ty_int | (v) ==((s01) -- (1))}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T672)
(declare-fun |0| () Int)
(declare-fun s01 () Int)
(declare-fun _lbv7 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun sizer () Int)
(declare-fun tlen (T672) Int)
(declare-fun rtree () T672)
(declare-fun sizel () Int)
(declare-fun ltree () T672)
(declare-fun root () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T672)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u97 Int) (var_u96 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv8 (- s 1))
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (> s0 s01)
         (= _lbv7 (- s01 1))
         (= var_v3 false)
         a!4
         (= _lbv7 (- s01 1))))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (not (or (> _lbv7 |0|) (= _lbv7 |0|))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term _lbv8
 
 Type of the Scalar Term {v:Ty_int | (v) ==((s) -- (1))}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T678)
(declare-fun |0| () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun sizer () Int)
(declare-fun tlen (T678) Int)
(declare-fun rtree () T678)
(declare-fun sizel () Int)
(declare-fun ltree () T678)
(declare-fun root () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T678)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u99 Int) (var_u98 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (> s0 s01)
         (= _lbv8 (- s 1))
         (= var_v3 false)
         a!4
         (= _lbv8 (- s 1))))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (not (or (> _lbv8 |0|) (= _lbv8 |0|))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {v:Ty_int | true}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T684)
(declare-fun |0| () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun sizer () Int)
(declare-fun tlen (T684) Int)
(declare-fun rtree () T684)
(declare-fun sizel () Int)
(declare-fun ltree () T684)
(declare-fun root () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T684)
(declare-fun n () Int)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u101 Int) (var_u100 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (> s0 s01)
         (= var_v3 false)
         a!4))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (not (or (> n |0|) (= n |0|))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term root
 
 Type of the Scalar Term {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }
 ################################################
 Skipping Variable root As this a  Formal Parameter to the current function Call
 ################################################
 
 Enumerating a Scalar Term sizel
 
 Type of the Scalar Term {v:Ty_int | true}
 ################################################
 Skipping Variable sizel As this a  Formal Parameter to the current function Call
 ################################################
 
 Enumerating a Scalar Term sizer
 
 Type of the Scalar Term {v:Ty_int | true}
 ################################################
 Skipping Variable sizer As this a  Formal Parameter to the current function Call
 ################################################
 
 Enumerating a Scalar Term s01
 
 Type of the Scalar Term {v:Ty_int | 
 	 Conj <c true
 	 , s0 > v >c }                                                                                                                                                                    
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T690)
(declare-fun |0| () Int)
(declare-fun s01 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun sizer () Int)
(declare-fun tlen (T690) Int)
(declare-fun rtree () T690)
(declare-fun sizel () Int)
(declare-fun ltree () T690)
(declare-fun root () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T690)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u103 Int) (var_u102 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (> s0 s01)
         (= var_v3 false)
         a!4
         (> s0 s01)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (not (or (> s01 |0|) (= s01 |0|))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 
 FaileD the subtype check T_vi <: T_goal
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>> 1th Args option for node : apply int_gen  (, dummy )
 TEST Overall List : List of Args for node
 EI apply int_gen  (, dummy )
 ##################################################################################
  Synthesizing the 2th argument for Function node
  Trying Arguments in Scalars 
 esynthesizeScalar for {v:Ty_int | true}
 
 Enumerating a Scalar Term s0
 
 Type of the Scalar Term {v:Ty_int | true}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term _lbv0
 
 Type of the Scalar Term {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 Enumerating a Scalar Term _lbv1
 
 Type of the Scalar Term {v:Ty_int | (v) ==((s0) -- (1))}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 Enumerating a Scalar Term _lbv2
 
 Type of the Scalar Term {v:Ty_int | (v) ==((_lbv0) -- (1))}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 Enumerating a Scalar Term s
 
 Type of the Scalar Term {var_v0:Ty_int | true}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term _lbv6
 
 Type of the Scalar Term {v:Ty_int | (v) ==((root) -- (1))}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 Enumerating a Scalar Term _lbv7
 
 Type of the Scalar Term {v:Ty_int | (v) ==((s01) -- (1))}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 Enumerating a Scalar Term _lbv8
 
 Type of the Scalar Term {v:Ty_int | (v) ==((s) -- (1))}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {v:Ty_int | true}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term sizel
 
 Type of the Scalar Term {v:Ty_int | true}
 ################################################
 Skipping Variable sizel As this a  Formal Parameter to the current function Call
 ################################################
 
 Enumerating a Scalar Term sizer
 
 Type of the Scalar Term {v:Ty_int | true}
 ################################################
 Skipping Variable sizer As this a  Formal Parameter to the current function Call
 ################################################
 
 Enumerating a Scalar Term s01
 
 Type of the Scalar Term {v:Ty_int | 
 	 Conj <c true
 	 , s0 > v >c }
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term root
 
 Type of the Scalar Term {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }
 ################################################
 Skipping Variable root As this a  Formal Parameter to the current function Call
 ################################################
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>> 2th Args option for node : s01
 >>>>>>>>>>>>>>>>>>> 2th Args option for node : n
 >>>>>>>>>>>>>>>>>>> 2th Args option for node : apply subs  (, s )
 >>>>>>>>>>>>>>>>>>> 2th Args option for node : apply subs  (, s01 )
 >>>>>>>>>>>>>>>>>>> 2th Args option for node : apply subs  (, root )
 >>>>>>>>>>>>>>>>>>> 2th Args option for node : s
 >>>>>>>>>>>>>>>>>>> 2th Args option for node : apply subs  (, apply int_gen  (, dummy ) )
 >>>>>>>>>>>>>>>>>>> 2th Args option for node : apply subs  (, s0 )
 >>>>>>>>>>>>>>>>>>> 2th Args option for node : apply int_gen  (, dummy )
 >>>>>>>>>>>>>>>>>>> 2th Args option for node : s0
 TEST Overall List : List of Args for node
 EI s01
 EI n
 EI apply subs  (, s )
 EI apply subs  (, s01 )
 EI apply subs  (, root )
 EI s
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI apply subs  (, s0 )
 EI apply int_gen  (, dummy )
 EI s0
 TEST Overall List : List of Args for node
 EI apply int_gen  (, dummy )
 ##################################################################################
  Synthesizing the 3th argument for Function node
  Trying Arguments in Scalars 
 esynthesizeScalar for {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 
 Enumerating a Scalar Term leaf
 
 Type of the Scalar Term {v:Ty_alphatree | (tlen)(v) ==(0)}                                                                                                                                                    
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T707)
(declare-fun |0| () Int)
(declare-fun tlen (T707) Int)
(declare-fun leaf () T707)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T707)
(declare-fun sizel () Int)
(declare-fun ltree () T707)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u105 Int) (var_u104 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen leaf) 0)
         (= var_v3 false)
         a!4
         (= (tlen leaf) 0)))))
(assert (not (forall ((var_u106 Int)) (= (tlen leaf) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term ltree
 
 Type of the Scalar Term {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 ################################################
 Skipping Variable ltree As this a  Formal Parameter to the current function Call
 ################################################
 
 Enumerating a Scalar Term rtree
 
 Type of the Scalar Term {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }}
 ################################################
 Skipping Variable rtree As this a  Formal Parameter to the current function Call
 ################################################
 >>>>>>>>>>>>>>>>>> No Scalar found in Environment, Trying esynthesizePureApp <<<<<<<<<<<<<<<<<< 
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 TEST Overall List : List of Args for node
 TEST Overall List : List of Args for node
 EI s01
 EI n
 EI apply subs  (, s )
 EI apply subs  (, s01 )
 EI apply subs  (, root )
 EI s
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI apply subs  (, s0 )
 EI apply int_gen  (, dummy )
 EI s0
 TEST Overall List : List of Args for node
 EI apply int_gen  (, dummy )
 ##################################################################################
  Synthesizing the 4th argument for Function node
  Trying Arguments in Scalars 
 esynthesizeScalar for {v:Ty_int | true}
 
 Enumerating a Scalar Term s0
 
 Type of the Scalar Term {v:Ty_int | true}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term _lbv0
 
 Type of the Scalar Term {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 Enumerating a Scalar Term _lbv1
 
 Type of the Scalar Term {v:Ty_int | (v) ==((s0) -- (1))}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 Enumerating a Scalar Term _lbv2
 
 Type of the Scalar Term {v:Ty_int | (v) ==((_lbv0) -- (1))}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 Enumerating a Scalar Term s
 
 Type of the Scalar Term {var_v0:Ty_int | true}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term _lbv6
 
 Type of the Scalar Term {v:Ty_int | (v) ==((root) -- (1))}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 Enumerating a Scalar Term _lbv7
 
 Type of the Scalar Term {v:Ty_int | (v) ==((s01) -- (1))}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 Enumerating a Scalar Term _lbv8
 
 Type of the Scalar Term {v:Ty_int | (v) ==((s) -- (1))}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {v:Ty_int | true}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term sizer
 
 Type of the Scalar Term {v:Ty_int | true}
 ################################################
 Skipping Variable sizer As this a  Formal Parameter to the current function Call
 ################################################
 
 Enumerating a Scalar Term s01
 
 Type of the Scalar Term {v:Ty_int | 
 	 Conj <c true
 	 , s0 > v >c }
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term root
 
 Type of the Scalar Term {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }
 ################################################
 Skipping Variable root As this a  Formal Parameter to the current function Call
 ################################################
 
 Enumerating a Scalar Term sizel
 
 Type of the Scalar Term {v:Ty_int | true}
 ################################################
 Skipping Variable sizel As this a  Formal Parameter to the current function Call
 ################################################
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>> 4th Args option for node : s01
 >>>>>>>>>>>>>>>>>>> 4th Args option for node : n
 >>>>>>>>>>>>>>>>>>> 4th Args option for node : apply subs  (, s )
 >>>>>>>>>>>>>>>>>>> 4th Args option for node : apply subs  (, s01 )
 >>>>>>>>>>>>>>>>>>> 4th Args option for node : apply subs  (, root )
 >>>>>>>>>>>>>>>>>>> 4th Args option for node : s
 >>>>>>>>>>>>>>>>>>> 4th Args option for node : apply subs  (, apply int_gen  (, dummy ) )
 >>>>>>>>>>>>>>>>>>> 4th Args option for node : apply subs  (, s0 )
 >>>>>>>>>>>>>>>>>>> 4th Args option for node : apply int_gen  (, dummy )
 >>>>>>>>>>>>>>>>>>> 4th Args option for node : s0
 TEST Overall List : List of Args for node
 EI s01
 EI n
 EI apply subs  (, s )
 EI apply subs  (, s01 )
 EI apply subs  (, root )
 EI s
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI apply subs  (, s0 )
 EI apply int_gen  (, dummy )
 EI s0
 TEST Overall List : List of Args for node
 TEST Overall List : List of Args for node
 EI s01
 EI n
 EI apply subs  (, s )
 EI apply subs  (, s01 )
 EI apply subs  (, root )
 EI s
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI apply subs  (, s0 )
 EI apply int_gen  (, dummy )
 EI s0
 TEST Overall List : List of Args for node
 EI apply int_gen  (, dummy )
 ##################################################################################
  Synthesizing the 5th argument for Function node
  Trying Arguments in Scalars 
 esynthesizeScalar for {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }}
 
 Enumerating a Scalar Term leaf
 
 Type of the Scalar Term {v:Ty_alphatree | (tlen)(v) ==(0)}                                                                                                                                                    
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T723)
(declare-fun |0| () Int)
(declare-fun tlen (T723) Int)
(declare-fun leaf () T723)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun sizel () Int)
(declare-fun ltree () T723)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T723)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u108 Int) (var_u107 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= (tlen rtree) sizer)
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen leaf) 0)
         (= var_v3 false)
         a!4
         (= (tlen leaf) 0)))))
(assert (not (forall ((var_u109 Int)) (= (tlen leaf) sizer))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term rtree
 
 Type of the Scalar Term {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }}
 ################################################
 Skipping Variable rtree As this a  Formal Parameter to the current function Call
 ################################################
 
 Enumerating a Scalar Term ltree
 
 Type of the Scalar Term {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 ################################################
 Skipping Variable ltree As this a  Formal Parameter to the current function Call
 ################################################
 >>>>>>>>>>>>>>>>>> No Scalar found in Environment, Trying esynthesizePureApp <<<<<<<<<<<<<<<<<< 
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 TEST Overall List : List of Args for node
 TEST Overall List : List of Args for node
 EI s01
 EI n
 EI apply subs  (, s )
 EI apply subs  (, s01 )
 EI apply subs  (, root )
 EI s
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI apply subs  (, s0 )
 EI apply int_gen  (, dummy )
 EI s0
 TEST Overall List : List of Args for node
 TEST Overall List : List of Args for node
 EI s01
 EI n
 EI apply subs  (, s )
 EI apply subs  (, s01 )
 EI apply subs  (, root )
 EI s
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI apply subs  (, s0 )
 EI apply int_gen  (, dummy )
 EI s0
 TEST Overall List : List of Args for node
 EI apply int_gen  (, dummy )
 ##################################################################################
  *************** Synthesizing Args ei : Failed for some  arg
 TEST Overall List : List of Args for node
 TEST Overall List : List of Args for node
 EI root
 EI n
 EI s01
 EI sizel
 EI s
 EI apply int_gen  (, dummy )
 EI s0
 EI apply int_gen  (, dummy )
 TEST Overall List : List of Args for node
 EI apply int_gen  (, dummy )
 EI apply subs  (, s0 )
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI apply subs  (, s )
 EI apply subs  (, root )
 EI apply subs  (, s01 )
 ##################################################################################
  Synthesizing the 4th argument for Function node
  Trying Arguments in Scalars 
 esynthesizeScalar for {v:Ty_int | true}
 
 Enumerating a Scalar Term s0
 
 Type of the Scalar Term {v:Ty_int | true}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term _lbv0
 
 Type of the Scalar Term {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 Enumerating a Scalar Term _lbv1
 
 Type of the Scalar Term {v:Ty_int | (v) ==((s0) -- (1))}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 Enumerating a Scalar Term _lbv2
 
 Type of the Scalar Term {v:Ty_int | (v) ==((_lbv0) -- (1))}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 Enumerating a Scalar Term s
 
 Type of the Scalar Term {var_v0:Ty_int | true}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term _lbv6
 
 Type of the Scalar Term {v:Ty_int | (v) ==((root) -- (1))}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 Enumerating a Scalar Term _lbv7
 
 Type of the Scalar Term {v:Ty_int | (v) ==((s01) -- (1))}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 Enumerating a Scalar Term _lbv8
 
 Type of the Scalar Term {v:Ty_int | (v) ==((s) -- (1))}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {v:Ty_int | true}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term s01
 
 Type of the Scalar Term {v:Ty_int | 
 	 Conj <c true
 	 , s0 > v >c }
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term root
 
 Type of the Scalar Term {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term sizel
 
 Type of the Scalar Term {v:Ty_int | true}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term sizer
 
 Type of the Scalar Term {v:Ty_int | true}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  , 
 subs, 
 int_gen
 ############################################################
  Synthesizing the Function application Pure Component subs
 ############################################################
  *************** Trying Arrow Component ************subs :  Arrow ( ( n : {v:Ty_int | true} ) -> {v:Ty_int | (v) ==((n) -- (1))}
  *************** Synthesizing Args ei : ti for ************subs
 ##################################################################################
  Synthesizing the 1th argument for Function subs
  Trying Arguments in Scalars 
 esynthesizeScalar for {v:Ty_int | true}
 
 Enumerating a Scalar Term s0
 
 Type of the Scalar Term {v:Ty_int | true}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term _lbv0
 
 Type of the Scalar Term {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 Enumerating a Scalar Term _lbv1
 
 Type of the Scalar Term {v:Ty_int | (v) ==((s0) -- (1))}
 ################################################
 Skipping Variable _lbv1 As Outer Function Call is subs
 
 Enumerating a Scalar Term _lbv2
 
 Type of the Scalar Term {v:Ty_int | (v) ==((_lbv0) -- (1))}
 ################################################
 Skipping Variable _lbv2 As Outer Function Call is subs
 
 Enumerating a Scalar Term s
 
 Type of the Scalar Term {var_v0:Ty_int | true}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term _lbv6
 
 Type of the Scalar Term {v:Ty_int | (v) ==((root) -- (1))}
 ################################################
 Skipping Variable _lbv6 As Outer Function Call is subs
 
 Enumerating a Scalar Term _lbv7
 
 Type of the Scalar Term {v:Ty_int | (v) ==((s01) -- (1))}
 ################################################
 Skipping Variable _lbv7 As Outer Function Call is subs
 
 Enumerating a Scalar Term _lbv8
 
 Type of the Scalar Term {v:Ty_int | (v) ==((s) -- (1))}
 ################################################
 Skipping Variable _lbv8 As Outer Function Call is subs
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {v:Ty_int | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 ################################################
 
 Enumerating a Scalar Term s01
 
 Type of the Scalar Term {v:Ty_int | 
 	 Conj <c true
 	 , s0 > v >c }
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term root
 
 Type of the Scalar Term {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term sizel
 
 Type of the Scalar Term {v:Ty_int | true}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term sizer
 
 Type of the Scalar Term {v:Ty_int | true}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>> 1th Args option for subs : sizer
 >>>>>>>>>>>>>>>>>>> 1th Args option for subs : sizel
 >>>>>>>>>>>>>>>>>>> 1th Args option for subs : root
 >>>>>>>>>>>>>>>>>>> 1th Args option for subs : s01
 >>>>>>>>>>>>>>>>>>> 1th Args option for subs : s
 >>>>>>>>>>>>>>>>>>> 1th Args option for subs : apply int_gen  (, dummy )
 >>>>>>>>>>>>>>>>>>> 1th Args option for subs : s0
 TEST Overall List : List of Args for subs
 EI sizer
 EI sizel
 EI root
 EI s01
 EI s
 EI apply int_gen  (, dummy )
 EI s0
 ##################################################################################
  *************** Successfully Synthesized Args ei Forall i 
 Ith Argument Options for subs
 EI sizer
 EI sizel
 EI root
 EI s01
 EI s
 EI apply int_gen  (, dummy )
 EI s0
 # of Possible Argument Options for subs 7
 Possible Arg Options 
 EI sizer
 Possible Arg Options 
 EI sizel
 Possible Arg Options 
 EI root
 Possible Arg Options 
 EI s01
 Possible Arg Options 
 EI s
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 Possible Arg Options 
 EI s0
 Apply Single Argument Case : f (ei) Case subs
  Case : f (ei) Case subs sizer
 Finding Already seen tree for apply subs  (, sizer )
 Typechecking the Term apply subs  (, sizer )
 Against {v:Ty_int | true}
 Argument sizer :: {v:Ty_int | true} | true
 AppType Type {v:Ty_int | (v) ==((sizer) -- (1))}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
  Show *************** TypeChecking Succsessful {v:Ty_int | (v) ==((sizer) -- (1))}
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 let _lbv9 = apply subs  (, sizer )
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  Case : f (ei) Case subs sizel
 Finding Already seen tree for apply subs  (, sizel )
 Typechecking the Term apply subs  (, sizel )
 Against {v:Ty_int | true}
 Argument sizel :: {v:Ty_int | true} | true
 AppType Type {v:Ty_int | (v) ==((sizel) -- (1))}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
  Show *************** TypeChecking Succsessful {v:Ty_int | (v) ==((sizel) -- (1))}
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 let _lbv10 = apply subs  (, sizel )
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  Case : f (ei) Case subs root
 Finding Already seen tree for apply subs  (, root )
 Found _lbv6
  Case : f (ei) Case subs s01
 Finding Already seen tree for apply subs  (, s01 )
 Found _lbv7
  Case : f (ei) Case subs s
 Finding Already seen tree for apply subs  (, s )
 Found _lbv8
  Case : f (ei) Case subs _lbv0
 Finding Already seen tree for apply subs  (, _lbv0 )
 Found _lbv2
  Case : f (ei) Case subs s0
 Finding Already seen tree for apply subs  (, s0 )
 Found _lbv1
 >>>>>>>>>>>>>>>>>>> 4th Args option for node : sizer
 >>>>>>>>>>>>>>>>>>> 4th Args option for node : sizel
 >>>>>>>>>>>>>>>>>>> 4th Args option for node : root
 >>>>>>>>>>>>>>>>>>> 4th Args option for node : s01
 >>>>>>>>>>>>>>>>>>> 4th Args option for node : n
 >>>>>>>>>>>>>>>>>>> 4th Args option for node : apply subs  (, s )
 >>>>>>>>>>>>>>>>>>> 4th Args option for node : apply subs  (, s01 )
 >>>>>>>>>>>>>>>>>>> 4th Args option for node : apply subs  (, root )
 >>>>>>>>>>>>>>>>>>> 4th Args option for node : s
 >>>>>>>>>>>>>>>>>>> 4th Args option for node : apply subs  (, apply int_gen  (, dummy ) )
 >>>>>>>>>>>>>>>>>>> 4th Args option for node : apply subs  (, s0 )
 >>>>>>>>>>>>>>>>>>> 4th Args option for node : apply int_gen  (, dummy )
 >>>>>>>>>>>>>>>>>>> 4th Args option for node : s0
 >>>>>>>>>>>>>>>>>>> 4th Args option for node : apply subs  (, s0 )
 >>>>>>>>>>>>>>>>>>> 4th Args option for node : apply subs  (, apply int_gen  (, dummy ) )
 >>>>>>>>>>>>>>>>>>> 4th Args option for node : apply subs  (, s )
 >>>>>>>>>>>>>>>>>>> 4th Args option for node : apply subs  (, s01 )
 >>>>>>>>>>>>>>>>>>> 4th Args option for node : apply subs  (, root )
 >>>>>>>>>>>>>>>>>>> 4th Args option for node : apply subs  (, sizel )
 >>>>>>>>>>>>>>>>>>> 4th Args option for node : apply subs  (, sizer )
 TEST Overall List : List of Args for node
 EI sizer
 EI sizel
 EI root
 EI s01
 EI n
 EI apply subs  (, s )
 EI apply subs  (, s01 )
 EI apply subs  (, root )
 EI s
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI apply subs  (, s0 )
 EI apply int_gen  (, dummy )
 EI s0
 EI apply subs  (, s0 )
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI apply subs  (, s )
 EI apply subs  (, s01 )
 EI apply subs  (, root )
 EI apply subs  (, sizel )
 EI apply subs  (, sizer )
 TEST Overall List : List of Args for node
 TEST Overall List : List of Args for node
 EI root
 EI n
 EI s01
 EI sizel
 EI s
 EI apply int_gen  (, dummy )
 EI s0
 EI apply int_gen  (, dummy )
 TEST Overall List : List of Args for node
 EI apply int_gen  (, dummy )
 EI apply subs  (, s0 )
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI apply subs  (, s )
 EI apply subs  (, root )
 EI apply subs  (, s01 )
 ##################################################################################
  Synthesizing the 5th argument for Function node
  Trying Arguments in Scalars 
 esynthesizeScalar for {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }}
 
 Enumerating a Scalar Term leaf
 
 Type of the Scalar Term {v:Ty_alphatree | (tlen)(v) ==(0)}                                                                                                                                                    
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T751)
(declare-fun |0| () Int)
(declare-fun tlen (T751) Int)
(declare-fun leaf () T751)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun sizel () Int)
(declare-fun _lbv10 () Int)
(declare-fun sizer () Int)
(declare-fun _lbv9 () Int)
(declare-fun ltree () T751)
(declare-fun rtree () T751)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u111 Int) (var_u110 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen rtree) sizer)
         (= (tlen ltree) sizel)
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (= (tlen leaf) 0)
         (= var_v3 false)
         a!4
         (= (tlen leaf) 0)))))
(assert (not (forall ((var_u112 Int)) (= (tlen leaf) sizer))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term rtree
 
 Type of the Scalar Term {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }}                                                                                                                                                    
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T756)
(declare-fun |0| () Int)
(declare-fun sizer () Int)
(declare-fun tlen (T756) Int)
(declare-fun rtree () T756)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun sizel () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun ltree () T756)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T756)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u115 Int) (var_u114 Int) (var_u113 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (= (tlen rtree) sizer)
         (= var_v3 false)
         a!4
         (= (tlen rtree) sizer)))))
(assert (not (forall ((var_u116 Int)) (= (tlen rtree) sizer))))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term ltree
 
 Type of the Scalar Term {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}                                                                                                                                                    
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T762)
(declare-fun |0| () Int)
(declare-fun sizel () Int)
(declare-fun tlen (T762) Int)
(declare-fun ltree () T762)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun _lbv10 () Int)
(declare-fun sizer () Int)
(declare-fun _lbv9 () Int)
(declare-fun rtree () T762)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T762)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u119 Int) (var_u118 Int) (var_u117 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen rtree) sizer)
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (= (tlen ltree) sizel)
         (= var_v3 false)
         a!4
         (= (tlen ltree) sizel)))))
(assert (not (forall ((var_u120 Int)) (= (tlen ltree) sizer))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 
 FaileD the subtype check T_vi <: T_goal
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  , 
 goal, 
 node
 ############################################################
  Synthesizing the Function application Pure Component goal
 ############################################################
  *************** Trying Arrow Component ************goal :  Arrow ( ( s01 : {v:Ty_int | 
 	 Conj <c true
 	 , s0 > v >c } ) -> {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (tlen)(v) ==(u)
 	 u = s01 > }}
  *************** Synthesizing Args ei : ti for ************goal
 ##################################################################################
  Synthesizing the 1th argument for Function goal
  Trying Arguments in Scalars 
 esynthesizeScalar for {v:Ty_int | 
 	 Conj <c true
 	 , s0 > v >c }
 
 Enumerating a Scalar Term s0
 
 Type of the Scalar Term {v:Ty_int | true}                                                                                                                                                         
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T768)
(declare-fun |0| () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun sizel () Int)
(declare-fun _lbv10 () Int)
(declare-fun sizer () Int)
(declare-fun _lbv9 () Int)
(declare-fun tlen (T768) Int)
(declare-fun ltree () T768)
(declare-fun rtree () T768)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T768)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u122 Int) (var_u121 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen rtree) sizer)
         (= (tlen ltree) sizel)
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (= var_v3 false)
         a!4))))
(assert (not (> s0 s0)))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term _lbv0
 
 Type of the Scalar Term {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }                                                                                                                                                                    
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T774)
(declare-fun |0| () Int)
(declare-fun _lbv0 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun sizel () Int)
(declare-fun _lbv10 () Int)
(declare-fun sizer () Int)
(declare-fun _lbv9 () Int)
(declare-fun tlen (T774) Int)
(declare-fun ltree () T774)
(declare-fun rtree () T774)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T774)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u124 Int) (var_u123 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen rtree) sizer)
         (= (tlen ltree) sizel)
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))))))
(assert (not (> s0 _lbv0)))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term _lbv1
 
 Type of the Scalar Term {v:Ty_int | (v) ==((s0) -- (1))}                                                                                                                                                         
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T780)
(declare-fun |0| () Int)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun sizel () Int)
(declare-fun _lbv10 () Int)
(declare-fun sizer () Int)
(declare-fun _lbv9 () Int)
(declare-fun tlen (T780) Int)
(declare-fun ltree () T780)
(declare-fun rtree () T780)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T780)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u126 Int) (var_u125 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen rtree) sizer)
         (= (tlen ltree) sizel)
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (= _lbv1 (- s0 1))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))))))
(assert (not (> s0 _lbv1)))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 Enumerating a Scalar Term _lbv2
 
 Type of the Scalar Term {v:Ty_int | (v) ==((_lbv0) -- (1))}                                                                                                                                                         
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T786)
(declare-fun |0| () Int)
(declare-fun _lbv0 () Int)
(declare-fun _lbv2 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun sizel () Int)
(declare-fun _lbv10 () Int)
(declare-fun sizer () Int)
(declare-fun _lbv9 () Int)
(declare-fun tlen (T786) Int)
(declare-fun ltree () T786)
(declare-fun rtree () T786)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T786)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u128 Int) (var_u127 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen rtree) sizer)
         (= (tlen ltree) sizel)
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (= _lbv2 (- _lbv0 1))
         (= var_v3 false)
         a!4
         (= _lbv2 (- _lbv0 1))))))
(assert (not (> s0 _lbv2)))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term s
 
 Type of the Scalar Term {var_v0:Ty_int | true}                                                                                                                                                         
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T792)
(declare-fun |0| () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun sizel () Int)
(declare-fun _lbv10 () Int)
(declare-fun sizer () Int)
(declare-fun _lbv9 () Int)
(declare-fun tlen (T792) Int)
(declare-fun ltree () T792)
(declare-fun rtree () T792)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T792)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u130 Int) (var_u129 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen rtree) sizer)
         (= (tlen ltree) sizel)
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (= var_v3 false)
         a!4))))
(assert (not (> s0 s)))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term _lbv6
 
 Type of the Scalar Term {v:Ty_int | (v) ==((root) -- (1))}                                                                                                                                                         
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T798)
(declare-fun |0| () Int)
(declare-fun root () Int)
(declare-fun _lbv6 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun sizel () Int)
(declare-fun _lbv10 () Int)
(declare-fun sizer () Int)
(declare-fun _lbv9 () Int)
(declare-fun tlen (T798) Int)
(declare-fun ltree () T798)
(declare-fun rtree () T798)
(declare-fun s01 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T798)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u132 Int) (var_u131 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen rtree) sizer)
         (= (tlen ltree) sizel)
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (= _lbv6 (- root 1))
         (= var_v3 false)
         a!4
         (= _lbv6 (- root 1))))))
(assert (not (> s0 _lbv6)))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term _lbv7
 
 Type of the Scalar Term {v:Ty_int | (v) ==((s01) -- (1))}                                                                                                                                                         
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T804)
(declare-fun |0| () Int)
(declare-fun s01 () Int)
(declare-fun _lbv7 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun sizel () Int)
(declare-fun _lbv10 () Int)
(declare-fun sizer () Int)
(declare-fun _lbv9 () Int)
(declare-fun tlen (T804) Int)
(declare-fun ltree () T804)
(declare-fun rtree () T804)
(declare-fun root () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T804)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u134 Int) (var_u133 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv8 (- s 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen rtree) sizer)
         (= (tlen ltree) sizel)
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (= _lbv7 (- s01 1))
         (= var_v3 false)
         a!4
         (= _lbv7 (- s01 1))))))
(assert (not (> s0 _lbv7)))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 Enumerating a Scalar Term _lbv8
 
 Type of the Scalar Term {v:Ty_int | (v) ==((s) -- (1))}                                                                                                                                                         
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T810)
(declare-fun |0| () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun sizel () Int)
(declare-fun _lbv10 () Int)
(declare-fun sizer () Int)
(declare-fun _lbv9 () Int)
(declare-fun tlen (T810) Int)
(declare-fun ltree () T810)
(declare-fun rtree () T810)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T810)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u136 Int) (var_u135 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen rtree) sizer)
         (= (tlen ltree) sizel)
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (= _lbv8 (- s 1))
         (= var_v3 false)
         a!4
         (= _lbv8 (- s 1))))))
(assert (not (> s0 _lbv8)))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term s01
 
 Type of the Scalar Term {v:Ty_int | 
 	 Conj <c true
 	 , s0 > v >c }
 ################################################
 Skipping Variable s01 As this a  Formal Parameter to the current function Call
 ################################################
 
 Enumerating a Scalar Term root
 
 Type of the Scalar Term {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }                                                                                                                                                                    
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T816)
(declare-fun |0| () Int)
(declare-fun root () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun sizel () Int)
(declare-fun _lbv10 () Int)
(declare-fun sizer () Int)
(declare-fun _lbv9 () Int)
(declare-fun tlen (T816) Int)
(declare-fun ltree () T816)
(declare-fun rtree () T816)
(declare-fun s01 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T816)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u138 Int) (var_u137 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (> s0 s01)
         (= (tlen rtree) sizer)
         (= (tlen ltree) sizel)
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (or (> root |0|) (= root |0|))
         (= var_v3 false)
         a!4
         (or (> root |0|) (= root |0|))))))
(assert (not (> s0 root)))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term sizel
 
 Type of the Scalar Term {v:Ty_int | true}                                                                                                                                                         
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T822)
(declare-fun |0| () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun sizel () Int)
(declare-fun _lbv10 () Int)
(declare-fun sizer () Int)
(declare-fun _lbv9 () Int)
(declare-fun tlen (T822) Int)
(declare-fun ltree () T822)
(declare-fun rtree () T822)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T822)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u140 Int) (var_u139 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen rtree) sizer)
         (= (tlen ltree) sizel)
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (= var_v3 false)
         a!4))))
(assert (not (> s0 sizel)))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {v:Ty_int | true}                                                                                                                                                         
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T828)
(declare-fun |0| () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun sizel () Int)
(declare-fun _lbv10 () Int)
(declare-fun sizer () Int)
(declare-fun _lbv9 () Int)
(declare-fun tlen (T828) Int)
(declare-fun ltree () T828)
(declare-fun rtree () T828)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T828)
(declare-fun n () Int)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u142 Int) (var_u141 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen rtree) sizer)
         (= (tlen ltree) sizel)
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (= var_v3 false)
         a!4))))
(assert (not (> s0 n)))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term _lbv9
 
 Type of the Scalar Term {v:Ty_int | (v) ==((sizer) -- (1))}                                                                                                                                                         
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T834)
(declare-fun |0| () Int)
(declare-fun sizer () Int)
(declare-fun _lbv9 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun sizel () Int)
(declare-fun _lbv10 () Int)
(declare-fun tlen (T834) Int)
(declare-fun ltree () T834)
(declare-fun rtree () T834)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T834)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u144 Int) (var_u143 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen rtree) sizer)
         (= (tlen ltree) sizel)
         (= _lbv10 (- sizel 1))
         (= _lbv9 (- sizer 1))
         (= var_v3 false)
         a!4
         (= _lbv9 (- sizer 1))))))
(assert (not (> s0 _lbv9)))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term _lbv10
 
 Type of the Scalar Term {v:Ty_int | (v) ==((sizel) -- (1))}                                                                                                                                                         
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T840)
(declare-fun |0| () Int)
(declare-fun sizel () Int)
(declare-fun _lbv10 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun sizer () Int)
(declare-fun _lbv9 () Int)
(declare-fun tlen (T840) Int)
(declare-fun ltree () T840)
(declare-fun rtree () T840)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T840)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u146 Int) (var_u145 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen rtree) sizer)
         (= (tlen ltree) sizel)
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (= var_v3 false)
         a!4
         (= _lbv10 (- sizel 1))))))
(assert (not (> s0 _lbv10)))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term sizer
 
 Type of the Scalar Term {v:Ty_int | true}                                                                                                                                                         
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T846)
(declare-fun |0| () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun sizel () Int)
(declare-fun _lbv10 () Int)
(declare-fun sizer () Int)
(declare-fun _lbv9 () Int)
(declare-fun tlen (T846) Int)
(declare-fun ltree () T846)
(declare-fun rtree () T846)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T846)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u148 Int) (var_u147 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen rtree) sizer)
         (= (tlen ltree) sizel)
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (= var_v3 false)
         a!4))))
(assert (not (> s0 sizer)))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 
 FaileD the subtype check T_vi <: T_goal
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>> 1th Args option for goal : apply subs  (, s01 )
 >>>>>>>>>>>>>>>>>>> 1th Args option for goal : apply subs  (, s0 )
 TEST Overall List : List of Args for goal
 EI apply subs  (, s01 )
 EI apply subs  (, s0 )
 ##################################################################################
  *************** Successfully Synthesized Args ei Forall i 
 Ith Argument Options for goal
 EI apply subs  (, s01 )
 EI apply subs  (, s0 )
 # of Possible Argument Options for goal 2
 Possible Arg Options 
 EI apply subs  (, s01 )
 Possible Arg Options 
 EI apply subs  (, s0 )
 Apply Single Argument Case : f (ei) Case goal
  Case : f (ei) Case goal _lbv7
 Finding Already seen tree for apply goal  (, _lbv7 )
 Typechecking the Term apply goal  (, _lbv7 )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }}
 Argument _lbv7 :: {v:Ty_int | (v) ==((s01) -- (1))} | (_lbv7) ==((s01) -- (1))
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (tlen)(v) ==(u)
 	 u = _lbv7 > }}                                                                                                                                                                
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T852)
(declare-fun |0| () Int)
(declare-fun _lbv7 () Int)
(declare-fun tlen (T852) Int)
(declare-fun v () T852)
(declare-fun s01 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun sizel () Int)
(declare-fun _lbv10 () Int)
(declare-fun sizer () Int)
(declare-fun _lbv9 () Int)
(declare-fun ltree () T852)
(declare-fun rtree () T852)
(declare-fun root () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T852)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u152 Int) (var_u151 Int) (var_u150 Int) (var_u149 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (or (> root |0|) (= root |0|))
         (= (tlen rtree) sizer)
         (= (tlen ltree) sizel)
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (=> (= (tlen v) var_u151) (= var_u151 _lbv7))
         (= var_v3 false)
         a!4
         (= _lbv7 (- s01 1))
         (=> (= (tlen v) var_u152) (= var_u152 _lbv7))))))
(assert (not (forall ((var_u153 Int)) (= (tlen v) sizer))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply goal  (, _lbv7 )
  Case : f (ei) Case goal _lbv1
 Finding Already seen tree for apply goal  (, _lbv1 )
 Typechecking the Term apply goal  (, _lbv1 )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (tlen)(v) ==(u)
 	 u = _lbv1 > }}                                                                                                                                                                
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T858)
(declare-fun |0| () Int)
(declare-fun _lbv1 () Int)
(declare-fun tlen (T858) Int)
(declare-fun v () T858)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun sizel () Int)
(declare-fun _lbv10 () Int)
(declare-fun sizer () Int)
(declare-fun _lbv9 () Int)
(declare-fun ltree () T858)
(declare-fun rtree () T858)
(declare-fun root () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T858)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u157 Int) (var_u156 Int) (var_u155 Int) (var_u154 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (or (> root |0|) (= root |0|))
         (= (tlen rtree) sizer)
         (= (tlen ltree) sizel)
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (=> (= (tlen v) var_u156) (= var_u156 _lbv1))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (=> (= (tlen v) var_u157) (= var_u157 _lbv1))))))
(assert (not (forall ((var_u158 Int)) (= (tlen v) sizer))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply goal  (, _lbv1 )
  ###################################################
  The Choice of Function goal Was Ill Fated Try Next Choice of function
 ############################################################
  Synthesizing the Function application Pure Component node
 ############################################################
  *************** Trying Arrow Component ************node :  Arrow ( ( root : {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } ) ->  Arrow ( ( sizel : {v:Ty_int | true} ) ->  Arrow ( ( ltree : {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} ) ->  Arrow ( ( sizer : {v:Ty_int | true} ) ->  Arrow ( ( rtree : {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} ) -> {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((sizel) + (1))
 	 (tlen)(v) ==(u) > }}
  *************** Synthesizing Args ei : ti for ************node
 ##################################################################################
  Synthesizing the 1th argument for Function node
  Trying Arguments in Scalars 
 esynthesizeScalar for {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }
 
 Enumerating a Scalar Term s0
 
 Type of the Scalar Term {v:Ty_int | true}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T864)
(declare-fun |0| () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun sizel () Int)
(declare-fun _lbv10 () Int)
(declare-fun sizer () Int)
(declare-fun _lbv9 () Int)
(declare-fun tlen (T864) Int)
(declare-fun ltree () T864)
(declare-fun rtree () T864)
(declare-fun root () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T864)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u160 Int) (var_u159 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (or (> root |0|) (= root |0|))
         (= (tlen rtree) sizer)
         (= (tlen ltree) sizel)
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (= var_v3 false)
         a!4))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (not (or (> s0 |0|) (= s0 |0|))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term _lbv0
 
 Type of the Scalar Term {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }                                                                                                                                                                          
# of Final Z3 expressions 20
 Final solver 
 (declare-sort T870)
(declare-fun |0| () Int)
(declare-fun _lbv0 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun sizel () Int)
(declare-fun _lbv10 () Int)
(declare-fun sizer () Int)
(declare-fun _lbv9 () Int)
(declare-fun tlen (T870) Int)
(declare-fun ltree () T870)
(declare-fun rtree () T870)
(declare-fun root () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T870)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u162 Int) (var_u161 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (or (> root |0|) (= root |0|))
         (= (tlen rtree) sizer)
         (= (tlen ltree) sizel)
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (not (or (> _lbv0 |0|) (= _lbv0 |0|))))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 Enumerating a Scalar Term _lbv1
 
 Type of the Scalar Term {v:Ty_int | (v) ==((s0) -- (1))}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T876)
(declare-fun |0| () Int)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun sizel () Int)
(declare-fun _lbv10 () Int)
(declare-fun sizer () Int)
(declare-fun _lbv9 () Int)
(declare-fun tlen (T876) Int)
(declare-fun ltree () T876)
(declare-fun rtree () T876)
(declare-fun root () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T876)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u164 Int) (var_u163 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (or (> root |0|) (= root |0|))
         (= (tlen rtree) sizer)
         (= (tlen ltree) sizel)
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (= _lbv1 (- s0 1))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (not (or (> _lbv1 |0|) (= _lbv1 |0|))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term _lbv2
 
 Type of the Scalar Term {v:Ty_int | (v) ==((_lbv0) -- (1))}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T882)
(declare-fun |0| () Int)
(declare-fun _lbv0 () Int)
(declare-fun _lbv2 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun sizel () Int)
(declare-fun _lbv10 () Int)
(declare-fun sizer () Int)
(declare-fun _lbv9 () Int)
(declare-fun tlen (T882) Int)
(declare-fun ltree () T882)
(declare-fun rtree () T882)
(declare-fun root () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T882)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u166 Int) (var_u165 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (or (> root |0|) (= root |0|))
         (= (tlen rtree) sizer)
         (= (tlen ltree) sizel)
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (= _lbv2 (- _lbv0 1))
         (= var_v3 false)
         a!4
         (= _lbv2 (- _lbv0 1))))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (not (or (> _lbv2 |0|) (= _lbv2 |0|))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term s
 
 Type of the Scalar Term {var_v0:Ty_int | true}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T888)
(declare-fun |0| () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun sizel () Int)
(declare-fun _lbv10 () Int)
(declare-fun sizer () Int)
(declare-fun _lbv9 () Int)
(declare-fun tlen (T888) Int)
(declare-fun ltree () T888)
(declare-fun rtree () T888)
(declare-fun root () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T888)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u168 Int) (var_u167 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (or (> root |0|) (= root |0|))
         (= (tlen rtree) sizer)
         (= (tlen ltree) sizel)
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (= var_v3 false)
         a!4))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (not (or (> s |0|) (= s |0|))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term _lbv6
 
 Type of the Scalar Term {v:Ty_int | (v) ==((root) -- (1))}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T894)
(declare-fun |0| () Int)
(declare-fun root () Int)
(declare-fun _lbv6 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun sizel () Int)
(declare-fun _lbv10 () Int)
(declare-fun sizer () Int)
(declare-fun _lbv9 () Int)
(declare-fun tlen (T894) Int)
(declare-fun ltree () T894)
(declare-fun rtree () T894)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T894)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u170 Int) (var_u169 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (or (> root |0|) (= root |0|))
         (= (tlen rtree) sizer)
         (= (tlen ltree) sizel)
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (= _lbv6 (- root 1))
         (= var_v3 false)
         a!4
         (= _lbv6 (- root 1))))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (not (or (> _lbv6 |0|) (= _lbv6 |0|))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term _lbv7
 
 Type of the Scalar Term {v:Ty_int | (v) ==((s01) -- (1))}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T900)
(declare-fun |0| () Int)
(declare-fun s01 () Int)
(declare-fun _lbv7 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun sizel () Int)
(declare-fun _lbv10 () Int)
(declare-fun sizer () Int)
(declare-fun _lbv9 () Int)
(declare-fun tlen (T900) Int)
(declare-fun ltree () T900)
(declare-fun rtree () T900)
(declare-fun root () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T900)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u172 Int) (var_u171 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv8 (- s 1))
         (or (> root |0|) (= root |0|))
         (= (tlen rtree) sizer)
         (= (tlen ltree) sizel)
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (= _lbv7 (- s01 1))
         (= var_v3 false)
         a!4
         (= _lbv7 (- s01 1))))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (not (or (> _lbv7 |0|) (= _lbv7 |0|))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term _lbv8
 
 Type of the Scalar Term {v:Ty_int | (v) ==((s) -- (1))}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T906)
(declare-fun |0| () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun sizel () Int)
(declare-fun _lbv10 () Int)
(declare-fun sizer () Int)
(declare-fun _lbv9 () Int)
(declare-fun tlen (T906) Int)
(declare-fun ltree () T906)
(declare-fun rtree () T906)
(declare-fun root () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T906)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u174 Int) (var_u173 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (or (> root |0|) (= root |0|))
         (= (tlen rtree) sizer)
         (= (tlen ltree) sizel)
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (= _lbv8 (- s 1))
         (= var_v3 false)
         a!4
         (= _lbv8 (- s 1))))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (not (or (> _lbv8 |0|) (= _lbv8 |0|))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term root
 
 Type of the Scalar Term {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }
 ################################################
 Skipping Variable root As this a  Formal Parameter to the current function Call
 ################################################
 
 Enumerating a Scalar Term sizel
 
 Type of the Scalar Term {v:Ty_int | true}
 ################################################
 Skipping Variable sizel As this a  Formal Parameter to the current function Call
 ################################################
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {v:Ty_int | true}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T912)
(declare-fun |0| () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun sizel () Int)
(declare-fun _lbv10 () Int)
(declare-fun sizer () Int)
(declare-fun _lbv9 () Int)
(declare-fun tlen (T912) Int)
(declare-fun ltree () T912)
(declare-fun rtree () T912)
(declare-fun root () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T912)
(declare-fun n () Int)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u176 Int) (var_u175 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (or (> root |0|) (= root |0|))
         (= (tlen rtree) sizer)
         (= (tlen ltree) sizel)
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (= var_v3 false)
         a!4))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (not (or (> n |0|) (= n |0|))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term _lbv9
 
 Type of the Scalar Term {v:Ty_int | (v) ==((sizer) -- (1))}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T918)
(declare-fun |0| () Int)
(declare-fun sizer () Int)
(declare-fun _lbv9 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun sizel () Int)
(declare-fun _lbv10 () Int)
(declare-fun tlen (T918) Int)
(declare-fun ltree () T918)
(declare-fun rtree () T918)
(declare-fun root () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T918)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u178 Int) (var_u177 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (or (> root |0|) (= root |0|))
         (= (tlen rtree) sizer)
         (= (tlen ltree) sizel)
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (= _lbv9 (- sizer 1))
         (= var_v3 false)
         a!4
         (= _lbv9 (- sizer 1))))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (not (or (> _lbv9 |0|) (= _lbv9 |0|))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term _lbv10
 
 Type of the Scalar Term {v:Ty_int | (v) ==((sizel) -- (1))}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T924)
(declare-fun |0| () Int)
(declare-fun sizel () Int)
(declare-fun _lbv10 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun sizer () Int)
(declare-fun _lbv9 () Int)
(declare-fun tlen (T924) Int)
(declare-fun ltree () T924)
(declare-fun rtree () T924)
(declare-fun root () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T924)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u180 Int) (var_u179 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (or (> root |0|) (= root |0|))
         (= (tlen rtree) sizer)
         (= (tlen ltree) sizel)
         (= _lbv9 (- sizer 1))
         (> s0 s01)
         (= _lbv10 (- sizel 1))
         (= var_v3 false)
         a!4
         (= _lbv10 (- sizel 1))))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (not (or (> _lbv10 |0|) (= _lbv10 |0|))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term sizer
 
 Type of the Scalar Term {v:Ty_int | true}
 ################################################
 Skipping Variable sizer As this a  Formal Parameter to the current function Call
 ################################################
 
 Enumerating a Scalar Term s01
 
 Type of the Scalar Term {v:Ty_int | 
 	 Conj <c true
 	 , s0 > v >c }                                                                                                                                                                    
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T930)
(declare-fun |0| () Int)
(declare-fun s01 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun sizel () Int)
(declare-fun _lbv10 () Int)
(declare-fun sizer () Int)
(declare-fun _lbv9 () Int)
(declare-fun tlen (T930) Int)
(declare-fun ltree () T930)
(declare-fun rtree () T930)
(declare-fun root () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T930)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u182 Int) (var_u181 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (or (> root |0|) (= root |0|))
         (= (tlen rtree) sizer)
         (= (tlen ltree) sizel)
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (= var_v3 false)
         a!4
         (> s0 s01)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (not (or (> s01 |0|) (= s01 |0|))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 
 FaileD the subtype check T_vi <: T_goal
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>> 1th Args option for node : apply int_gen  (, dummy )
 TEST Overall List : List of Args for node
 EI apply int_gen  (, dummy )
 ##################################################################################
  Synthesizing the 2th argument for Function node
  Trying Arguments in Scalars 
 esynthesizeScalar for {v:Ty_int | true}
 
 Enumerating a Scalar Term s0
 
 Type of the Scalar Term {v:Ty_int | true}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term _lbv0
 
 Type of the Scalar Term {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 Enumerating a Scalar Term _lbv1
 
 Type of the Scalar Term {v:Ty_int | (v) ==((s0) -- (1))}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 Enumerating a Scalar Term _lbv2
 
 Type of the Scalar Term {v:Ty_int | (v) ==((_lbv0) -- (1))}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 Enumerating a Scalar Term s
 
 Type of the Scalar Term {var_v0:Ty_int | true}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term _lbv6
 
 Type of the Scalar Term {v:Ty_int | (v) ==((root) -- (1))}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 Enumerating a Scalar Term _lbv7
 
 Type of the Scalar Term {v:Ty_int | (v) ==((s01) -- (1))}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 Enumerating a Scalar Term _lbv8
 
 Type of the Scalar Term {v:Ty_int | (v) ==((s) -- (1))}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 Enumerating a Scalar Term sizel
 
 Type of the Scalar Term {v:Ty_int | true}
 ################################################
 Skipping Variable sizel As this a  Formal Parameter to the current function Call
 ################################################
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {v:Ty_int | true}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term _lbv9
 
 Type of the Scalar Term {v:Ty_int | (v) ==((sizer) -- (1))}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 Enumerating a Scalar Term _lbv10
 
 Type of the Scalar Term {v:Ty_int | (v) ==((sizel) -- (1))}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 Enumerating a Scalar Term sizer
 
 Type of the Scalar Term {v:Ty_int | true}
 ################################################
 Skipping Variable sizer As this a  Formal Parameter to the current function Call
 ################################################
 
 Enumerating a Scalar Term s01
 
 Type of the Scalar Term {v:Ty_int | 
 	 Conj <c true
 	 , s0 > v >c }
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term root
 
 Type of the Scalar Term {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }
 ################################################
 Skipping Variable root As this a  Formal Parameter to the current function Call
 ################################################
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>> 2th Args option for node : s01
 >>>>>>>>>>>>>>>>>>> 2th Args option for node : apply subs  (, sizel )
 >>>>>>>>>>>>>>>>>>> 2th Args option for node : apply subs  (, sizer )
 >>>>>>>>>>>>>>>>>>> 2th Args option for node : n
 >>>>>>>>>>>>>>>>>>> 2th Args option for node : apply subs  (, s )
 >>>>>>>>>>>>>>>>>>> 2th Args option for node : apply subs  (, s01 )
 >>>>>>>>>>>>>>>>>>> 2th Args option for node : apply subs  (, root )
 >>>>>>>>>>>>>>>>>>> 2th Args option for node : s
 >>>>>>>>>>>>>>>>>>> 2th Args option for node : apply subs  (, apply int_gen  (, dummy ) )
 >>>>>>>>>>>>>>>>>>> 2th Args option for node : apply subs  (, s0 )
 >>>>>>>>>>>>>>>>>>> 2th Args option for node : apply int_gen  (, dummy )
 >>>>>>>>>>>>>>>>>>> 2th Args option for node : s0
 TEST Overall List : List of Args for node
 EI s01
 EI apply subs  (, sizel )
 EI apply subs  (, sizer )
 EI n
 EI apply subs  (, s )
 EI apply subs  (, s01 )
 EI apply subs  (, root )
 EI s
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI apply subs  (, s0 )
 EI apply int_gen  (, dummy )
 EI s0
 TEST Overall List : List of Args for node
 EI apply int_gen  (, dummy )
 ##################################################################################
  Synthesizing the 3th argument for Function node
  Trying Arguments in Scalars 
 esynthesizeScalar for {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 
 Enumerating a Scalar Term leaf
 
 Type of the Scalar Term {v:Ty_alphatree | (tlen)(v) ==(0)}                                                                                                                                                    
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T949)
(declare-fun |0| () Int)
(declare-fun tlen (T949) Int)
(declare-fun leaf () T949)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun sizel () Int)
(declare-fun _lbv10 () Int)
(declare-fun sizer () Int)
(declare-fun _lbv9 () Int)
(declare-fun ltree () T949)
(declare-fun rtree () T949)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u184 Int) (var_u183 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= (tlen rtree) sizer)
         (= (tlen ltree) sizel)
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen leaf) 0)
         (= var_v3 false)
         a!4
         (= (tlen leaf) 0)))))
(assert (not (forall ((var_u185 Int)) (= (tlen leaf) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term rtree
 
 Type of the Scalar Term {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }}
 ################################################
 Skipping Variable rtree As this a  Formal Parameter to the current function Call
 ################################################
 
 Enumerating a Scalar Term ltree
 
 Type of the Scalar Term {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 ################################################
 Skipping Variable ltree As this a  Formal Parameter to the current function Call
 ################################################
 >>>>>>>>>>>>>>>>>> No Scalar found in Environment, Trying esynthesizePureApp <<<<<<<<<<<<<<<<<< 
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 TEST Overall List : List of Args for node
 TEST Overall List : List of Args for node
 EI s01
 EI apply subs  (, sizel )
 EI apply subs  (, sizer )
 EI n
 EI apply subs  (, s )
 EI apply subs  (, s01 )
 EI apply subs  (, root )
 EI s
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI apply subs  (, s0 )
 EI apply int_gen  (, dummy )
 EI s0
 TEST Overall List : List of Args for node
 EI apply int_gen  (, dummy )
 ##################################################################################
  Synthesizing the 4th argument for Function node
  Trying Arguments in Scalars 
 esynthesizeScalar for {v:Ty_int | true}
 
 Enumerating a Scalar Term s0
 
 Type of the Scalar Term {v:Ty_int | true}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term _lbv0
 
 Type of the Scalar Term {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 Enumerating a Scalar Term _lbv1
 
 Type of the Scalar Term {v:Ty_int | (v) ==((s0) -- (1))}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 Enumerating a Scalar Term _lbv2
 
 Type of the Scalar Term {v:Ty_int | (v) ==((_lbv0) -- (1))}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 Enumerating a Scalar Term s
 
 Type of the Scalar Term {var_v0:Ty_int | true}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term _lbv6
 
 Type of the Scalar Term {v:Ty_int | (v) ==((root) -- (1))}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 Enumerating a Scalar Term _lbv7
 
 Type of the Scalar Term {v:Ty_int | (v) ==((s01) -- (1))}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 Enumerating a Scalar Term _lbv8
 
 Type of the Scalar Term {v:Ty_int | (v) ==((s) -- (1))}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {v:Ty_int | true}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term _lbv9
 
 Type of the Scalar Term {v:Ty_int | (v) ==((sizer) -- (1))}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 Enumerating a Scalar Term _lbv10
 
 Type of the Scalar Term {v:Ty_int | (v) ==((sizel) -- (1))}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 Enumerating a Scalar Term sizer
 
 Type of the Scalar Term {v:Ty_int | true}
 ################################################
 Skipping Variable sizer As this a  Formal Parameter to the current function Call
 ################################################
 
 Enumerating a Scalar Term s01
 
 Type of the Scalar Term {v:Ty_int | 
 	 Conj <c true
 	 , s0 > v >c }
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term root
 
 Type of the Scalar Term {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }
 ################################################
 Skipping Variable root As this a  Formal Parameter to the current function Call
 ################################################
 
 Enumerating a Scalar Term sizel
 
 Type of the Scalar Term {v:Ty_int | true}
 ################################################
 Skipping Variable sizel As this a  Formal Parameter to the current function Call
 ################################################
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>> 4th Args option for node : s01
 >>>>>>>>>>>>>>>>>>> 4th Args option for node : apply subs  (, sizel )
 >>>>>>>>>>>>>>>>>>> 4th Args option for node : apply subs  (, sizer )
 >>>>>>>>>>>>>>>>>>> 4th Args option for node : n
 >>>>>>>>>>>>>>>>>>> 4th Args option for node : apply subs  (, s )
 >>>>>>>>>>>>>>>>>>> 4th Args option for node : apply subs  (, s01 )
 >>>>>>>>>>>>>>>>>>> 4th Args option for node : apply subs  (, root )
 >>>>>>>>>>>>>>>>>>> 4th Args option for node : s
 >>>>>>>>>>>>>>>>>>> 4th Args option for node : apply subs  (, apply int_gen  (, dummy ) )
 >>>>>>>>>>>>>>>>>>> 4th Args option for node : apply subs  (, s0 )
 >>>>>>>>>>>>>>>>>>> 4th Args option for node : apply int_gen  (, dummy )
 >>>>>>>>>>>>>>>>>>> 4th Args option for node : s0
 TEST Overall List : List of Args for node
 EI s01
 EI apply subs  (, sizel )
 EI apply subs  (, sizer )
 EI n
 EI apply subs  (, s )
 EI apply subs  (, s01 )
 EI apply subs  (, root )
 EI s
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI apply subs  (, s0 )
 EI apply int_gen  (, dummy )
 EI s0
 TEST Overall List : List of Args for node
 TEST Overall List : List of Args for node
 EI s01
 EI apply subs  (, sizel )
 EI apply subs  (, sizer )
 EI n
 EI apply subs  (, s )
 EI apply subs  (, s01 )
 EI apply subs  (, root )
 EI s
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI apply subs  (, s0 )
 EI apply int_gen  (, dummy )
 EI s0
 TEST Overall List : List of Args for node
 EI apply int_gen  (, dummy )
 ##################################################################################
  Synthesizing the 5th argument for Function node
  Trying Arguments in Scalars 
 esynthesizeScalar for {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }}
 
 Enumerating a Scalar Term leaf
 
 Type of the Scalar Term {v:Ty_alphatree | (tlen)(v) ==(0)}                                                                                                                                                    
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T967)
(declare-fun |0| () Int)
(declare-fun tlen (T967) Int)
(declare-fun leaf () T967)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun sizel () Int)
(declare-fun ltree () T967)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun sizer () Int)
(declare-fun _lbv9 () Int)
(declare-fun rtree () T967)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u187 Int) (var_u186 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= (tlen rtree) sizer)
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen leaf) 0)
         (= var_v3 false)
         a!4
         (= (tlen leaf) 0)))))
(assert (not (forall ((var_u188 Int)) (= (tlen leaf) sizer))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term rtree
 
 Type of the Scalar Term {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }}
 ################################################
 Skipping Variable rtree As this a  Formal Parameter to the current function Call
 ################################################
 
 Enumerating a Scalar Term ltree
 
 Type of the Scalar Term {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 ################################################
 Skipping Variable ltree As this a  Formal Parameter to the current function Call
 ################################################
 >>>>>>>>>>>>>>>>>> No Scalar found in Environment, Trying esynthesizePureApp <<<<<<<<<<<<<<<<<< 
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 TEST Overall List : List of Args for node
 TEST Overall List : List of Args for node
 EI s01
 EI apply subs  (, sizel )
 EI apply subs  (, sizer )
 EI n
 EI apply subs  (, s )
 EI apply subs  (, s01 )
 EI apply subs  (, root )
 EI s
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI apply subs  (, s0 )
 EI apply int_gen  (, dummy )
 EI s0
 TEST Overall List : List of Args for node
 TEST Overall List : List of Args for node
 EI s01
 EI apply subs  (, sizel )
 EI apply subs  (, sizer )
 EI n
 EI apply subs  (, s )
 EI apply subs  (, s01 )
 EI apply subs  (, root )
 EI s
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI apply subs  (, s0 )
 EI apply int_gen  (, dummy )
 EI s0
 TEST Overall List : List of Args for node
 EI apply int_gen  (, dummy )
 ##################################################################################
  *************** Synthesizing Args ei : Failed for some  arg
 >>>>>>>>>>>>>>>>>>> 5th Args option for node : rtree
 TEST Overall List : List of Args for node
 EI rtree
 TEST Overall List : List of Args for node
 EI sizer
 EI sizel
 EI root
 EI s01
 EI n
 EI apply subs  (, s )
 EI apply subs  (, s01 )
 EI apply subs  (, root )
 EI s
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI apply subs  (, s0 )
 EI apply int_gen  (, dummy )
 EI s0
 EI apply subs  (, s0 )
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI apply subs  (, s )
 EI apply subs  (, s01 )
 EI apply subs  (, root )
 EI apply subs  (, sizel )
 EI apply subs  (, sizer )
 TEST Overall List : List of Args for node
 TEST Overall List : List of Args for node
 EI root
 EI n
 EI s01
 EI sizel
 EI s
 EI apply int_gen  (, dummy )
 EI s0
 EI apply int_gen  (, dummy )
 TEST Overall List : List of Args for node
 EI apply int_gen  (, dummy )
 EI apply subs  (, s0 )
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI apply subs  (, s )
 EI apply subs  (, root )
 EI apply subs  (, s01 )
 ##################################################################################
  *************** Synthesizing Args ei : Failed for some  arg
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 Found Constructors with required return type
  
 ********************** HERE BEFORE 
 Show No more choices for ConsApp
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  , 
 goal, 
 node
 ############################################################
  Synthesizing the Function application Pure Component goal
 ############################################################
  *************** Trying Arrow Component ************goal :  Arrow ( ( s01 : {v:Ty_int | 
 	 Conj <c true
 	 , s0 > v >c } ) -> {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (tlen)(v) ==(u)
 	 u = s01 > }}
  *************** Synthesizing Args ei : ti for ************goal
 ##################################################################################
  Synthesizing the 1th argument for Function goal
  Trying Arguments in Scalars 
 esynthesizeScalar for {v:Ty_int | 
 	 Conj <c true
 	 , s0 > v >c }
 
 Enumerating a Scalar Term s0
 
 Type of the Scalar Term {v:Ty_int | true}                                                                                                                                                         
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T972)
(declare-fun |0| () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun sizer () Int)
(declare-fun tlen (T972) Int)
(declare-fun rtree () T972)
(declare-fun sizel () Int)
(declare-fun ltree () T972)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T972)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u190 Int) (var_u189 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (= var_v3 false)
         a!4))))
(assert (not (> s0 s0)))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term _lbv0
 
 Type of the Scalar Term {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }                                                                                                                                                                    
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T978)
(declare-fun |0| () Int)
(declare-fun _lbv0 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun sizer () Int)
(declare-fun tlen (T978) Int)
(declare-fun rtree () T978)
(declare-fun sizel () Int)
(declare-fun ltree () T978)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T978)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u192 Int) (var_u191 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))))))
(assert (not (> s0 _lbv0)))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term _lbv1
 
 Type of the Scalar Term {v:Ty_int | (v) ==((s0) -- (1))}                                                                                                                                                         
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T984)
(declare-fun |0| () Int)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun sizer () Int)
(declare-fun tlen (T984) Int)
(declare-fun rtree () T984)
(declare-fun sizel () Int)
(declare-fun ltree () T984)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T984)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u194 Int) (var_u193 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (= _lbv1 (- s0 1))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))))))
(assert (not (> s0 _lbv1)))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 Enumerating a Scalar Term _lbv2
 
 Type of the Scalar Term {v:Ty_int | (v) ==((_lbv0) -- (1))}                                                                                                                                                         
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T990)
(declare-fun |0| () Int)
(declare-fun _lbv0 () Int)
(declare-fun _lbv2 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun sizer () Int)
(declare-fun tlen (T990) Int)
(declare-fun rtree () T990)
(declare-fun sizel () Int)
(declare-fun ltree () T990)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T990)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u196 Int) (var_u195 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (= _lbv2 (- _lbv0 1))
         (= var_v3 false)
         a!4
         (= _lbv2 (- _lbv0 1))))))
(assert (not (> s0 _lbv2)))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term s
 
 Type of the Scalar Term {var_v0:Ty_int | true}                                                                                                                                                         
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T996)
(declare-fun |0| () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun sizer () Int)
(declare-fun tlen (T996) Int)
(declare-fun rtree () T996)
(declare-fun sizel () Int)
(declare-fun ltree () T996)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T996)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u198 Int) (var_u197 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (= var_v3 false)
         a!4))))
(assert (not (> s0 s)))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term _lbv6
 
 Type of the Scalar Term {v:Ty_int | (v) ==((root) -- (1))}                                                                                                                                                         
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T1002)
(declare-fun |0| () Int)
(declare-fun root () Int)
(declare-fun _lbv6 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun sizer () Int)
(declare-fun tlen (T1002) Int)
(declare-fun rtree () T1002)
(declare-fun sizel () Int)
(declare-fun ltree () T1002)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T1002)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u200 Int) (var_u199 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (= _lbv6 (- root 1))
         (= var_v3 false)
         a!4
         (= _lbv6 (- root 1))))))
(assert (not (> s0 _lbv6)))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term _lbv7
 
 Type of the Scalar Term {v:Ty_int | (v) ==((s01) -- (1))}                                                                                                                                                         
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T1008)
(declare-fun |0| () Int)
(declare-fun s01 () Int)
(declare-fun _lbv7 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun sizer () Int)
(declare-fun tlen (T1008) Int)
(declare-fun rtree () T1008)
(declare-fun sizel () Int)
(declare-fun ltree () T1008)
(declare-fun root () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T1008)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u202 Int) (var_u201 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (= _lbv7 (- s01 1))
         (= var_v3 false)
         a!4
         (= _lbv7 (- s01 1))))))
(assert (not (> s0 _lbv7)))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 Enumerating a Scalar Term _lbv8
 
 Type of the Scalar Term {v:Ty_int | (v) ==((s) -- (1))}                                                                                                                                                         
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T1014)
(declare-fun |0| () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun sizer () Int)
(declare-fun tlen (T1014) Int)
(declare-fun rtree () T1014)
(declare-fun sizel () Int)
(declare-fun ltree () T1014)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T1014)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u204 Int) (var_u203 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (= _lbv8 (- s 1))
         (= var_v3 false)
         a!4
         (= _lbv8 (- s 1))))))
(assert (not (> s0 _lbv8)))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {v:Ty_int | true}                                                                                                                                                         
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T1020)
(declare-fun |0| () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun sizer () Int)
(declare-fun tlen (T1020) Int)
(declare-fun rtree () T1020)
(declare-fun sizel () Int)
(declare-fun ltree () T1020)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T1020)
(declare-fun n () Int)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u206 Int) (var_u205 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (= var_v3 false)
         a!4))))
(assert (not (> s0 n)))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term _lbv9
 
 Type of the Scalar Term {v:Ty_int | (v) ==((sizer) -- (1))}                                                                                                                                                         
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T1026)
(declare-fun |0| () Int)
(declare-fun sizer () Int)
(declare-fun _lbv9 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun tlen (T1026) Int)
(declare-fun rtree () T1026)
(declare-fun sizel () Int)
(declare-fun ltree () T1026)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T1026)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u208 Int) (var_u207 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (= _lbv9 (- sizer 1))
         (= var_v3 false)
         a!4
         (= _lbv9 (- sizer 1))))))
(assert (not (> s0 _lbv9)))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term _lbv10
 
 Type of the Scalar Term {v:Ty_int | (v) ==((sizel) -- (1))}                                                                                                                                                         
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T1032)
(declare-fun |0| () Int)
(declare-fun sizel () Int)
(declare-fun _lbv10 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun sizer () Int)
(declare-fun tlen (T1032) Int)
(declare-fun rtree () T1032)
(declare-fun ltree () T1032)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T1032)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u210 Int) (var_u209 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (= _lbv10 (- sizel 1))
         (= var_v3 false)
         a!4
         (= _lbv10 (- sizel 1))))))
(assert (not (> s0 _lbv10)))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term s01
 
 Type of the Scalar Term {v:Ty_int | 
 	 Conj <c true
 	 , s0 > v >c }
 ################################################
 Skipping Variable s01 As this a  Formal Parameter to the current function Call
 ################################################
 
 Enumerating a Scalar Term root
 
 Type of the Scalar Term {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }                                                                                                                                                                    
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T1038)
(declare-fun |0| () Int)
(declare-fun root () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun sizer () Int)
(declare-fun tlen (T1038) Int)
(declare-fun rtree () T1038)
(declare-fun sizel () Int)
(declare-fun ltree () T1038)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T1038)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u212 Int) (var_u211 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (or (> root |0|) (= root |0|))
         (= var_v3 false)
         a!4
         (or (> root |0|) (= root |0|))))))
(assert (not (> s0 root)))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term sizel
 
 Type of the Scalar Term {v:Ty_int | true}                                                                                                                                                         
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T1044)
(declare-fun |0| () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun sizer () Int)
(declare-fun tlen (T1044) Int)
(declare-fun rtree () T1044)
(declare-fun sizel () Int)
(declare-fun ltree () T1044)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T1044)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u214 Int) (var_u213 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (= var_v3 false)
         a!4))))
(assert (not (> s0 sizel)))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term sizer
 
 Type of the Scalar Term {v:Ty_int | true}                                                                                                                                                         
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T1050)
(declare-fun |0| () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun sizer () Int)
(declare-fun tlen (T1050) Int)
(declare-fun rtree () T1050)
(declare-fun sizel () Int)
(declare-fun ltree () T1050)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T1050)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u216 Int) (var_u215 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (= var_v3 false)
         a!4))))
(assert (not (> s0 sizer)))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 
 FaileD the subtype check T_vi <: T_goal
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  , 
 subs, 
 int_gen
 ############################################################
  Synthesizing the Function application Pure Component subs
 ############################################################
  *************** Trying Arrow Component ************subs :  Arrow ( ( n : {v:Ty_int | true} ) -> {v:Ty_int | (v) ==((n) -- (1))}
  *************** Synthesizing Args ei : ti for ************subs
 ##################################################################################
  Synthesizing the 1th argument for Function subs
  Trying Arguments in Scalars 
 esynthesizeScalar for {v:Ty_int | true}
 
 Enumerating a Scalar Term s0
 
 Type of the Scalar Term {v:Ty_int | true}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term _lbv0
 
 Type of the Scalar Term {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 Enumerating a Scalar Term _lbv1
 
 Type of the Scalar Term {v:Ty_int | (v) ==((s0) -- (1))}
 ################################################
 Skipping Variable _lbv1 As Outer Function Call is subs
 
 Enumerating a Scalar Term _lbv2
 
 Type of the Scalar Term {v:Ty_int | (v) ==((_lbv0) -- (1))}
 ################################################
 Skipping Variable _lbv2 As Outer Function Call is subs
 
 Enumerating a Scalar Term s
 
 Type of the Scalar Term {var_v0:Ty_int | true}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term _lbv6
 
 Type of the Scalar Term {v:Ty_int | (v) ==((root) -- (1))}
 ################################################
 Skipping Variable _lbv6 As Outer Function Call is subs
 
 Enumerating a Scalar Term _lbv7
 
 Type of the Scalar Term {v:Ty_int | (v) ==((s01) -- (1))}
 ################################################
 Skipping Variable _lbv7 As Outer Function Call is subs
 
 Enumerating a Scalar Term _lbv8
 
 Type of the Scalar Term {v:Ty_int | (v) ==((s) -- (1))}
 ################################################
 Skipping Variable _lbv8 As Outer Function Call is subs
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {v:Ty_int | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 ################################################
 
 Enumerating a Scalar Term _lbv9
 
 Type of the Scalar Term {v:Ty_int | (v) ==((sizer) -- (1))}
 ################################################
 Skipping Variable _lbv9 As Outer Function Call is subs
 
 Enumerating a Scalar Term _lbv10
 
 Type of the Scalar Term {v:Ty_int | (v) ==((sizel) -- (1))}
 ################################################
 Skipping Variable _lbv10 As Outer Function Call is subs
 
 Enumerating a Scalar Term s01
 
 Type of the Scalar Term {v:Ty_int | 
 	 Conj <c true
 	 , s0 > v >c }
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term root
 
 Type of the Scalar Term {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term sizel
 
 Type of the Scalar Term {v:Ty_int | true}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term sizer
 
 Type of the Scalar Term {v:Ty_int | true}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>> 1th Args option for subs : sizer
 >>>>>>>>>>>>>>>>>>> 1th Args option for subs : sizel
 >>>>>>>>>>>>>>>>>>> 1th Args option for subs : root
 >>>>>>>>>>>>>>>>>>> 1th Args option for subs : s01
 >>>>>>>>>>>>>>>>>>> 1th Args option for subs : s
 >>>>>>>>>>>>>>>>>>> 1th Args option for subs : apply int_gen  (, dummy )
 >>>>>>>>>>>>>>>>>>> 1th Args option for subs : s0
 TEST Overall List : List of Args for subs
 EI sizer
 EI sizel
 EI root
 EI s01
 EI s
 EI apply int_gen  (, dummy )
 EI s0
 ##################################################################################
  *************** Successfully Synthesized Args ei Forall i 
 Ith Argument Options for subs
 EI sizer
 EI sizel
 EI root
 EI s01
 EI s
 EI apply int_gen  (, dummy )
 EI s0
 # of Possible Argument Options for subs 7
 Possible Arg Options 
 EI sizer
 Possible Arg Options 
 EI sizel
 Possible Arg Options 
 EI root
 Possible Arg Options 
 EI s01
 Possible Arg Options 
 EI s
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 Possible Arg Options 
 EI s0
 Apply Single Argument Case : f (ei) Case subs
  Case : f (ei) Case subs sizer
 Finding Already seen tree for apply subs  (, sizer )
 Found _lbv9
  Case : f (ei) Case subs sizel
 Finding Already seen tree for apply subs  (, sizel )
 Found _lbv10
  Case : f (ei) Case subs root
 Finding Already seen tree for apply subs  (, root )
 Found _lbv6
  Case : f (ei) Case subs s01
 Finding Already seen tree for apply subs  (, s01 )
 Found _lbv7
  Case : f (ei) Case subs s
 Finding Already seen tree for apply subs  (, s )
 Found _lbv8
  Case : f (ei) Case subs _lbv0
 Finding Already seen tree for apply subs  (, _lbv0 )
 Found _lbv2
  Case : f (ei) Case subs s0
 Finding Already seen tree for apply subs  (, s0 )
 Found _lbv1
 >>>>>>>>>>>>>>>>>>> 1th Args option for goal : apply subs  (, s01 )
 >>>>>>>>>>>>>>>>>>> 1th Args option for goal : apply subs  (, s0 )
 >>>>>>>>>>>>>>>>>>> 1th Args option for goal : apply subs  (, s0 )
 >>>>>>>>>>>>>>>>>>> 1th Args option for goal : apply subs  (, apply int_gen  (, dummy ) )
 >>>>>>>>>>>>>>>>>>> 1th Args option for goal : apply subs  (, s )
 >>>>>>>>>>>>>>>>>>> 1th Args option for goal : apply subs  (, s01 )
 >>>>>>>>>>>>>>>>>>> 1th Args option for goal : apply subs  (, root )
 >>>>>>>>>>>>>>>>>>> 1th Args option for goal : apply subs  (, sizel )
 >>>>>>>>>>>>>>>>>>> 1th Args option for goal : apply subs  (, sizer )
 TEST Overall List : List of Args for goal
 EI apply subs  (, s01 )
 EI apply subs  (, s0 )
 EI apply subs  (, s0 )
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI apply subs  (, s )
 EI apply subs  (, s01 )
 EI apply subs  (, root )
 EI apply subs  (, sizel )
 EI apply subs  (, sizer )
 ##################################################################################
  *************** Successfully Synthesized Args ei Forall i 
 Ith Argument Options for goal
 EI apply subs  (, s01 )
 EI apply subs  (, s0 )
 EI apply subs  (, s0 )
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI apply subs  (, s )
 EI apply subs  (, s01 )
 EI apply subs  (, root )
 EI apply subs  (, sizel )
 EI apply subs  (, sizer )
 # of Possible Argument Options for goal 9
 Possible Arg Options 
 EI apply subs  (, s01 )
 Possible Arg Options 
 EI apply subs  (, s0 )
 Possible Arg Options 
 EI apply subs  (, s0 )
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 Possible Arg Options 
 EI apply subs  (, s )
 Possible Arg Options 
 EI apply subs  (, s01 )
 Possible Arg Options 
 EI apply subs  (, root )
 Possible Arg Options 
 EI apply subs  (, sizel )
 Possible Arg Options 
 EI apply subs  (, sizer )
 Apply Single Argument Case : f (ei) Case goal
  Case : f (ei) Case goal _lbv7
 Finding Already seen tree for apply goal  (, _lbv7 )
 Typechecking the Term apply goal  (, _lbv7 )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv7 :: {v:Ty_int | (v) ==((s01) -- (1))} | (_lbv7) ==((s01) -- (1))
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (tlen)(v) ==(u)
 	 u = _lbv7 > }}                                                                                                                                                                
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T1063)
(declare-fun |0| () Int)
(declare-fun _lbv7 () Int)
(declare-fun tlen (T1063) Int)
(declare-fun v () T1063)
(declare-fun s01 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun sizer () Int)
(declare-fun rtree () T1063)
(declare-fun sizel () Int)
(declare-fun ltree () T1063)
(declare-fun root () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T1063)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u220 Int) (var_u219 Int) (var_u218 Int) (var_u217 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (> s0 s01)
         (=> (= (tlen v) var_u219) (= var_u219 _lbv7))
         (= var_v3 false)
         a!4
         (= _lbv7 (- s01 1))
         (=> (= (tlen v) var_u220) (= var_u220 _lbv7))))))
(assert (not (forall ((var_u221 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply goal  (, _lbv7 )
  Case : f (ei) Case goal _lbv1
 Finding Already seen tree for apply goal  (, _lbv1 )
 Typechecking the Term apply goal  (, _lbv1 )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (tlen)(v) ==(u)
 	 u = _lbv1 > }}                                                                                                                                                                
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T1069)
(declare-fun |0| () Int)
(declare-fun _lbv1 () Int)
(declare-fun tlen (T1069) Int)
(declare-fun v () T1069)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T1069)
(declare-fun sizel () Int)
(declare-fun ltree () T1069)
(declare-fun root () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T1069)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u225 Int) (var_u224 Int) (var_u223 Int) (var_u222 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (> s0 s01)
         (=> (= (tlen v) var_u224) (= var_u224 _lbv1))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (=> (= (tlen v) var_u225) (= var_u225 _lbv1))))))
(assert (not (forall ((var_u226 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply goal  (, _lbv1 )
  Case : f (ei) Case goal _lbv1
 Finding Already seen tree for apply goal  (, _lbv1 )
 Typechecking the Term apply goal  (, _lbv1 )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (tlen)(v) ==(u)
 	 u = _lbv1 > }}                                                                                                                                                                
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T1075)
(declare-fun |0| () Int)
(declare-fun _lbv1 () Int)
(declare-fun tlen (T1075) Int)
(declare-fun v () T1075)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T1075)
(declare-fun sizel () Int)
(declare-fun ltree () T1075)
(declare-fun root () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T1075)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u230 Int) (var_u229 Int) (var_u228 Int) (var_u227 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (> s0 s01)
         (=> (= (tlen v) var_u229) (= var_u229 _lbv1))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (=> (= (tlen v) var_u230) (= var_u230 _lbv1))))))
(assert (not (forall ((var_u231 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply goal  (, _lbv1 )
  Case : f (ei) Case goal _lbv2
 Finding Already seen tree for apply goal  (, _lbv2 )
 Typechecking the Term apply goal  (, _lbv2 )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv2 :: {v:Ty_int | (v) ==((_lbv0) -- (1))} | (_lbv2) ==((_lbv0) -- (1))
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (tlen)(v) ==(u)
 	 u = _lbv2 > }}                                                                                                                                                                
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T1081)
(declare-fun |0| () Int)
(declare-fun _lbv2 () Int)
(declare-fun tlen (T1081) Int)
(declare-fun v () T1081)
(declare-fun _lbv0 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T1081)
(declare-fun sizel () Int)
(declare-fun ltree () T1081)
(declare-fun root () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T1081)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u235 Int) (var_u234 Int) (var_u233 Int) (var_u232 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (> s0 s01)
         (=> (= (tlen v) var_u234) (= var_u234 _lbv2))
         (= var_v3 false)
         a!4
         (= _lbv2 (- _lbv0 1))
         (=> (= (tlen v) var_u235) (= var_u235 _lbv2))))))
(assert (not (forall ((var_u236 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply goal  (, _lbv2 )
  Case : f (ei) Case goal _lbv8
 Finding Already seen tree for apply goal  (, _lbv8 )
 Typechecking the Term apply goal  (, _lbv8 )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv8 :: {v:Ty_int | (v) ==((s) -- (1))} | (_lbv8) ==((s) -- (1))
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (tlen)(v) ==(u)
 	 u = _lbv8 > }}                                                                                                                                                                
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T1087)
(declare-fun |0| () Int)
(declare-fun _lbv8 () Int)
(declare-fun tlen (T1087) Int)
(declare-fun v () T1087)
(declare-fun s () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T1087)
(declare-fun sizel () Int)
(declare-fun ltree () T1087)
(declare-fun root () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T1087)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u240 Int) (var_u239 Int) (var_u238 Int) (var_u237 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (> s0 s01)
         (=> (= (tlen v) var_u239) (= var_u239 _lbv8))
         (= var_v3 false)
         a!4
         (= _lbv8 (- s 1))
         (=> (= (tlen v) var_u240) (= var_u240 _lbv8))))))
(assert (not (forall ((var_u241 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply goal  (, _lbv8 )
  Case : f (ei) Case goal _lbv7
 Finding Already seen tree for apply goal  (, _lbv7 )
 Typechecking the Term apply goal  (, _lbv7 )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv7 :: {v:Ty_int | (v) ==((s01) -- (1))} | (_lbv7) ==((s01) -- (1))
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (tlen)(v) ==(u)
 	 u = _lbv7 > }}                                                                                                                                                                
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T1093)
(declare-fun |0| () Int)
(declare-fun _lbv7 () Int)
(declare-fun tlen (T1093) Int)
(declare-fun v () T1093)
(declare-fun s01 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun sizer () Int)
(declare-fun rtree () T1093)
(declare-fun sizel () Int)
(declare-fun ltree () T1093)
(declare-fun root () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T1093)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u245 Int) (var_u244 Int) (var_u243 Int) (var_u242 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (> s0 s01)
         (=> (= (tlen v) var_u244) (= var_u244 _lbv7))
         (= var_v3 false)
         a!4
         (= _lbv7 (- s01 1))
         (=> (= (tlen v) var_u245) (= var_u245 _lbv7))))))
(assert (not (forall ((var_u246 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply goal  (, _lbv7 )
  Case : f (ei) Case goal _lbv6
 Finding Already seen tree for apply goal  (, _lbv6 )
 Typechecking the Term apply goal  (, _lbv6 )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv6 :: {v:Ty_int | (v) ==((root) -- (1))} | (_lbv6) ==((root) -- (1))
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (tlen)(v) ==(u)
 	 u = _lbv6 > }}                                                                                                                                                                
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T1099)
(declare-fun |0| () Int)
(declare-fun _lbv6 () Int)
(declare-fun tlen (T1099) Int)
(declare-fun v () T1099)
(declare-fun root () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T1099)
(declare-fun sizel () Int)
(declare-fun ltree () T1099)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T1099)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u250 Int) (var_u249 Int) (var_u248 Int) (var_u247 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (> s0 s01)
         (=> (= (tlen v) var_u249) (= var_u249 _lbv6))
         (= var_v3 false)
         a!4
         (= _lbv6 (- root 1))
         (=> (= (tlen v) var_u250) (= var_u250 _lbv6))))))
(assert (not (forall ((var_u251 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply goal  (, _lbv6 )
  Case : f (ei) Case goal _lbv10
 Finding Already seen tree for apply goal  (, _lbv10 )
 Typechecking the Term apply goal  (, _lbv10 )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv10 :: {v:Ty_int | (v) ==((sizel) -- (1))} | (_lbv10) ==((sizel) -- (1))
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (tlen)(v) ==(u)
 	 u = _lbv10 > }}                                                                                                                                                                
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T1105)
(declare-fun |0| () Int)
(declare-fun _lbv10 () Int)
(declare-fun tlen (T1105) Int)
(declare-fun v () T1105)
(declare-fun sizel () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T1105)
(declare-fun ltree () T1105)
(declare-fun root () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T1105)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u255 Int) (var_u254 Int) (var_u253 Int) (var_u252 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (> s0 s01)
         (=> (= (tlen v) var_u254) (= var_u254 _lbv10))
         (= var_v3 false)
         a!4
         (= _lbv10 (- sizel 1))
         (=> (= (tlen v) var_u255) (= var_u255 _lbv10))))))
(assert (not (forall ((var_u256 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply goal  (, _lbv10 )
  Case : f (ei) Case goal _lbv9
 Finding Already seen tree for apply goal  (, _lbv9 )
 Typechecking the Term apply goal  (, _lbv9 )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv9 :: {v:Ty_int | (v) ==((sizer) -- (1))} | (_lbv9) ==((sizer) -- (1))
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (tlen)(v) ==(u)
 	 u = _lbv9 > }}                                                                                                                                                                
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T1111)
(declare-fun |0| () Int)
(declare-fun _lbv9 () Int)
(declare-fun tlen (T1111) Int)
(declare-fun v () T1111)
(declare-fun sizer () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun rtree () T1111)
(declare-fun sizel () Int)
(declare-fun ltree () T1111)
(declare-fun root () Int)
(declare-fun _lbv10 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T1111)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u260 Int) (var_u259 Int) (var_u258 Int) (var_u257 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (> s0 s01)
         (=> (= (tlen v) var_u259) (= var_u259 _lbv9))
         (= var_v3 false)
         a!4
         (= _lbv9 (- sizer 1))
         (=> (= (tlen v) var_u260) (= var_u260 _lbv9))))))
(assert (not (forall ((var_u261 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply goal  (, _lbv9 )
  ###################################################
  The Choice of Function goal Was Ill Fated Try Next Choice of function
 ############################################################
  Synthesizing the Function application Pure Component node
 ############################################################
  *************** Trying Arrow Component ************node :  Arrow ( ( root : {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } ) ->  Arrow ( ( sizel : {v:Ty_int | true} ) ->  Arrow ( ( ltree : {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} ) ->  Arrow ( ( sizer : {v:Ty_int | true} ) ->  Arrow ( ( rtree : {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} ) -> {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((sizel) + (1))
 	 (tlen)(v) ==(u) > }}
  *************** Synthesizing Args ei : ti for ************node
 ##################################################################################
  Synthesizing the 1th argument for Function node
  Trying Arguments in Scalars 
 esynthesizeScalar for {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }
 
 Enumerating a Scalar Term s0
 
 Type of the Scalar Term {v:Ty_int | true}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T1117)
(declare-fun |0| () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun sizer () Int)
(declare-fun tlen (T1117) Int)
(declare-fun rtree () T1117)
(declare-fun sizel () Int)
(declare-fun ltree () T1117)
(declare-fun root () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T1117)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u263 Int) (var_u262 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (> s0 s01)
         (= var_v3 false)
         a!4))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (not (or (> s0 |0|) (= s0 |0|))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term _lbv0
 
 Type of the Scalar Term {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }                                                                                                                                                                          
# of Final Z3 expressions 20
 Final solver 
 (declare-sort T1123)
(declare-fun |0| () Int)
(declare-fun _lbv0 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun sizer () Int)
(declare-fun tlen (T1123) Int)
(declare-fun rtree () T1123)
(declare-fun sizel () Int)
(declare-fun ltree () T1123)
(declare-fun root () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T1123)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u265 Int) (var_u264 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (> s0 s01)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (not (or (> _lbv0 |0|) (= _lbv0 |0|))))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 Enumerating a Scalar Term _lbv1
 
 Type of the Scalar Term {v:Ty_int | (v) ==((s0) -- (1))}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T1129)
(declare-fun |0| () Int)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun sizer () Int)
(declare-fun tlen (T1129) Int)
(declare-fun rtree () T1129)
(declare-fun sizel () Int)
(declare-fun ltree () T1129)
(declare-fun root () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T1129)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u267 Int) (var_u266 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (> s0 s01)
         (= _lbv1 (- s0 1))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (not (or (> _lbv1 |0|) (= _lbv1 |0|))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term _lbv2
 
 Type of the Scalar Term {v:Ty_int | (v) ==((_lbv0) -- (1))}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T1135)
(declare-fun |0| () Int)
(declare-fun _lbv0 () Int)
(declare-fun _lbv2 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun sizer () Int)
(declare-fun tlen (T1135) Int)
(declare-fun rtree () T1135)
(declare-fun sizel () Int)
(declare-fun ltree () T1135)
(declare-fun root () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T1135)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u269 Int) (var_u268 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (> s0 s01)
         (= _lbv2 (- _lbv0 1))
         (= var_v3 false)
         a!4
         (= _lbv2 (- _lbv0 1))))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (not (or (> _lbv2 |0|) (= _lbv2 |0|))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term s
 
 Type of the Scalar Term {var_v0:Ty_int | true}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T1141)
(declare-fun |0| () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun sizer () Int)
(declare-fun tlen (T1141) Int)
(declare-fun rtree () T1141)
(declare-fun sizel () Int)
(declare-fun ltree () T1141)
(declare-fun root () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T1141)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u271 Int) (var_u270 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (> s0 s01)
         (= var_v3 false)
         a!4))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (not (or (> s |0|) (= s |0|))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term _lbv6
 
 Type of the Scalar Term {v:Ty_int | (v) ==((root) -- (1))}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T1147)
(declare-fun |0| () Int)
(declare-fun root () Int)
(declare-fun _lbv6 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun sizer () Int)
(declare-fun tlen (T1147) Int)
(declare-fun rtree () T1147)
(declare-fun sizel () Int)
(declare-fun ltree () T1147)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T1147)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u273 Int) (var_u272 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (> s0 s01)
         (= _lbv6 (- root 1))
         (= var_v3 false)
         a!4
         (= _lbv6 (- root 1))))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (not (or (> _lbv6 |0|) (= _lbv6 |0|))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term _lbv7
 
 Type of the Scalar Term {v:Ty_int | (v) ==((s01) -- (1))}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T1153)
(declare-fun |0| () Int)
(declare-fun s01 () Int)
(declare-fun _lbv7 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun sizer () Int)
(declare-fun tlen (T1153) Int)
(declare-fun rtree () T1153)
(declare-fun sizel () Int)
(declare-fun ltree () T1153)
(declare-fun root () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T1153)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u275 Int) (var_u274 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (> s0 s01)
         (= _lbv7 (- s01 1))
         (= var_v3 false)
         a!4
         (= _lbv7 (- s01 1))))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (not (or (> _lbv7 |0|) (= _lbv7 |0|))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term _lbv8
 
 Type of the Scalar Term {v:Ty_int | (v) ==((s) -- (1))}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T1159)
(declare-fun |0| () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun sizer () Int)
(declare-fun tlen (T1159) Int)
(declare-fun rtree () T1159)
(declare-fun sizel () Int)
(declare-fun ltree () T1159)
(declare-fun root () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T1159)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u277 Int) (var_u276 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (> s0 s01)
         (= _lbv8 (- s 1))
         (= var_v3 false)
         a!4
         (= _lbv8 (- s 1))))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (not (or (> _lbv8 |0|) (= _lbv8 |0|))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term _lbv9
 
 Type of the Scalar Term {v:Ty_int | (v) ==((sizer) -- (1))}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T1165)
(declare-fun |0| () Int)
(declare-fun sizer () Int)
(declare-fun _lbv9 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun tlen (T1165) Int)
(declare-fun rtree () T1165)
(declare-fun sizel () Int)
(declare-fun ltree () T1165)
(declare-fun root () Int)
(declare-fun _lbv10 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T1165)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u279 Int) (var_u278 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv10 (- sizel 1))
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (> s0 s01)
         (= _lbv9 (- sizer 1))
         (= var_v3 false)
         a!4
         (= _lbv9 (- sizer 1))))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (not (or (> _lbv9 |0|) (= _lbv9 |0|))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term _lbv10
 
 Type of the Scalar Term {v:Ty_int | (v) ==((sizel) -- (1))}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T1171)
(declare-fun |0| () Int)
(declare-fun sizel () Int)
(declare-fun _lbv10 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun sizer () Int)
(declare-fun tlen (T1171) Int)
(declare-fun rtree () T1171)
(declare-fun ltree () T1171)
(declare-fun root () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T1171)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u281 Int) (var_u280 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (> s0 s01)
         (= _lbv10 (- sizel 1))
         (= var_v3 false)
         a!4
         (= _lbv10 (- sizel 1))))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (not (or (> _lbv10 |0|) (= _lbv10 |0|))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term root
 
 Type of the Scalar Term {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }
 ################################################
 Skipping Variable root As this a  Formal Parameter to the current function Call
 ################################################
 
 Enumerating a Scalar Term sizel
 
 Type of the Scalar Term {v:Ty_int | true}
 ################################################
 Skipping Variable sizel As this a  Formal Parameter to the current function Call
 ################################################
 
 Enumerating a Scalar Term sizer
 
 Type of the Scalar Term {v:Ty_int | true}
 ################################################
 Skipping Variable sizer As this a  Formal Parameter to the current function Call
 ################################################
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {v:Ty_int | true}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T1177)
(declare-fun |0| () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun sizer () Int)
(declare-fun tlen (T1177) Int)
(declare-fun rtree () T1177)
(declare-fun sizel () Int)
(declare-fun ltree () T1177)
(declare-fun root () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T1177)
(declare-fun n () Int)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u283 Int) (var_u282 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (> s0 s01)
         (= var_v3 false)
         a!4))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (not (or (> n |0|) (= n |0|))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term s01
 
 Type of the Scalar Term {v:Ty_int | 
 	 Conj <c true
 	 , s0 > v >c }                                                                                                                                                                    
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T1183)
(declare-fun |0| () Int)
(declare-fun s01 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun sizer () Int)
(declare-fun tlen (T1183) Int)
(declare-fun rtree () T1183)
(declare-fun sizel () Int)
(declare-fun ltree () T1183)
(declare-fun root () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T1183)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u285 Int) (var_u284 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (> s0 s01)
         (= var_v3 false)
         a!4
         (> s0 s01)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (not (or (> s01 |0|) (= s01 |0|))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 
 FaileD the subtype check T_vi <: T_goal
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  , 
 subs, 
 int_gen
 ############################################################
  Synthesizing the Function application Pure Component subs
 ############################################################
  *************** Trying Arrow Component ************subs :  Arrow ( ( n : {v:Ty_int | true} ) -> {v:Ty_int | (v) ==((n) -- (1))}
  *************** Synthesizing Args ei : ti for ************subs
 ##################################################################################
  Synthesizing the 1th argument for Function subs
  Trying Arguments in Scalars 
 esynthesizeScalar for {v:Ty_int | true}
 
 Enumerating a Scalar Term s0
 
 Type of the Scalar Term {v:Ty_int | true}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term _lbv0
 
 Type of the Scalar Term {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 Enumerating a Scalar Term _lbv1
 
 Type of the Scalar Term {v:Ty_int | (v) ==((s0) -- (1))}
 ################################################
 Skipping Variable _lbv1 As Outer Function Call is subs
 
 Enumerating a Scalar Term _lbv2
 
 Type of the Scalar Term {v:Ty_int | (v) ==((_lbv0) -- (1))}
 ################################################
 Skipping Variable _lbv2 As Outer Function Call is subs
 
 Enumerating a Scalar Term s
 
 Type of the Scalar Term {var_v0:Ty_int | true}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term _lbv6
 
 Type of the Scalar Term {v:Ty_int | (v) ==((root) -- (1))}
 ################################################
 Skipping Variable _lbv6 As Outer Function Call is subs
 
 Enumerating a Scalar Term _lbv7
 
 Type of the Scalar Term {v:Ty_int | (v) ==((s01) -- (1))}
 ################################################
 Skipping Variable _lbv7 As Outer Function Call is subs
 
 Enumerating a Scalar Term _lbv8
 
 Type of the Scalar Term {v:Ty_int | (v) ==((s) -- (1))}
 ################################################
 Skipping Variable _lbv8 As Outer Function Call is subs
 
 Enumerating a Scalar Term _lbv9
 
 Type of the Scalar Term {v:Ty_int | (v) ==((sizer) -- (1))}
 ################################################
 Skipping Variable _lbv9 As Outer Function Call is subs
 
 Enumerating a Scalar Term _lbv10
 
 Type of the Scalar Term {v:Ty_int | (v) ==((sizel) -- (1))}
 ################################################
 Skipping Variable _lbv10 As Outer Function Call is subs
 
 Enumerating a Scalar Term root
 
 Type of the Scalar Term {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term sizel
 
 Type of the Scalar Term {v:Ty_int | true}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term sizer
 
 Type of the Scalar Term {v:Ty_int | true}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {v:Ty_int | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 ################################################
 
 Enumerating a Scalar Term s01
 
 Type of the Scalar Term {v:Ty_int | 
 	 Conj <c true
 	 , s0 > v >c }
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>> 1th Args option for subs : s01
 >>>>>>>>>>>>>>>>>>> 1th Args option for subs : sizer
 >>>>>>>>>>>>>>>>>>> 1th Args option for subs : sizel
 >>>>>>>>>>>>>>>>>>> 1th Args option for subs : root
 >>>>>>>>>>>>>>>>>>> 1th Args option for subs : s
 >>>>>>>>>>>>>>>>>>> 1th Args option for subs : apply int_gen  (, dummy )
 >>>>>>>>>>>>>>>>>>> 1th Args option for subs : s0
 TEST Overall List : List of Args for subs
 EI s01
 EI sizer
 EI sizel
 EI root
 EI s
 EI apply int_gen  (, dummy )
 EI s0
 ##################################################################################
  *************** Successfully Synthesized Args ei Forall i 
 Ith Argument Options for subs
 EI s01
 EI sizer
 EI sizel
 EI root
 EI s
 EI apply int_gen  (, dummy )
 EI s0
 # of Possible Argument Options for subs 7
 Possible Arg Options 
 EI s01
 Possible Arg Options 
 EI sizer
 Possible Arg Options 
 EI sizel
 Possible Arg Options 
 EI root
 Possible Arg Options 
 EI s
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 Possible Arg Options 
 EI s0
 Apply Single Argument Case : f (ei) Case subs
  Case : f (ei) Case subs s01
 Finding Already seen tree for apply subs  (, s01 )
 Found _lbv7
  Case : f (ei) Case subs sizer
 Finding Already seen tree for apply subs  (, sizer )
 Found _lbv9
  Case : f (ei) Case subs sizel
 Finding Already seen tree for apply subs  (, sizel )
 Found _lbv10
  Case : f (ei) Case subs root
 Finding Already seen tree for apply subs  (, root )
 Found _lbv6
  Case : f (ei) Case subs s
 Finding Already seen tree for apply subs  (, s )
 Found _lbv8
  Case : f (ei) Case subs _lbv0
 Finding Already seen tree for apply subs  (, _lbv0 )
 Found _lbv2
  Case : f (ei) Case subs s0
 Finding Already seen tree for apply subs  (, s0 )
 Found _lbv1
 >>>>>>>>>>>>>>>>>>> 1th Args option for node : apply int_gen  (, dummy )
 >>>>>>>>>>>>>>>>>>> 1th Args option for node : apply subs  (, s0 )
 >>>>>>>>>>>>>>>>>>> 1th Args option for node : apply subs  (, apply int_gen  (, dummy ) )
 >>>>>>>>>>>>>>>>>>> 1th Args option for node : apply subs  (, s )
 >>>>>>>>>>>>>>>>>>> 1th Args option for node : apply subs  (, root )
 >>>>>>>>>>>>>>>>>>> 1th Args option for node : apply subs  (, sizel )
 >>>>>>>>>>>>>>>>>>> 1th Args option for node : apply subs  (, sizer )
 >>>>>>>>>>>>>>>>>>> 1th Args option for node : apply subs  (, s01 )
 TEST Overall List : List of Args for node
 EI apply int_gen  (, dummy )
 EI apply subs  (, s0 )
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI apply subs  (, s )
 EI apply subs  (, root )
 EI apply subs  (, sizel )
 EI apply subs  (, sizer )
 EI apply subs  (, s01 )
 ##################################################################################
  Synthesizing the 2th argument for Function node
  Trying Arguments in Scalars 
 esynthesizeScalar for {v:Ty_int | true}
 
 Enumerating a Scalar Term s0
 
 Type of the Scalar Term {v:Ty_int | true}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term _lbv0
 
 Type of the Scalar Term {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 Enumerating a Scalar Term _lbv1
 
 Type of the Scalar Term {v:Ty_int | (v) ==((s0) -- (1))}
 ################################################
 Skipping Variable _lbv1 As Outer Function Call is subs
 
 Enumerating a Scalar Term _lbv2
 
 Type of the Scalar Term {v:Ty_int | (v) ==((_lbv0) -- (1))}
 ################################################
 Skipping Variable _lbv2 As Outer Function Call is subs
 
 Enumerating a Scalar Term s
 
 Type of the Scalar Term {var_v0:Ty_int | true}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term _lbv6
 
 Type of the Scalar Term {v:Ty_int | (v) ==((root) -- (1))}
 ################################################
 Skipping Variable _lbv6 As Outer Function Call is subs
 
 Enumerating a Scalar Term _lbv7
 
 Type of the Scalar Term {v:Ty_int | (v) ==((s01) -- (1))}
 ################################################
 Skipping Variable _lbv7 As Outer Function Call is subs
 
 Enumerating a Scalar Term _lbv8
 
 Type of the Scalar Term {v:Ty_int | (v) ==((s) -- (1))}
 ################################################
 Skipping Variable _lbv8 As Outer Function Call is subs
 
 Enumerating a Scalar Term _lbv9
 
 Type of the Scalar Term {v:Ty_int | (v) ==((sizer) -- (1))}
 ################################################
 Skipping Variable _lbv9 As Outer Function Call is subs
 
 Enumerating a Scalar Term _lbv10
 
 Type of the Scalar Term {v:Ty_int | (v) ==((sizel) -- (1))}
 ################################################
 Skipping Variable _lbv10 As Outer Function Call is subs
 
 Enumerating a Scalar Term sizel
 
 Type of the Scalar Term {v:Ty_int | true}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term sizer
 
 Type of the Scalar Term {v:Ty_int | true}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term s01
 
 Type of the Scalar Term {v:Ty_int | 
 	 Conj <c true
 	 , s0 > v >c }
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {v:Ty_int | true}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term root
 
 Type of the Scalar Term {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  , 
 subs, 
 int_gen
 ############################################################
  Synthesizing the Function application Pure Component subs
 ############################################################
 ############################################################
  Synthesizing the Function application Pure Component int_gen
 ############################################################
  *************** Trying Arrow Component ************int_gen :  Arrow ( ( d : {var_v1:Ty_unit | true} ) -> {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }
  *************** Synthesizing Args ei : ti for ************int_gen
 ##################################################################################
  Synthesizing the 1th argument for Function int_gen
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v1:Ty_unit | true}
 
 Enumerating a Scalar Term dummy
 
 Type of the Scalar Term {v:Ty_unit | true}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term d
 
 Type of the Scalar Term {var_v1:Ty_unit | true}
 ################################################
 Skipping Variable d As this a  Formal Parameter to the current function Call
 ################################################
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>> 1th Args option for int_gen : dummy
 TEST Overall List : List of Args for int_gen
 EI dummy
 ##################################################################################
  *************** Successfully Synthesized Args ei Forall i 
 Ith Argument Options for int_gen
 EI dummy
 # of Possible Argument Options for int_gen 1
 Possible Arg Options 
 EI dummy
 Apply Single Argument Case : f (ei) Case int_gen
  Case : f (ei) Case int_gen dummy
 Finding Already seen tree for apply int_gen  (, dummy )
 Found _lbv0
 >>>>>>>>>>>>>>>>>>> 2th Args option for node : root
 >>>>>>>>>>>>>>>>>>> 2th Args option for node : n
 >>>>>>>>>>>>>>>>>>> 2th Args option for node : s01
 >>>>>>>>>>>>>>>>>>> 2th Args option for node : sizer
 >>>>>>>>>>>>>>>>>>> 2th Args option for node : sizel
 >>>>>>>>>>>>>>>>>>> 2th Args option for node : s
 >>>>>>>>>>>>>>>>>>> 2th Args option for node : apply int_gen  (, dummy )
 >>>>>>>>>>>>>>>>>>> 2th Args option for node : s0
 >>>>>>>>>>>>>>>>>>> 2th Args option for node : apply int_gen  (, dummy )
 TEST Overall List : List of Args for node
 EI root
 EI n
 EI s01
 EI sizer
 EI sizel
 EI s
 EI apply int_gen  (, dummy )
 EI s0
 EI apply int_gen  (, dummy )
 TEST Overall List : List of Args for node
 EI apply int_gen  (, dummy )
 EI apply subs  (, s0 )
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI apply subs  (, s )
 EI apply subs  (, root )
 EI apply subs  (, sizel )
 EI apply subs  (, sizer )
 EI apply subs  (, s01 )
 ##################################################################################
  Synthesizing the 3th argument for Function node
  Trying Arguments in Scalars 
 esynthesizeScalar for {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 
 Enumerating a Scalar Term leaf
 
 Type of the Scalar Term {v:Ty_alphatree | (tlen)(v) ==(0)}                                                                                                                                                    
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T1206)
(declare-fun |0| () Int)
(declare-fun tlen (T1206) Int)
(declare-fun leaf () T1206)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T1206)
(declare-fun sizel () Int)
(declare-fun ltree () T1206)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u287 Int) (var_u286 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen leaf) 0)
         (= var_v3 false)
         a!4
         (= (tlen leaf) 0)))))
(assert (not (forall ((var_u288 Int)) (= (tlen leaf) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term ltree
 
 Type of the Scalar Term {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}                                                                                                                                                    
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T1211)
(declare-fun |0| () Int)
(declare-fun sizel () Int)
(declare-fun tlen (T1211) Int)
(declare-fun ltree () T1211)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T1211)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T1211)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u291 Int) (var_u290 Int) (var_u289 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (= (tlen rtree) sizer)
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= var_v3 false)
         a!4
         (= (tlen ltree) sizel)))))
(assert (not (forall ((var_u292 Int)) (= (tlen ltree) sizel))))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term rtree
 
 Type of the Scalar Term {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }}                                                                                                                                                    
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T1217)
(declare-fun |0| () Int)
(declare-fun sizer () Int)
(declare-fun tlen (T1217) Int)
(declare-fun rtree () T1217)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T1217)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T1217)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u295 Int) (var_u294 Int) (var_u293 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (= (tlen ltree) sizel)
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen rtree) sizer)
         (= var_v3 false)
         a!4
         (= (tlen rtree) sizer)))))
(assert (not (forall ((var_u296 Int)) (= (tlen rtree) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 
 FaileD the subtype check T_vi <: T_goal
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  , 
 goal, 
 node
 ############################################################
  Synthesizing the Function application Pure Component goal
 ############################################################
  *************** Trying Arrow Component ************goal :  Arrow ( ( s01 : {v:Ty_int | 
 	 Conj <c true
 	 , s0 > v >c } ) -> {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (tlen)(v) ==(u)
 	 u = s01 > }}
  *************** Synthesizing Args ei : ti for ************goal
 ##################################################################################
  Synthesizing the 1th argument for Function goal
  Trying Arguments in Scalars 
 esynthesizeScalar for {v:Ty_int | 
 	 Conj <c true
 	 , s0 > v >c }
 
 Enumerating a Scalar Term s0
 
 Type of the Scalar Term {v:Ty_int | true}                                                                                                                                                         
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T1223)
(declare-fun |0| () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun sizer () Int)
(declare-fun tlen (T1223) Int)
(declare-fun rtree () T1223)
(declare-fun sizel () Int)
(declare-fun ltree () T1223)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T1223)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u298 Int) (var_u297 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= var_v3 false)
         a!4))))
(assert (not (> s0 s0)))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term _lbv0
 
 Type of the Scalar Term {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }                                                                                                                                                                    
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T1229)
(declare-fun |0| () Int)
(declare-fun _lbv0 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun sizer () Int)
(declare-fun tlen (T1229) Int)
(declare-fun rtree () T1229)
(declare-fun sizel () Int)
(declare-fun ltree () T1229)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T1229)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u300 Int) (var_u299 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))))))
(assert (not (> s0 _lbv0)))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term _lbv1
 
 Type of the Scalar Term {v:Ty_int | (v) ==((s0) -- (1))}                                                                                                                                                         
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T1235)
(declare-fun |0| () Int)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun sizer () Int)
(declare-fun tlen (T1235) Int)
(declare-fun rtree () T1235)
(declare-fun sizel () Int)
(declare-fun ltree () T1235)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T1235)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u302 Int) (var_u301 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= _lbv1 (- s0 1))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))))))
(assert (not (> s0 _lbv1)))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 Enumerating a Scalar Term _lbv2
 
 Type of the Scalar Term {v:Ty_int | (v) ==((_lbv0) -- (1))}                                                                                                                                                         
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T1241)
(declare-fun |0| () Int)
(declare-fun _lbv0 () Int)
(declare-fun _lbv2 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun sizer () Int)
(declare-fun tlen (T1241) Int)
(declare-fun rtree () T1241)
(declare-fun sizel () Int)
(declare-fun ltree () T1241)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T1241)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u304 Int) (var_u303 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= _lbv2 (- _lbv0 1))
         (= var_v3 false)
         a!4
         (= _lbv2 (- _lbv0 1))))))
(assert (not (> s0 _lbv2)))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term s
 
 Type of the Scalar Term {var_v0:Ty_int | true}                                                                                                                                                         
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T1247)
(declare-fun |0| () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun sizer () Int)
(declare-fun tlen (T1247) Int)
(declare-fun rtree () T1247)
(declare-fun sizel () Int)
(declare-fun ltree () T1247)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T1247)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u306 Int) (var_u305 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= var_v3 false)
         a!4))))
(assert (not (> s0 s)))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term _lbv6
 
 Type of the Scalar Term {v:Ty_int | (v) ==((root) -- (1))}                                                                                                                                                         
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T1253)
(declare-fun |0| () Int)
(declare-fun root () Int)
(declare-fun _lbv6 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun sizer () Int)
(declare-fun tlen (T1253) Int)
(declare-fun rtree () T1253)
(declare-fun sizel () Int)
(declare-fun ltree () T1253)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T1253)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u308 Int) (var_u307 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= _lbv6 (- root 1))
         (= var_v3 false)
         a!4
         (= _lbv6 (- root 1))))))
(assert (not (> s0 _lbv6)))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term _lbv7
 
 Type of the Scalar Term {v:Ty_int | (v) ==((s01) -- (1))}                                                                                                                                                         
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T1259)
(declare-fun |0| () Int)
(declare-fun s01 () Int)
(declare-fun _lbv7 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun sizer () Int)
(declare-fun tlen (T1259) Int)
(declare-fun rtree () T1259)
(declare-fun sizel () Int)
(declare-fun ltree () T1259)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T1259)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u310 Int) (var_u309 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= _lbv7 (- s01 1))
         (= var_v3 false)
         a!4
         (= _lbv7 (- s01 1))))))
(assert (not (> s0 _lbv7)))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 Enumerating a Scalar Term _lbv8
 
 Type of the Scalar Term {v:Ty_int | (v) ==((s) -- (1))}                                                                                                                                                         
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T1265)
(declare-fun |0| () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun sizer () Int)
(declare-fun tlen (T1265) Int)
(declare-fun rtree () T1265)
(declare-fun sizel () Int)
(declare-fun ltree () T1265)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T1265)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u312 Int) (var_u311 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= _lbv8 (- s 1))
         (= var_v3 false)
         a!4
         (= _lbv8 (- s 1))))))
(assert (not (> s0 _lbv8)))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term _lbv9
 
 Type of the Scalar Term {v:Ty_int | (v) ==((sizer) -- (1))}                                                                                                                                                         
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T1271)
(declare-fun |0| () Int)
(declare-fun sizer () Int)
(declare-fun _lbv9 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun tlen (T1271) Int)
(declare-fun rtree () T1271)
(declare-fun sizel () Int)
(declare-fun ltree () T1271)
(declare-fun _lbv10 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T1271)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u314 Int) (var_u313 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv10 (- sizel 1))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= _lbv9 (- sizer 1))
         (= var_v3 false)
         a!4
         (= _lbv9 (- sizer 1))))))
(assert (not (> s0 _lbv9)))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term _lbv10
 
 Type of the Scalar Term {v:Ty_int | (v) ==((sizel) -- (1))}                                                                                                                                                         
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T1277)
(declare-fun |0| () Int)
(declare-fun sizel () Int)
(declare-fun _lbv10 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun sizer () Int)
(declare-fun tlen (T1277) Int)
(declare-fun rtree () T1277)
(declare-fun ltree () T1277)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T1277)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u316 Int) (var_u315 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= _lbv10 (- sizel 1))
         (= var_v3 false)
         a!4
         (= _lbv10 (- sizel 1))))))
(assert (not (> s0 _lbv10)))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term sizer
 
 Type of the Scalar Term {v:Ty_int | true}                                                                                                                                                         
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T1283)
(declare-fun |0| () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun sizer () Int)
(declare-fun tlen (T1283) Int)
(declare-fun rtree () T1283)
(declare-fun sizel () Int)
(declare-fun ltree () T1283)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T1283)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u318 Int) (var_u317 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= var_v3 false)
         a!4))))
(assert (not (> s0 sizer)))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term s01
 
 Type of the Scalar Term {v:Ty_int | 
 	 Conj <c true
 	 , s0 > v >c }
 ################################################
 Skipping Variable s01 As this a  Formal Parameter to the current function Call
 ################################################
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {v:Ty_int | true}                                                                                                                                                         
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T1289)
(declare-fun |0| () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun sizer () Int)
(declare-fun tlen (T1289) Int)
(declare-fun rtree () T1289)
(declare-fun sizel () Int)
(declare-fun ltree () T1289)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T1289)
(declare-fun n () Int)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u320 Int) (var_u319 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= var_v3 false)
         a!4))))
(assert (not (> s0 n)))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term root
 
 Type of the Scalar Term {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }                                                                                                                                                                    
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T1295)
(declare-fun |0| () Int)
(declare-fun root () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun sizer () Int)
(declare-fun tlen (T1295) Int)
(declare-fun rtree () T1295)
(declare-fun sizel () Int)
(declare-fun ltree () T1295)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T1295)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u322 Int) (var_u321 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= var_v3 false)
         a!4
         (or (> root |0|) (= root |0|))))))
(assert (not (> s0 root)))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term sizel
 
 Type of the Scalar Term {v:Ty_int | true}                                                                                                                                                         
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T1301)
(declare-fun |0| () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun sizer () Int)
(declare-fun tlen (T1301) Int)
(declare-fun rtree () T1301)
(declare-fun sizel () Int)
(declare-fun ltree () T1301)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T1301)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u324 Int) (var_u323 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= var_v3 false)
         a!4))))
(assert (not (> s0 sizel)))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 
 FaileD the subtype check T_vi <: T_goal
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>> 1th Args option for goal : apply subs  (, s01 )
 >>>>>>>>>>>>>>>>>>> 1th Args option for goal : apply subs  (, s0 )
 TEST Overall List : List of Args for goal
 EI apply subs  (, s01 )
 EI apply subs  (, s0 )
 ##################################################################################
  *************** Successfully Synthesized Args ei Forall i 
 Ith Argument Options for goal
 EI apply subs  (, s01 )
 EI apply subs  (, s0 )
 # of Possible Argument Options for goal 2
 Possible Arg Options 
 EI apply subs  (, s01 )
 Possible Arg Options 
 EI apply subs  (, s0 )
 Apply Single Argument Case : f (ei) Case goal
  Case : f (ei) Case goal _lbv7
 Finding Already seen tree for apply goal  (, _lbv7 )
 Typechecking the Term apply goal  (, _lbv7 )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv7 :: {v:Ty_int | (v) ==((s01) -- (1))} | (_lbv7) ==((s01) -- (1))
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (tlen)(v) ==(u)
 	 u = _lbv7 > }}                                                                                                                                                                
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T1307)
(declare-fun |0| () Int)
(declare-fun _lbv7 () Int)
(declare-fun tlen (T1307) Int)
(declare-fun v () T1307)
(declare-fun s01 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T1307)
(declare-fun sizel () Int)
(declare-fun ltree () T1307)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T1307)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u328 Int) (var_u327 Int) (var_u326 Int) (var_u325 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (or (> root |0|) (= root |0|))
         (> s0 s01)
         (=> (= (tlen v) var_u327) (= var_u327 _lbv7))
         (= var_v3 false)
         a!4
         (= _lbv7 (- s01 1))
         (=> (= (tlen v) var_u328) (= var_u328 _lbv7))))))
(assert (not (forall ((var_u329 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply goal  (, _lbv7 )
  Case : f (ei) Case goal _lbv1
 Finding Already seen tree for apply goal  (, _lbv1 )
 Typechecking the Term apply goal  (, _lbv1 )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (tlen)(v) ==(u)
 	 u = _lbv1 > }}                                                                                                                                                                
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T1313)
(declare-fun |0| () Int)
(declare-fun _lbv1 () Int)
(declare-fun tlen (T1313) Int)
(declare-fun v () T1313)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun root () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T1313)
(declare-fun sizel () Int)
(declare-fun ltree () T1313)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T1313)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u333 Int) (var_u332 Int) (var_u331 Int) (var_u330 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (or (> root |0|) (= root |0|))
         (> s0 s01)
         (=> (= (tlen v) var_u332) (= var_u332 _lbv1))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (=> (= (tlen v) var_u333) (= var_u333 _lbv1))))))
(assert (not (forall ((var_u334 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply goal  (, _lbv1 )
  ###################################################
  The Choice of Function goal Was Ill Fated Try Next Choice of function
 ############################################################
  Synthesizing the Function application Pure Component node
 ############################################################
  *************** Trying Arrow Component ************node :  Arrow ( ( root : {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } ) ->  Arrow ( ( sizel : {v:Ty_int | true} ) ->  Arrow ( ( ltree : {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} ) ->  Arrow ( ( sizer : {v:Ty_int | true} ) ->  Arrow ( ( rtree : {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} ) -> {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((sizel) + (1))
 	 (tlen)(v) ==(u) > }}
  *************** Synthesizing Args ei : ti for ************node
 ##################################################################################
  Synthesizing the 1th argument for Function node
  Trying Arguments in Scalars 
 esynthesizeScalar for {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }
 
 Enumerating a Scalar Term s0
 
 Type of the Scalar Term {v:Ty_int | true}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T1319)
(declare-fun |0| () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun root () Int)
(declare-fun sizer () Int)
(declare-fun tlen (T1319) Int)
(declare-fun rtree () T1319)
(declare-fun sizel () Int)
(declare-fun ltree () T1319)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T1319)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u336 Int) (var_u335 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (or (> root |0|) (= root |0|))
         (> s0 s01)
         (= var_v3 false)
         a!4))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (not (or (> s0 |0|) (= s0 |0|))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term _lbv0
 
 Type of the Scalar Term {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }                                                                                                                                                                          
# of Final Z3 expressions 20
 Final solver 
 (declare-sort T1325)
(declare-fun |0| () Int)
(declare-fun _lbv0 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun root () Int)
(declare-fun sizer () Int)
(declare-fun tlen (T1325) Int)
(declare-fun rtree () T1325)
(declare-fun sizel () Int)
(declare-fun ltree () T1325)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T1325)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u338 Int) (var_u337 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (or (> root |0|) (= root |0|))
         (> s0 s01)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (not (or (> _lbv0 |0|) (= _lbv0 |0|))))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 Enumerating a Scalar Term _lbv1
 
 Type of the Scalar Term {v:Ty_int | (v) ==((s0) -- (1))}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T1331)
(declare-fun |0| () Int)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun root () Int)
(declare-fun sizer () Int)
(declare-fun tlen (T1331) Int)
(declare-fun rtree () T1331)
(declare-fun sizel () Int)
(declare-fun ltree () T1331)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T1331)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u340 Int) (var_u339 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (or (> root |0|) (= root |0|))
         (> s0 s01)
         (= _lbv1 (- s0 1))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (not (or (> _lbv1 |0|) (= _lbv1 |0|))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term _lbv2
 
 Type of the Scalar Term {v:Ty_int | (v) ==((_lbv0) -- (1))}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T1337)
(declare-fun |0| () Int)
(declare-fun _lbv0 () Int)
(declare-fun _lbv2 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun root () Int)
(declare-fun sizer () Int)
(declare-fun tlen (T1337) Int)
(declare-fun rtree () T1337)
(declare-fun sizel () Int)
(declare-fun ltree () T1337)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T1337)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u342 Int) (var_u341 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (or (> root |0|) (= root |0|))
         (> s0 s01)
         (= _lbv2 (- _lbv0 1))
         (= var_v3 false)
         a!4
         (= _lbv2 (- _lbv0 1))))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (not (or (> _lbv2 |0|) (= _lbv2 |0|))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term s
 
 Type of the Scalar Term {var_v0:Ty_int | true}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T1343)
(declare-fun |0| () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun root () Int)
(declare-fun sizer () Int)
(declare-fun tlen (T1343) Int)
(declare-fun rtree () T1343)
(declare-fun sizel () Int)
(declare-fun ltree () T1343)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T1343)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u344 Int) (var_u343 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (or (> root |0|) (= root |0|))
         (> s0 s01)
         (= var_v3 false)
         a!4))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (not (or (> s |0|) (= s |0|))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term _lbv6
 
 Type of the Scalar Term {v:Ty_int | (v) ==((root) -- (1))}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T1349)
(declare-fun |0| () Int)
(declare-fun root () Int)
(declare-fun _lbv6 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun sizer () Int)
(declare-fun tlen (T1349) Int)
(declare-fun rtree () T1349)
(declare-fun sizel () Int)
(declare-fun ltree () T1349)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T1349)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u346 Int) (var_u345 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (or (> root |0|) (= root |0|))
         (> s0 s01)
         (= _lbv6 (- root 1))
         (= var_v3 false)
         a!4
         (= _lbv6 (- root 1))))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (not (or (> _lbv6 |0|) (= _lbv6 |0|))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term _lbv7
 
 Type of the Scalar Term {v:Ty_int | (v) ==((s01) -- (1))}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T1355)
(declare-fun |0| () Int)
(declare-fun s01 () Int)
(declare-fun _lbv7 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun sizer () Int)
(declare-fun tlen (T1355) Int)
(declare-fun rtree () T1355)
(declare-fun sizel () Int)
(declare-fun ltree () T1355)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T1355)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u348 Int) (var_u347 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (or (> root |0|) (= root |0|))
         (> s0 s01)
         (= _lbv7 (- s01 1))
         (= var_v3 false)
         a!4
         (= _lbv7 (- s01 1))))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (not (or (> _lbv7 |0|) (= _lbv7 |0|))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term _lbv8
 
 Type of the Scalar Term {v:Ty_int | (v) ==((s) -- (1))}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T1361)
(declare-fun |0| () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun root () Int)
(declare-fun sizer () Int)
(declare-fun tlen (T1361) Int)
(declare-fun rtree () T1361)
(declare-fun sizel () Int)
(declare-fun ltree () T1361)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T1361)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u350 Int) (var_u349 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (or (> root |0|) (= root |0|))
         (> s0 s01)
         (= _lbv8 (- s 1))
         (= var_v3 false)
         a!4
         (= _lbv8 (- s 1))))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (not (or (> _lbv8 |0|) (= _lbv8 |0|))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term _lbv9
 
 Type of the Scalar Term {v:Ty_int | (v) ==((sizer) -- (1))}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T1367)
(declare-fun |0| () Int)
(declare-fun sizer () Int)
(declare-fun _lbv9 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun root () Int)
(declare-fun tlen (T1367) Int)
(declare-fun rtree () T1367)
(declare-fun sizel () Int)
(declare-fun ltree () T1367)
(declare-fun _lbv10 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T1367)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u352 Int) (var_u351 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv10 (- sizel 1))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (or (> root |0|) (= root |0|))
         (> s0 s01)
         (= _lbv9 (- sizer 1))
         (= var_v3 false)
         a!4
         (= _lbv9 (- sizer 1))))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (not (or (> _lbv9 |0|) (= _lbv9 |0|))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term _lbv10
 
 Type of the Scalar Term {v:Ty_int | (v) ==((sizel) -- (1))}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T1373)
(declare-fun |0| () Int)
(declare-fun sizel () Int)
(declare-fun _lbv10 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun root () Int)
(declare-fun sizer () Int)
(declare-fun tlen (T1373) Int)
(declare-fun rtree () T1373)
(declare-fun ltree () T1373)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T1373)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u354 Int) (var_u353 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (or (> root |0|) (= root |0|))
         (> s0 s01)
         (= _lbv10 (- sizel 1))
         (= var_v3 false)
         a!4
         (= _lbv10 (- sizel 1))))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (not (or (> _lbv10 |0|) (= _lbv10 |0|))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term sizer
 
 Type of the Scalar Term {v:Ty_int | true}
 ################################################
 Skipping Variable sizer As this a  Formal Parameter to the current function Call
 ################################################
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {v:Ty_int | true}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T1379)
(declare-fun |0| () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun root () Int)
(declare-fun sizer () Int)
(declare-fun tlen (T1379) Int)
(declare-fun rtree () T1379)
(declare-fun sizel () Int)
(declare-fun ltree () T1379)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T1379)
(declare-fun n () Int)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u356 Int) (var_u355 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (or (> root |0|) (= root |0|))
         (> s0 s01)
         (= var_v3 false)
         a!4))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (not (or (> n |0|) (= n |0|))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term root
 
 Type of the Scalar Term {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }
 ################################################
 Skipping Variable root As this a  Formal Parameter to the current function Call
 ################################################
 
 Enumerating a Scalar Term sizel
 
 Type of the Scalar Term {v:Ty_int | true}
 ################################################
 Skipping Variable sizel As this a  Formal Parameter to the current function Call
 ################################################
 
 Enumerating a Scalar Term s01
 
 Type of the Scalar Term {v:Ty_int | 
 	 Conj <c true
 	 , s0 > v >c }                                                                                                                                                                    
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T1385)
(declare-fun |0| () Int)
(declare-fun s01 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun sizer () Int)
(declare-fun tlen (T1385) Int)
(declare-fun rtree () T1385)
(declare-fun sizel () Int)
(declare-fun ltree () T1385)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T1385)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u358 Int) (var_u357 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (or (> root |0|) (= root |0|))
         (> s0 s01)
         (= var_v3 false)
         a!4
         (> s0 s01)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (not (or (> s01 |0|) (= s01 |0|))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 
 FaileD the subtype check T_vi <: T_goal
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>> 1th Args option for node : apply int_gen  (, dummy )
 TEST Overall List : List of Args for node
 EI apply int_gen  (, dummy )
 ##################################################################################
  Synthesizing the 2th argument for Function node
  Trying Arguments in Scalars 
 esynthesizeScalar for {v:Ty_int | true}
 
 Enumerating a Scalar Term s0
 
 Type of the Scalar Term {v:Ty_int | true}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term _lbv0
 
 Type of the Scalar Term {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 Enumerating a Scalar Term _lbv1
 
 Type of the Scalar Term {v:Ty_int | (v) ==((s0) -- (1))}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 Enumerating a Scalar Term _lbv2
 
 Type of the Scalar Term {v:Ty_int | (v) ==((_lbv0) -- (1))}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 Enumerating a Scalar Term s
 
 Type of the Scalar Term {var_v0:Ty_int | true}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term _lbv6
 
 Type of the Scalar Term {v:Ty_int | (v) ==((root) -- (1))}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 Enumerating a Scalar Term _lbv7
 
 Type of the Scalar Term {v:Ty_int | (v) ==((s01) -- (1))}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 Enumerating a Scalar Term _lbv8
 
 Type of the Scalar Term {v:Ty_int | (v) ==((s) -- (1))}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 Enumerating a Scalar Term _lbv9
 
 Type of the Scalar Term {v:Ty_int | (v) ==((sizer) -- (1))}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 Enumerating a Scalar Term _lbv10
 
 Type of the Scalar Term {v:Ty_int | (v) ==((sizel) -- (1))}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 Enumerating a Scalar Term sizer
 
 Type of the Scalar Term {v:Ty_int | true}
 ################################################
 Skipping Variable sizer As this a  Formal Parameter to the current function Call
 ################################################
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {v:Ty_int | true}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term sizel
 
 Type of the Scalar Term {v:Ty_int | true}
 ################################################
 Skipping Variable sizel As this a  Formal Parameter to the current function Call
 ################################################
 
 Enumerating a Scalar Term s01
 
 Type of the Scalar Term {v:Ty_int | 
 	 Conj <c true
 	 , s0 > v >c }
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term root
 
 Type of the Scalar Term {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }
 ################################################
 Skipping Variable root As this a  Formal Parameter to the current function Call
 ################################################
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>> 2th Args option for node : s01
 >>>>>>>>>>>>>>>>>>> 2th Args option for node : n
 >>>>>>>>>>>>>>>>>>> 2th Args option for node : apply subs  (, sizel )
 >>>>>>>>>>>>>>>>>>> 2th Args option for node : apply subs  (, sizer )
 >>>>>>>>>>>>>>>>>>> 2th Args option for node : apply subs  (, s )
 >>>>>>>>>>>>>>>>>>> 2th Args option for node : apply subs  (, s01 )
 >>>>>>>>>>>>>>>>>>> 2th Args option for node : apply subs  (, root )
 >>>>>>>>>>>>>>>>>>> 2th Args option for node : s
 >>>>>>>>>>>>>>>>>>> 2th Args option for node : apply subs  (, apply int_gen  (, dummy ) )
 >>>>>>>>>>>>>>>>>>> 2th Args option for node : apply subs  (, s0 )
 >>>>>>>>>>>>>>>>>>> 2th Args option for node : apply int_gen  (, dummy )
 >>>>>>>>>>>>>>>>>>> 2th Args option for node : s0
 TEST Overall List : List of Args for node
 EI s01
 EI n
 EI apply subs  (, sizel )
 EI apply subs  (, sizer )
 EI apply subs  (, s )
 EI apply subs  (, s01 )
 EI apply subs  (, root )
 EI s
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI apply subs  (, s0 )
 EI apply int_gen  (, dummy )
 EI s0
 TEST Overall List : List of Args for node
 EI apply int_gen  (, dummy )
 ##################################################################################
  Synthesizing the 3th argument for Function node
  Trying Arguments in Scalars 
 esynthesizeScalar for {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 
 Enumerating a Scalar Term leaf
 
 Type of the Scalar Term {v:Ty_alphatree | (tlen)(v) ==(0)}                                                                                                                                                    
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T1404)
(declare-fun |0| () Int)
(declare-fun tlen (T1404) Int)
(declare-fun leaf () T1404)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T1404)
(declare-fun sizel () Int)
(declare-fun ltree () T1404)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u360 Int) (var_u359 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen leaf) 0)
         (= var_v3 false)
         a!4
         (= (tlen leaf) 0)))))
(assert (not (forall ((var_u361 Int)) (= (tlen leaf) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term ltree
 
 Type of the Scalar Term {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 ################################################
 Skipping Variable ltree As this a  Formal Parameter to the current function Call
 ################################################
 
 Enumerating a Scalar Term rtree
 
 Type of the Scalar Term {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }}
 ################################################
 Skipping Variable rtree As this a  Formal Parameter to the current function Call
 ################################################
 >>>>>>>>>>>>>>>>>> No Scalar found in Environment, Trying esynthesizePureApp <<<<<<<<<<<<<<<<<< 
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 TEST Overall List : List of Args for node
 TEST Overall List : List of Args for node
 EI s01
 EI n
 EI apply subs  (, sizel )
 EI apply subs  (, sizer )
 EI apply subs  (, s )
 EI apply subs  (, s01 )
 EI apply subs  (, root )
 EI s
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI apply subs  (, s0 )
 EI apply int_gen  (, dummy )
 EI s0
 TEST Overall List : List of Args for node
 EI apply int_gen  (, dummy )
 ##################################################################################
  Synthesizing the 4th argument for Function node
  Trying Arguments in Scalars 
 esynthesizeScalar for {v:Ty_int | true}
 
 Enumerating a Scalar Term s0
 
 Type of the Scalar Term {v:Ty_int | true}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term _lbv0
 
 Type of the Scalar Term {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 Enumerating a Scalar Term _lbv1
 
 Type of the Scalar Term {v:Ty_int | (v) ==((s0) -- (1))}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 Enumerating a Scalar Term _lbv2
 
 Type of the Scalar Term {v:Ty_int | (v) ==((_lbv0) -- (1))}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 Enumerating a Scalar Term s
 
 Type of the Scalar Term {var_v0:Ty_int | true}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term _lbv6
 
 Type of the Scalar Term {v:Ty_int | (v) ==((root) -- (1))}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 Enumerating a Scalar Term _lbv7
 
 Type of the Scalar Term {v:Ty_int | (v) ==((s01) -- (1))}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 Enumerating a Scalar Term _lbv8
 
 Type of the Scalar Term {v:Ty_int | (v) ==((s) -- (1))}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 Enumerating a Scalar Term _lbv9
 
 Type of the Scalar Term {v:Ty_int | (v) ==((sizer) -- (1))}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 Enumerating a Scalar Term _lbv10
 
 Type of the Scalar Term {v:Ty_int | (v) ==((sizel) -- (1))}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 Enumerating a Scalar Term sizer
 
 Type of the Scalar Term {v:Ty_int | true}
 ################################################
 Skipping Variable sizer As this a  Formal Parameter to the current function Call
 ################################################
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {v:Ty_int | true}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term s01
 
 Type of the Scalar Term {v:Ty_int | 
 	 Conj <c true
 	 , s0 > v >c }
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term root
 
 Type of the Scalar Term {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }
 ################################################
 Skipping Variable root As this a  Formal Parameter to the current function Call
 ################################################
 
 Enumerating a Scalar Term sizel
 
 Type of the Scalar Term {v:Ty_int | true}
 ################################################
 Skipping Variable sizel As this a  Formal Parameter to the current function Call
 ################################################
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>> 4th Args option for node : s01
 >>>>>>>>>>>>>>>>>>> 4th Args option for node : n
 >>>>>>>>>>>>>>>>>>> 4th Args option for node : apply subs  (, sizel )
 >>>>>>>>>>>>>>>>>>> 4th Args option for node : apply subs  (, sizer )
 >>>>>>>>>>>>>>>>>>> 4th Args option for node : apply subs  (, s )
 >>>>>>>>>>>>>>>>>>> 4th Args option for node : apply subs  (, s01 )
 >>>>>>>>>>>>>>>>>>> 4th Args option for node : apply subs  (, root )
 >>>>>>>>>>>>>>>>>>> 4th Args option for node : s
 >>>>>>>>>>>>>>>>>>> 4th Args option for node : apply subs  (, apply int_gen  (, dummy ) )
 >>>>>>>>>>>>>>>>>>> 4th Args option for node : apply subs  (, s0 )
 >>>>>>>>>>>>>>>>>>> 4th Args option for node : apply int_gen  (, dummy )
 >>>>>>>>>>>>>>>>>>> 4th Args option for node : s0
 TEST Overall List : List of Args for node
 EI s01
 EI n
 EI apply subs  (, sizel )
 EI apply subs  (, sizer )
 EI apply subs  (, s )
 EI apply subs  (, s01 )
 EI apply subs  (, root )
 EI s
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI apply subs  (, s0 )
 EI apply int_gen  (, dummy )
 EI s0
 TEST Overall List : List of Args for node
 TEST Overall List : List of Args for node
 EI s01
 EI n
 EI apply subs  (, sizel )
 EI apply subs  (, sizer )
 EI apply subs  (, s )
 EI apply subs  (, s01 )
 EI apply subs  (, root )
 EI s
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI apply subs  (, s0 )
 EI apply int_gen  (, dummy )
 EI s0
 TEST Overall List : List of Args for node
 EI apply int_gen  (, dummy )
 ##################################################################################
  Synthesizing the 5th argument for Function node
  Trying Arguments in Scalars 
 esynthesizeScalar for {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }}
 
 Enumerating a Scalar Term leaf
 
 Type of the Scalar Term {v:Ty_alphatree | (tlen)(v) ==(0)}                                                                                                                                                    
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T1422)
(declare-fun |0| () Int)
(declare-fun tlen (T1422) Int)
(declare-fun leaf () T1422)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun sizel () Int)
(declare-fun ltree () T1422)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T1422)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u363 Int) (var_u362 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (= (tlen rtree) sizer)
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen leaf) 0)
         (= var_v3 false)
         a!4
         (= (tlen leaf) 0)))))
(assert (not (forall ((var_u364 Int)) (= (tlen leaf) sizer))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term rtree
 
 Type of the Scalar Term {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }}
 ################################################
 Skipping Variable rtree As this a  Formal Parameter to the current function Call
 ################################################
 
 Enumerating a Scalar Term ltree
 
 Type of the Scalar Term {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 ################################################
 Skipping Variable ltree As this a  Formal Parameter to the current function Call
 ################################################
 >>>>>>>>>>>>>>>>>> No Scalar found in Environment, Trying esynthesizePureApp <<<<<<<<<<<<<<<<<< 
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 TEST Overall List : List of Args for node
 TEST Overall List : List of Args for node
 EI s01
 EI n
 EI apply subs  (, sizel )
 EI apply subs  (, sizer )
 EI apply subs  (, s )
 EI apply subs  (, s01 )
 EI apply subs  (, root )
 EI s
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI apply subs  (, s0 )
 EI apply int_gen  (, dummy )
 EI s0
 TEST Overall List : List of Args for node
 TEST Overall List : List of Args for node
 EI s01
 EI n
 EI apply subs  (, sizel )
 EI apply subs  (, sizer )
 EI apply subs  (, s )
 EI apply subs  (, s01 )
 EI apply subs  (, root )
 EI s
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI apply subs  (, s0 )
 EI apply int_gen  (, dummy )
 EI s0
 TEST Overall List : List of Args for node
 EI apply int_gen  (, dummy )
 ##################################################################################
  *************** Synthesizing Args ei : Failed for some  arg
 >>>>>>>>>>>>>>>>>>> 3th Args option for node : ltree
 TEST Overall List : List of Args for node
 EI ltree
 TEST Overall List : List of Args for node
 EI root
 EI n
 EI s01
 EI sizer
 EI sizel
 EI s
 EI apply int_gen  (, dummy )
 EI s0
 EI apply int_gen  (, dummy )
 TEST Overall List : List of Args for node
 EI apply int_gen  (, dummy )
 EI apply subs  (, s0 )
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI apply subs  (, s )
 EI apply subs  (, root )
 EI apply subs  (, sizel )
 EI apply subs  (, sizer )
 EI apply subs  (, s01 )
 ##################################################################################
  Synthesizing the 4th argument for Function node
  Trying Arguments in Scalars 
 esynthesizeScalar for {v:Ty_int | true}
 
 Enumerating a Scalar Term s0
 
 Type of the Scalar Term {v:Ty_int | true}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term _lbv0
 
 Type of the Scalar Term {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 Enumerating a Scalar Term _lbv1
 
 Type of the Scalar Term {v:Ty_int | (v) ==((s0) -- (1))}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 Enumerating a Scalar Term _lbv2
 
 Type of the Scalar Term {v:Ty_int | (v) ==((_lbv0) -- (1))}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 Enumerating a Scalar Term s
 
 Type of the Scalar Term {var_v0:Ty_int | true}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term _lbv6
 
 Type of the Scalar Term {v:Ty_int | (v) ==((root) -- (1))}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 Enumerating a Scalar Term _lbv7
 
 Type of the Scalar Term {v:Ty_int | (v) ==((s01) -- (1))}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 Enumerating a Scalar Term _lbv8
 
 Type of the Scalar Term {v:Ty_int | (v) ==((s) -- (1))}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 Enumerating a Scalar Term _lbv9
 
 Type of the Scalar Term {v:Ty_int | (v) ==((sizer) -- (1))}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 Enumerating a Scalar Term _lbv10
 
 Type of the Scalar Term {v:Ty_int | (v) ==((sizel) -- (1))}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {v:Ty_int | true}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term s01
 
 Type of the Scalar Term {v:Ty_int | 
 	 Conj <c true
 	 , s0 > v >c }
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term root
 
 Type of the Scalar Term {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term sizel
 
 Type of the Scalar Term {v:Ty_int | true}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term sizer
 
 Type of the Scalar Term {v:Ty_int | true}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  , 
 subs, 
 int_gen
 ############################################################
  Synthesizing the Function application Pure Component subs
 ############################################################
  *************** Trying Arrow Component ************subs :  Arrow ( ( n : {v:Ty_int | true} ) -> {v:Ty_int | (v) ==((n) -- (1))}
  *************** Synthesizing Args ei : ti for ************subs
 ##################################################################################
  Synthesizing the 1th argument for Function subs
  Trying Arguments in Scalars 
 esynthesizeScalar for {v:Ty_int | true}
 
 Enumerating a Scalar Term s0
 
 Type of the Scalar Term {v:Ty_int | true}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term _lbv0
 
 Type of the Scalar Term {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 Enumerating a Scalar Term _lbv1
 
 Type of the Scalar Term {v:Ty_int | (v) ==((s0) -- (1))}
 ################################################
 Skipping Variable _lbv1 As Outer Function Call is subs
 
 Enumerating a Scalar Term _lbv2
 
 Type of the Scalar Term {v:Ty_int | (v) ==((_lbv0) -- (1))}
 ################################################
 Skipping Variable _lbv2 As Outer Function Call is subs
 
 Enumerating a Scalar Term s
 
 Type of the Scalar Term {var_v0:Ty_int | true}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term _lbv6
 
 Type of the Scalar Term {v:Ty_int | (v) ==((root) -- (1))}
 ################################################
 Skipping Variable _lbv6 As Outer Function Call is subs
 
 Enumerating a Scalar Term _lbv7
 
 Type of the Scalar Term {v:Ty_int | (v) ==((s01) -- (1))}
 ################################################
 Skipping Variable _lbv7 As Outer Function Call is subs
 
 Enumerating a Scalar Term _lbv8
 
 Type of the Scalar Term {v:Ty_int | (v) ==((s) -- (1))}
 ################################################
 Skipping Variable _lbv8 As Outer Function Call is subs
 
 Enumerating a Scalar Term _lbv9
 
 Type of the Scalar Term {v:Ty_int | (v) ==((sizer) -- (1))}
 ################################################
 Skipping Variable _lbv9 As Outer Function Call is subs
 
 Enumerating a Scalar Term _lbv10
 
 Type of the Scalar Term {v:Ty_int | (v) ==((sizel) -- (1))}
 ################################################
 Skipping Variable _lbv10 As Outer Function Call is subs
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {v:Ty_int | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 ################################################
 
 Enumerating a Scalar Term s01
 
 Type of the Scalar Term {v:Ty_int | 
 	 Conj <c true
 	 , s0 > v >c }
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term root
 
 Type of the Scalar Term {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term sizel
 
 Type of the Scalar Term {v:Ty_int | true}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term sizer
 
 Type of the Scalar Term {v:Ty_int | true}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>> 1th Args option for subs : sizer
 >>>>>>>>>>>>>>>>>>> 1th Args option for subs : sizel
 >>>>>>>>>>>>>>>>>>> 1th Args option for subs : root
 >>>>>>>>>>>>>>>>>>> 1th Args option for subs : s01
 >>>>>>>>>>>>>>>>>>> 1th Args option for subs : s
 >>>>>>>>>>>>>>>>>>> 1th Args option for subs : apply int_gen  (, dummy )
 >>>>>>>>>>>>>>>>>>> 1th Args option for subs : s0
 TEST Overall List : List of Args for subs
 EI sizer
 EI sizel
 EI root
 EI s01
 EI s
 EI apply int_gen  (, dummy )
 EI s0
 ##################################################################################
  *************** Successfully Synthesized Args ei Forall i 
 Ith Argument Options for subs
 EI sizer
 EI sizel
 EI root
 EI s01
 EI s
 EI apply int_gen  (, dummy )
 EI s0
 # of Possible Argument Options for subs 7
 Possible Arg Options 
 EI sizer
 Possible Arg Options 
 EI sizel
 Possible Arg Options 
 EI root
 Possible Arg Options 
 EI s01
 Possible Arg Options 
 EI s
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 Possible Arg Options 
 EI s0
 Apply Single Argument Case : f (ei) Case subs
  Case : f (ei) Case subs sizer
 Finding Already seen tree for apply subs  (, sizer )
 Found _lbv9
  Case : f (ei) Case subs sizel
 Finding Already seen tree for apply subs  (, sizel )
 Found _lbv10
  Case : f (ei) Case subs root
 Finding Already seen tree for apply subs  (, root )
 Found _lbv6
  Case : f (ei) Case subs s01
 Finding Already seen tree for apply subs  (, s01 )
 Found _lbv7
  Case : f (ei) Case subs s
 Finding Already seen tree for apply subs  (, s )
 Found _lbv8
  Case : f (ei) Case subs _lbv0
 Finding Already seen tree for apply subs  (, _lbv0 )
 Found _lbv2
  Case : f (ei) Case subs s0
 Finding Already seen tree for apply subs  (, s0 )
 Found _lbv1
 >>>>>>>>>>>>>>>>>>> 4th Args option for node : sizer
 >>>>>>>>>>>>>>>>>>> 4th Args option for node : sizel
 >>>>>>>>>>>>>>>>>>> 4th Args option for node : root
 >>>>>>>>>>>>>>>>>>> 4th Args option for node : s01
 >>>>>>>>>>>>>>>>>>> 4th Args option for node : n
 >>>>>>>>>>>>>>>>>>> 4th Args option for node : apply subs  (, sizel )
 >>>>>>>>>>>>>>>>>>> 4th Args option for node : apply subs  (, sizer )
 >>>>>>>>>>>>>>>>>>> 4th Args option for node : apply subs  (, s )
 >>>>>>>>>>>>>>>>>>> 4th Args option for node : apply subs  (, s01 )
 >>>>>>>>>>>>>>>>>>> 4th Args option for node : apply subs  (, root )
 >>>>>>>>>>>>>>>>>>> 4th Args option for node : s
 >>>>>>>>>>>>>>>>>>> 4th Args option for node : apply subs  (, apply int_gen  (, dummy ) )
 >>>>>>>>>>>>>>>>>>> 4th Args option for node : apply subs  (, s0 )
 >>>>>>>>>>>>>>>>>>> 4th Args option for node : apply int_gen  (, dummy )
 >>>>>>>>>>>>>>>>>>> 4th Args option for node : s0
 >>>>>>>>>>>>>>>>>>> 4th Args option for node : apply subs  (, s0 )
 >>>>>>>>>>>>>>>>>>> 4th Args option for node : apply subs  (, apply int_gen  (, dummy ) )
 >>>>>>>>>>>>>>>>>>> 4th Args option for node : apply subs  (, s )
 >>>>>>>>>>>>>>>>>>> 4th Args option for node : apply subs  (, s01 )
 >>>>>>>>>>>>>>>>>>> 4th Args option for node : apply subs  (, root )
 >>>>>>>>>>>>>>>>>>> 4th Args option for node : apply subs  (, sizel )
 >>>>>>>>>>>>>>>>>>> 4th Args option for node : apply subs  (, sizer )
 TEST Overall List : List of Args for node
 EI sizer
 EI sizel
 EI root
 EI s01
 EI n
 EI apply subs  (, sizel )
 EI apply subs  (, sizer )
 EI apply subs  (, s )
 EI apply subs  (, s01 )
 EI apply subs  (, root )
 EI s
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI apply subs  (, s0 )
 EI apply int_gen  (, dummy )
 EI s0
 EI apply subs  (, s0 )
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI apply subs  (, s )
 EI apply subs  (, s01 )
 EI apply subs  (, root )
 EI apply subs  (, sizel )
 EI apply subs  (, sizer )
 TEST Overall List : List of Args for node
 EI ltree
 TEST Overall List : List of Args for node
 EI root
 EI n
 EI s01
 EI sizer
 EI sizel
 EI s
 EI apply int_gen  (, dummy )
 EI s0
 EI apply int_gen  (, dummy )
 TEST Overall List : List of Args for node
 EI apply int_gen  (, dummy )
 EI apply subs  (, s0 )
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI apply subs  (, s )
 EI apply subs  (, root )
 EI apply subs  (, sizel )
 EI apply subs  (, sizer )
 EI apply subs  (, s01 )
 ##################################################################################
  Synthesizing the 5th argument for Function node
  Trying Arguments in Scalars 
 esynthesizeScalar for {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }}
 
 Enumerating a Scalar Term leaf
 
 Type of the Scalar Term {v:Ty_alphatree | (tlen)(v) ==(0)}                                                                                                                                                    
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T1450)
(declare-fun |0| () Int)
(declare-fun tlen (T1450) Int)
(declare-fun leaf () T1450)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun sizel () Int)
(declare-fun ltree () T1450)
(declare-fun sizer () Int)
(declare-fun rtree () T1450)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u366 Int) (var_u365 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen rtree) sizer)
         (= (tlen ltree) sizel)
         (= (tlen leaf) 0)
         (= var_v3 false)
         a!4
         (= (tlen leaf) 0)))))
(assert (not (forall ((var_u367 Int)) (= (tlen leaf) sizer))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term rtree
 
 Type of the Scalar Term {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }}                                                                                                                                                    
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T1455)
(declare-fun |0| () Int)
(declare-fun sizer () Int)
(declare-fun tlen (T1455) Int)
(declare-fun rtree () T1455)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun sizel () Int)
(declare-fun ltree () T1455)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T1455)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u370 Int) (var_u369 Int) (var_u368 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (= var_v3 false)
         a!4
         (= (tlen rtree) sizer)))))
(assert (not (forall ((var_u371 Int)) (= (tlen rtree) sizer))))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term ltree
 
 Type of the Scalar Term {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}                                                                                                                                                    
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T1461)
(declare-fun |0| () Int)
(declare-fun sizel () Int)
(declare-fun tlen (T1461) Int)
(declare-fun ltree () T1461)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun sizer () Int)
(declare-fun rtree () T1461)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T1461)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u374 Int) (var_u373 Int) (var_u372 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen rtree) sizer)
         (= (tlen ltree) sizel)
         (= var_v3 false)
         a!4
         (= (tlen ltree) sizel)))))
(assert (not (forall ((var_u375 Int)) (= (tlen ltree) sizer))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 
 FaileD the subtype check T_vi <: T_goal
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  , 
 goal, 
 node
 ############################################################
  Synthesizing the Function application Pure Component goal
 ############################################################
  *************** Trying Arrow Component ************goal :  Arrow ( ( s01 : {v:Ty_int | 
 	 Conj <c true
 	 , s0 > v >c } ) -> {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (tlen)(v) ==(u)
 	 u = s01 > }}
  *************** Synthesizing Args ei : ti for ************goal
 ##################################################################################
  Synthesizing the 1th argument for Function goal
  Trying Arguments in Scalars 
 esynthesizeScalar for {v:Ty_int | 
 	 Conj <c true
 	 , s0 > v >c }
 
 Enumerating a Scalar Term s0
 
 Type of the Scalar Term {v:Ty_int | true}                                                                                                                                                         
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T1467)
(declare-fun |0| () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun sizel () Int)
(declare-fun tlen (T1467) Int)
(declare-fun ltree () T1467)
(declare-fun sizer () Int)
(declare-fun rtree () T1467)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T1467)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u377 Int) (var_u376 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen rtree) sizer)
         (= (tlen ltree) sizel)
         (= var_v3 false)
         a!4))))
(assert (not (> s0 s0)))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term _lbv0
 
 Type of the Scalar Term {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }                                                                                                                                                                    
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T1473)
(declare-fun |0| () Int)
(declare-fun _lbv0 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun sizel () Int)
(declare-fun tlen (T1473) Int)
(declare-fun ltree () T1473)
(declare-fun sizer () Int)
(declare-fun rtree () T1473)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T1473)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u379 Int) (var_u378 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen rtree) sizer)
         (= (tlen ltree) sizel)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))))))
(assert (not (> s0 _lbv0)))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term _lbv1
 
 Type of the Scalar Term {v:Ty_int | (v) ==((s0) -- (1))}                                                                                                                                                         
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T1479)
(declare-fun |0| () Int)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun sizel () Int)
(declare-fun tlen (T1479) Int)
(declare-fun ltree () T1479)
(declare-fun sizer () Int)
(declare-fun rtree () T1479)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T1479)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u381 Int) (var_u380 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen rtree) sizer)
         (= (tlen ltree) sizel)
         (= _lbv1 (- s0 1))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))))))
(assert (not (> s0 _lbv1)))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 Enumerating a Scalar Term _lbv2
 
 Type of the Scalar Term {v:Ty_int | (v) ==((_lbv0) -- (1))}                                                                                                                                                         
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T1485)
(declare-fun |0| () Int)
(declare-fun _lbv0 () Int)
(declare-fun _lbv2 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun sizel () Int)
(declare-fun tlen (T1485) Int)
(declare-fun ltree () T1485)
(declare-fun sizer () Int)
(declare-fun rtree () T1485)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T1485)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u383 Int) (var_u382 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen rtree) sizer)
         (= (tlen ltree) sizel)
         (= _lbv2 (- _lbv0 1))
         (= var_v3 false)
         a!4
         (= _lbv2 (- _lbv0 1))))))
(assert (not (> s0 _lbv2)))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term s
 
 Type of the Scalar Term {var_v0:Ty_int | true}                                                                                                                                                         
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T1491)
(declare-fun |0| () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun sizel () Int)
(declare-fun tlen (T1491) Int)
(declare-fun ltree () T1491)
(declare-fun sizer () Int)
(declare-fun rtree () T1491)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T1491)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u385 Int) (var_u384 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen rtree) sizer)
         (= (tlen ltree) sizel)
         (= var_v3 false)
         a!4))))
(assert (not (> s0 s)))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term _lbv6
 
 Type of the Scalar Term {v:Ty_int | (v) ==((root) -- (1))}                                                                                                                                                         
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T1497)
(declare-fun |0| () Int)
(declare-fun root () Int)
(declare-fun _lbv6 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun sizel () Int)
(declare-fun tlen (T1497) Int)
(declare-fun ltree () T1497)
(declare-fun sizer () Int)
(declare-fun rtree () T1497)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T1497)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u387 Int) (var_u386 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen rtree) sizer)
         (= (tlen ltree) sizel)
         (= _lbv6 (- root 1))
         (= var_v3 false)
         a!4
         (= _lbv6 (- root 1))))))
(assert (not (> s0 _lbv6)))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term _lbv7
 
 Type of the Scalar Term {v:Ty_int | (v) ==((s01) -- (1))}                                                                                                                                                         
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T1503)
(declare-fun |0| () Int)
(declare-fun s01 () Int)
(declare-fun _lbv7 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun sizel () Int)
(declare-fun tlen (T1503) Int)
(declare-fun ltree () T1503)
(declare-fun sizer () Int)
(declare-fun rtree () T1503)
(declare-fun root () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T1503)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u389 Int) (var_u388 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen rtree) sizer)
         (= (tlen ltree) sizel)
         (= _lbv7 (- s01 1))
         (= var_v3 false)
         a!4
         (= _lbv7 (- s01 1))))))
(assert (not (> s0 _lbv7)))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 Enumerating a Scalar Term _lbv8
 
 Type of the Scalar Term {v:Ty_int | (v) ==((s) -- (1))}                                                                                                                                                         
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T1509)
(declare-fun |0| () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun sizel () Int)
(declare-fun tlen (T1509) Int)
(declare-fun ltree () T1509)
(declare-fun sizer () Int)
(declare-fun rtree () T1509)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T1509)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u391 Int) (var_u390 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen rtree) sizer)
         (= (tlen ltree) sizel)
         (= _lbv8 (- s 1))
         (= var_v3 false)
         a!4
         (= _lbv8 (- s 1))))))
(assert (not (> s0 _lbv8)))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term _lbv9
 
 Type of the Scalar Term {v:Ty_int | (v) ==((sizer) -- (1))}                                                                                                                                                         
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T1515)
(declare-fun |0| () Int)
(declare-fun sizer () Int)
(declare-fun _lbv9 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun sizel () Int)
(declare-fun tlen (T1515) Int)
(declare-fun ltree () T1515)
(declare-fun rtree () T1515)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T1515)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u393 Int) (var_u392 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen rtree) sizer)
         (= (tlen ltree) sizel)
         (= _lbv9 (- sizer 1))
         (= var_v3 false)
         a!4
         (= _lbv9 (- sizer 1))))))
(assert (not (> s0 _lbv9)))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term _lbv10
 
 Type of the Scalar Term {v:Ty_int | (v) ==((sizel) -- (1))}                                                                                                                                                         
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T1521)
(declare-fun |0| () Int)
(declare-fun sizel () Int)
(declare-fun _lbv10 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun tlen (T1521) Int)
(declare-fun ltree () T1521)
(declare-fun sizer () Int)
(declare-fun rtree () T1521)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T1521)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u395 Int) (var_u394 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen rtree) sizer)
         (= (tlen ltree) sizel)
         (= _lbv10 (- sizel 1))
         (= var_v3 false)
         a!4
         (= _lbv10 (- sizel 1))))))
(assert (not (> s0 _lbv10)))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term s01
 
 Type of the Scalar Term {v:Ty_int | 
 	 Conj <c true
 	 , s0 > v >c }
 ################################################
 Skipping Variable s01 As this a  Formal Parameter to the current function Call
 ################################################
 
 Enumerating a Scalar Term root
 
 Type of the Scalar Term {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }                                                                                                                                                                    
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T1527)
(declare-fun |0| () Int)
(declare-fun root () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun sizel () Int)
(declare-fun tlen (T1527) Int)
(declare-fun ltree () T1527)
(declare-fun sizer () Int)
(declare-fun rtree () T1527)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T1527)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u397 Int) (var_u396 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (= (tlen rtree) sizer)
         (= (tlen ltree) sizel)
         (or (> root |0|) (= root |0|))
         (= var_v3 false)
         a!4
         (or (> root |0|) (= root |0|))))))
(assert (not (> s0 root)))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term sizel
 
 Type of the Scalar Term {v:Ty_int | true}                                                                                                                                                         
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T1533)
(declare-fun |0| () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun sizel () Int)
(declare-fun tlen (T1533) Int)
(declare-fun ltree () T1533)
(declare-fun sizer () Int)
(declare-fun rtree () T1533)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T1533)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u399 Int) (var_u398 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen rtree) sizer)
         (= (tlen ltree) sizel)
         (= var_v3 false)
         a!4))))
(assert (not (> s0 sizel)))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {v:Ty_int | true}                                                                                                                                                         
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T1539)
(declare-fun |0| () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun sizel () Int)
(declare-fun tlen (T1539) Int)
(declare-fun ltree () T1539)
(declare-fun sizer () Int)
(declare-fun rtree () T1539)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T1539)
(declare-fun n () Int)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u401 Int) (var_u400 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen rtree) sizer)
         (= (tlen ltree) sizel)
         (= var_v3 false)
         a!4))))
(assert (not (> s0 n)))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term sizer
 
 Type of the Scalar Term {v:Ty_int | true}                                                                                                                                                         
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T1545)
(declare-fun |0| () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun sizel () Int)
(declare-fun tlen (T1545) Int)
(declare-fun ltree () T1545)
(declare-fun sizer () Int)
(declare-fun rtree () T1545)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T1545)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u403 Int) (var_u402 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen rtree) sizer)
         (= (tlen ltree) sizel)
         (= var_v3 false)
         a!4))))
(assert (not (> s0 sizer)))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 
 FaileD the subtype check T_vi <: T_goal
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>> 1th Args option for goal : apply subs  (, s01 )
 >>>>>>>>>>>>>>>>>>> 1th Args option for goal : apply subs  (, s0 )
 TEST Overall List : List of Args for goal
 EI apply subs  (, s01 )
 EI apply subs  (, s0 )
 ##################################################################################
  *************** Successfully Synthesized Args ei Forall i 
 Ith Argument Options for goal
 EI apply subs  (, s01 )
 EI apply subs  (, s0 )
 # of Possible Argument Options for goal 2
 Possible Arg Options 
 EI apply subs  (, s01 )
 Possible Arg Options 
 EI apply subs  (, s0 )
 Apply Single Argument Case : f (ei) Case goal
  Case : f (ei) Case goal _lbv7
 Finding Already seen tree for apply goal  (, _lbv7 )
 Typechecking the Term apply goal  (, _lbv7 )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }}
 Argument _lbv7 :: {v:Ty_int | (v) ==((s01) -- (1))} | (_lbv7) ==((s01) -- (1))
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (tlen)(v) ==(u)
 	 u = _lbv7 > }}                                                                                                                                                                
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T1551)
(declare-fun |0| () Int)
(declare-fun _lbv7 () Int)
(declare-fun tlen (T1551) Int)
(declare-fun v () T1551)
(declare-fun s01 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun sizel () Int)
(declare-fun ltree () T1551)
(declare-fun sizer () Int)
(declare-fun rtree () T1551)
(declare-fun root () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T1551)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u407 Int) (var_u406 Int) (var_u405 Int) (var_u404 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (or (> root |0|) (= root |0|))
         (= (tlen rtree) sizer)
         (= (tlen ltree) sizel)
         (> s0 s01)
         (=> (= (tlen v) var_u406) (= var_u406 _lbv7))
         (= var_v3 false)
         a!4
         (= _lbv7 (- s01 1))
         (=> (= (tlen v) var_u407) (= var_u407 _lbv7))))))
(assert (not (forall ((var_u408 Int)) (= (tlen v) sizer))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply goal  (, _lbv7 )
  Case : f (ei) Case goal _lbv1
 Finding Already seen tree for apply goal  (, _lbv1 )
 Typechecking the Term apply goal  (, _lbv1 )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (tlen)(v) ==(u)
 	 u = _lbv1 > }}                                                                                                                                                                
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T1557)
(declare-fun |0| () Int)
(declare-fun _lbv1 () Int)
(declare-fun tlen (T1557) Int)
(declare-fun v () T1557)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T1557)
(declare-fun sizer () Int)
(declare-fun rtree () T1557)
(declare-fun root () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T1557)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u412 Int) (var_u411 Int) (var_u410 Int) (var_u409 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (or (> root |0|) (= root |0|))
         (= (tlen rtree) sizer)
         (= (tlen ltree) sizel)
         (> s0 s01)
         (=> (= (tlen v) var_u411) (= var_u411 _lbv1))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (=> (= (tlen v) var_u412) (= var_u412 _lbv1))))))
(assert (not (forall ((var_u413 Int)) (= (tlen v) sizer))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply goal  (, _lbv1 )
  ###################################################
  The Choice of Function goal Was Ill Fated Try Next Choice of function
 ############################################################
  Synthesizing the Function application Pure Component node
 ############################################################
  *************** Trying Arrow Component ************node :  Arrow ( ( root : {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } ) ->  Arrow ( ( sizel : {v:Ty_int | true} ) ->  Arrow ( ( ltree : {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} ) ->  Arrow ( ( sizer : {v:Ty_int | true} ) ->  Arrow ( ( rtree : {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} ) -> {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((sizel) + (1))
 	 (tlen)(v) ==(u) > }}
  *************** Synthesizing Args ei : ti for ************node
 ##################################################################################
  Synthesizing the 1th argument for Function node
  Trying Arguments in Scalars 
 esynthesizeScalar for {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }
 
 Enumerating a Scalar Term s0
 
 Type of the Scalar Term {v:Ty_int | true}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T1563)
(declare-fun |0| () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun sizel () Int)
(declare-fun tlen (T1563) Int)
(declare-fun ltree () T1563)
(declare-fun sizer () Int)
(declare-fun rtree () T1563)
(declare-fun root () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T1563)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u415 Int) (var_u414 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (or (> root |0|) (= root |0|))
         (= (tlen rtree) sizer)
         (= (tlen ltree) sizel)
         (> s0 s01)
         (= var_v3 false)
         a!4))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (not (or (> s0 |0|) (= s0 |0|))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term _lbv0
 
 Type of the Scalar Term {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }                                                                                                                                                                          
# of Final Z3 expressions 20
 Final solver 
 (declare-sort T1569)
(declare-fun |0| () Int)
(declare-fun _lbv0 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun sizel () Int)
(declare-fun tlen (T1569) Int)
(declare-fun ltree () T1569)
(declare-fun sizer () Int)
(declare-fun rtree () T1569)
(declare-fun root () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T1569)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u417 Int) (var_u416 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (or (> root |0|) (= root |0|))
         (= (tlen rtree) sizer)
         (= (tlen ltree) sizel)
         (> s0 s01)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (not (or (> _lbv0 |0|) (= _lbv0 |0|))))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 Enumerating a Scalar Term _lbv1
 
 Type of the Scalar Term {v:Ty_int | (v) ==((s0) -- (1))}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T1575)
(declare-fun |0| () Int)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun sizel () Int)
(declare-fun tlen (T1575) Int)
(declare-fun ltree () T1575)
(declare-fun sizer () Int)
(declare-fun rtree () T1575)
(declare-fun root () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T1575)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u419 Int) (var_u418 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (or (> root |0|) (= root |0|))
         (= (tlen rtree) sizer)
         (= (tlen ltree) sizel)
         (> s0 s01)
         (= _lbv1 (- s0 1))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (not (or (> _lbv1 |0|) (= _lbv1 |0|))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term _lbv2
 
 Type of the Scalar Term {v:Ty_int | (v) ==((_lbv0) -- (1))}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T1581)
(declare-fun |0| () Int)
(declare-fun _lbv0 () Int)
(declare-fun _lbv2 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun sizel () Int)
(declare-fun tlen (T1581) Int)
(declare-fun ltree () T1581)
(declare-fun sizer () Int)
(declare-fun rtree () T1581)
(declare-fun root () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T1581)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u421 Int) (var_u420 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (or (> root |0|) (= root |0|))
         (= (tlen rtree) sizer)
         (= (tlen ltree) sizel)
         (> s0 s01)
         (= _lbv2 (- _lbv0 1))
         (= var_v3 false)
         a!4
         (= _lbv2 (- _lbv0 1))))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (not (or (> _lbv2 |0|) (= _lbv2 |0|))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term s
 
 Type of the Scalar Term {var_v0:Ty_int | true}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T1587)
(declare-fun |0| () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun sizel () Int)
(declare-fun tlen (T1587) Int)
(declare-fun ltree () T1587)
(declare-fun sizer () Int)
(declare-fun rtree () T1587)
(declare-fun root () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T1587)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u423 Int) (var_u422 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (or (> root |0|) (= root |0|))
         (= (tlen rtree) sizer)
         (= (tlen ltree) sizel)
         (> s0 s01)
         (= var_v3 false)
         a!4))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (not (or (> s |0|) (= s |0|))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term _lbv6
 
 Type of the Scalar Term {v:Ty_int | (v) ==((root) -- (1))}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T1593)
(declare-fun |0| () Int)
(declare-fun root () Int)
(declare-fun _lbv6 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun sizel () Int)
(declare-fun tlen (T1593) Int)
(declare-fun ltree () T1593)
(declare-fun sizer () Int)
(declare-fun rtree () T1593)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T1593)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u425 Int) (var_u424 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (or (> root |0|) (= root |0|))
         (= (tlen rtree) sizer)
         (= (tlen ltree) sizel)
         (> s0 s01)
         (= _lbv6 (- root 1))
         (= var_v3 false)
         a!4
         (= _lbv6 (- root 1))))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (not (or (> _lbv6 |0|) (= _lbv6 |0|))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term _lbv7
 
 Type of the Scalar Term {v:Ty_int | (v) ==((s01) -- (1))}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T1599)
(declare-fun |0| () Int)
(declare-fun s01 () Int)
(declare-fun _lbv7 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun sizel () Int)
(declare-fun tlen (T1599) Int)
(declare-fun ltree () T1599)
(declare-fun sizer () Int)
(declare-fun rtree () T1599)
(declare-fun root () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T1599)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u427 Int) (var_u426 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (or (> root |0|) (= root |0|))
         (= (tlen rtree) sizer)
         (= (tlen ltree) sizel)
         (> s0 s01)
         (= _lbv7 (- s01 1))
         (= var_v3 false)
         a!4
         (= _lbv7 (- s01 1))))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (not (or (> _lbv7 |0|) (= _lbv7 |0|))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term _lbv8
 
 Type of the Scalar Term {v:Ty_int | (v) ==((s) -- (1))}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T1605)
(declare-fun |0| () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun sizel () Int)
(declare-fun tlen (T1605) Int)
(declare-fun ltree () T1605)
(declare-fun sizer () Int)
(declare-fun rtree () T1605)
(declare-fun root () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T1605)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u429 Int) (var_u428 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (or (> root |0|) (= root |0|))
         (= (tlen rtree) sizer)
         (= (tlen ltree) sizel)
         (> s0 s01)
         (= _lbv8 (- s 1))
         (= var_v3 false)
         a!4
         (= _lbv8 (- s 1))))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (not (or (> _lbv8 |0|) (= _lbv8 |0|))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term _lbv9
 
 Type of the Scalar Term {v:Ty_int | (v) ==((sizer) -- (1))}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T1611)
(declare-fun |0| () Int)
(declare-fun sizer () Int)
(declare-fun _lbv9 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun sizel () Int)
(declare-fun tlen (T1611) Int)
(declare-fun ltree () T1611)
(declare-fun rtree () T1611)
(declare-fun root () Int)
(declare-fun _lbv10 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T1611)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u431 Int) (var_u430 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv10 (- sizel 1))
         (or (> root |0|) (= root |0|))
         (= (tlen rtree) sizer)
         (= (tlen ltree) sizel)
         (> s0 s01)
         (= _lbv9 (- sizer 1))
         (= var_v3 false)
         a!4
         (= _lbv9 (- sizer 1))))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (not (or (> _lbv9 |0|) (= _lbv9 |0|))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term _lbv10
 
 Type of the Scalar Term {v:Ty_int | (v) ==((sizel) -- (1))}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T1617)
(declare-fun |0| () Int)
(declare-fun sizel () Int)
(declare-fun _lbv10 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun tlen (T1617) Int)
(declare-fun ltree () T1617)
(declare-fun sizer () Int)
(declare-fun rtree () T1617)
(declare-fun root () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T1617)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u433 Int) (var_u432 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (or (> root |0|) (= root |0|))
         (= (tlen rtree) sizer)
         (= (tlen ltree) sizel)
         (> s0 s01)
         (= _lbv10 (- sizel 1))
         (= var_v3 false)
         a!4
         (= _lbv10 (- sizel 1))))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (not (or (> _lbv10 |0|) (= _lbv10 |0|))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term root
 
 Type of the Scalar Term {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }
 ################################################
 Skipping Variable root As this a  Formal Parameter to the current function Call
 ################################################
 
 Enumerating a Scalar Term sizel
 
 Type of the Scalar Term {v:Ty_int | true}
 ################################################
 Skipping Variable sizel As this a  Formal Parameter to the current function Call
 ################################################
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {v:Ty_int | true}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T1623)
(declare-fun |0| () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun sizel () Int)
(declare-fun tlen (T1623) Int)
(declare-fun ltree () T1623)
(declare-fun sizer () Int)
(declare-fun rtree () T1623)
(declare-fun root () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T1623)
(declare-fun n () Int)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u435 Int) (var_u434 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (or (> root |0|) (= root |0|))
         (= (tlen rtree) sizer)
         (= (tlen ltree) sizel)
         (> s0 s01)
         (= var_v3 false)
         a!4))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (not (or (> n |0|) (= n |0|))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term sizer
 
 Type of the Scalar Term {v:Ty_int | true}
 ################################################
 Skipping Variable sizer As this a  Formal Parameter to the current function Call
 ################################################
 
 Enumerating a Scalar Term s01
 
 Type of the Scalar Term {v:Ty_int | 
 	 Conj <c true
 	 , s0 > v >c }                                                                                                                                                                    
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T1629)
(declare-fun |0| () Int)
(declare-fun s01 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun sizel () Int)
(declare-fun tlen (T1629) Int)
(declare-fun ltree () T1629)
(declare-fun sizer () Int)
(declare-fun rtree () T1629)
(declare-fun root () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T1629)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u437 Int) (var_u436 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (or (> root |0|) (= root |0|))
         (= (tlen rtree) sizer)
         (= (tlen ltree) sizel)
         (> s0 s01)
         (= var_v3 false)
         a!4
         (> s0 s01)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (not (or (> s01 |0|) (= s01 |0|))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 
 FaileD the subtype check T_vi <: T_goal
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>> 1th Args option for node : apply int_gen  (, dummy )
 TEST Overall List : List of Args for node
 EI apply int_gen  (, dummy )
 ##################################################################################
  Synthesizing the 2th argument for Function node
  Trying Arguments in Scalars 
 esynthesizeScalar for {v:Ty_int | true}
 
 Enumerating a Scalar Term s0
 
 Type of the Scalar Term {v:Ty_int | true}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term _lbv0
 
 Type of the Scalar Term {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 Enumerating a Scalar Term _lbv1
 
 Type of the Scalar Term {v:Ty_int | (v) ==((s0) -- (1))}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 Enumerating a Scalar Term _lbv2
 
 Type of the Scalar Term {v:Ty_int | (v) ==((_lbv0) -- (1))}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 Enumerating a Scalar Term s
 
 Type of the Scalar Term {var_v0:Ty_int | true}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term _lbv6
 
 Type of the Scalar Term {v:Ty_int | (v) ==((root) -- (1))}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 Enumerating a Scalar Term _lbv7
 
 Type of the Scalar Term {v:Ty_int | (v) ==((s01) -- (1))}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 Enumerating a Scalar Term _lbv8
 
 Type of the Scalar Term {v:Ty_int | (v) ==((s) -- (1))}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 Enumerating a Scalar Term _lbv9
 
 Type of the Scalar Term {v:Ty_int | (v) ==((sizer) -- (1))}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 Enumerating a Scalar Term _lbv10
 
 Type of the Scalar Term {v:Ty_int | (v) ==((sizel) -- (1))}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 Enumerating a Scalar Term sizel
 
 Type of the Scalar Term {v:Ty_int | true}
 ################################################
 Skipping Variable sizel As this a  Formal Parameter to the current function Call
 ################################################
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {v:Ty_int | true}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term sizer
 
 Type of the Scalar Term {v:Ty_int | true}
 ################################################
 Skipping Variable sizer As this a  Formal Parameter to the current function Call
 ################################################
 
 Enumerating a Scalar Term s01
 
 Type of the Scalar Term {v:Ty_int | 
 	 Conj <c true
 	 , s0 > v >c }
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term root
 
 Type of the Scalar Term {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }
 ################################################
 Skipping Variable root As this a  Formal Parameter to the current function Call
 ################################################
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>> 2th Args option for node : s01
 >>>>>>>>>>>>>>>>>>> 2th Args option for node : n
 >>>>>>>>>>>>>>>>>>> 2th Args option for node : apply subs  (, sizel )
 >>>>>>>>>>>>>>>>>>> 2th Args option for node : apply subs  (, sizer )
 >>>>>>>>>>>>>>>>>>> 2th Args option for node : apply subs  (, s )
 >>>>>>>>>>>>>>>>>>> 2th Args option for node : apply subs  (, s01 )
 >>>>>>>>>>>>>>>>>>> 2th Args option for node : apply subs  (, root )
 >>>>>>>>>>>>>>>>>>> 2th Args option for node : s
 >>>>>>>>>>>>>>>>>>> 2th Args option for node : apply subs  (, apply int_gen  (, dummy ) )
 >>>>>>>>>>>>>>>>>>> 2th Args option for node : apply subs  (, s0 )
 >>>>>>>>>>>>>>>>>>> 2th Args option for node : apply int_gen  (, dummy )
 >>>>>>>>>>>>>>>>>>> 2th Args option for node : s0
 TEST Overall List : List of Args for node
 EI s01
 EI n
 EI apply subs  (, sizel )
 EI apply subs  (, sizer )
 EI apply subs  (, s )
 EI apply subs  (, s01 )
 EI apply subs  (, root )
 EI s
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI apply subs  (, s0 )
 EI apply int_gen  (, dummy )
 EI s0
 TEST Overall List : List of Args for node
 EI apply int_gen  (, dummy )
 ##################################################################################
  Synthesizing the 3th argument for Function node
  Trying Arguments in Scalars 
 esynthesizeScalar for {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 
 Enumerating a Scalar Term leaf
 
 Type of the Scalar Term {v:Ty_alphatree | (tlen)(v) ==(0)}                                                                                                                                                    
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T1648)
(declare-fun |0| () Int)
(declare-fun tlen (T1648) Int)
(declare-fun leaf () T1648)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T1648)
(declare-fun sizer () Int)
(declare-fun rtree () T1648)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u439 Int) (var_u438 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (= (tlen rtree) sizer)
         (= (tlen ltree) sizel)
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen leaf) 0)
         (= var_v3 false)
         a!4
         (= (tlen leaf) 0)))))
(assert (not (forall ((var_u440 Int)) (= (tlen leaf) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term rtree
 
 Type of the Scalar Term {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }}
 ################################################
 Skipping Variable rtree As this a  Formal Parameter to the current function Call
 ################################################
 
 Enumerating a Scalar Term ltree
 
 Type of the Scalar Term {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 ################################################
 Skipping Variable ltree As this a  Formal Parameter to the current function Call
 ################################################
 >>>>>>>>>>>>>>>>>> No Scalar found in Environment, Trying esynthesizePureApp <<<<<<<<<<<<<<<<<< 
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 TEST Overall List : List of Args for node
 TEST Overall List : List of Args for node
 EI s01
 EI n
 EI apply subs  (, sizel )
 EI apply subs  (, sizer )
 EI apply subs  (, s )
 EI apply subs  (, s01 )
 EI apply subs  (, root )
 EI s
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI apply subs  (, s0 )
 EI apply int_gen  (, dummy )
 EI s0
 TEST Overall List : List of Args for node
 EI apply int_gen  (, dummy )
 ##################################################################################
  Synthesizing the 4th argument for Function node
  Trying Arguments in Scalars 
 esynthesizeScalar for {v:Ty_int | true}
 
 Enumerating a Scalar Term s0
 
 Type of the Scalar Term {v:Ty_int | true}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term _lbv0
 
 Type of the Scalar Term {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 Enumerating a Scalar Term _lbv1
 
 Type of the Scalar Term {v:Ty_int | (v) ==((s0) -- (1))}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 Enumerating a Scalar Term _lbv2
 
 Type of the Scalar Term {v:Ty_int | (v) ==((_lbv0) -- (1))}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 Enumerating a Scalar Term s
 
 Type of the Scalar Term {var_v0:Ty_int | true}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term _lbv6
 
 Type of the Scalar Term {v:Ty_int | (v) ==((root) -- (1))}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 Enumerating a Scalar Term _lbv7
 
 Type of the Scalar Term {v:Ty_int | (v) ==((s01) -- (1))}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 Enumerating a Scalar Term _lbv8
 
 Type of the Scalar Term {v:Ty_int | (v) ==((s) -- (1))}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 Enumerating a Scalar Term _lbv9
 
 Type of the Scalar Term {v:Ty_int | (v) ==((sizer) -- (1))}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 Enumerating a Scalar Term _lbv10
 
 Type of the Scalar Term {v:Ty_int | (v) ==((sizel) -- (1))}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {v:Ty_int | true}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term sizer
 
 Type of the Scalar Term {v:Ty_int | true}
 ################################################
 Skipping Variable sizer As this a  Formal Parameter to the current function Call
 ################################################
 
 Enumerating a Scalar Term s01
 
 Type of the Scalar Term {v:Ty_int | 
 	 Conj <c true
 	 , s0 > v >c }
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term root
 
 Type of the Scalar Term {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }
 ################################################
 Skipping Variable root As this a  Formal Parameter to the current function Call
 ################################################
 
 Enumerating a Scalar Term sizel
 
 Type of the Scalar Term {v:Ty_int | true}
 ################################################
 Skipping Variable sizel As this a  Formal Parameter to the current function Call
 ################################################
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>> 4th Args option for node : s01
 >>>>>>>>>>>>>>>>>>> 4th Args option for node : n
 >>>>>>>>>>>>>>>>>>> 4th Args option for node : apply subs  (, sizel )
 >>>>>>>>>>>>>>>>>>> 4th Args option for node : apply subs  (, sizer )
 >>>>>>>>>>>>>>>>>>> 4th Args option for node : apply subs  (, s )
 >>>>>>>>>>>>>>>>>>> 4th Args option for node : apply subs  (, s01 )
 >>>>>>>>>>>>>>>>>>> 4th Args option for node : apply subs  (, root )
 >>>>>>>>>>>>>>>>>>> 4th Args option for node : s
 >>>>>>>>>>>>>>>>>>> 4th Args option for node : apply subs  (, apply int_gen  (, dummy ) )
 >>>>>>>>>>>>>>>>>>> 4th Args option for node : apply subs  (, s0 )
 >>>>>>>>>>>>>>>>>>> 4th Args option for node : apply int_gen  (, dummy )
 >>>>>>>>>>>>>>>>>>> 4th Args option for node : s0
 TEST Overall List : List of Args for node
 EI s01
 EI n
 EI apply subs  (, sizel )
 EI apply subs  (, sizer )
 EI apply subs  (, s )
 EI apply subs  (, s01 )
 EI apply subs  (, root )
 EI s
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI apply subs  (, s0 )
 EI apply int_gen  (, dummy )
 EI s0
 TEST Overall List : List of Args for node
 TEST Overall List : List of Args for node
 EI s01
 EI n
 EI apply subs  (, sizel )
 EI apply subs  (, sizer )
 EI apply subs  (, s )
 EI apply subs  (, s01 )
 EI apply subs  (, root )
 EI s
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI apply subs  (, s0 )
 EI apply int_gen  (, dummy )
 EI s0
 TEST Overall List : List of Args for node
 EI apply int_gen  (, dummy )
 ##################################################################################
  Synthesizing the 5th argument for Function node
  Trying Arguments in Scalars 
 esynthesizeScalar for {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }}
 
 Enumerating a Scalar Term leaf
 
 Type of the Scalar Term {v:Ty_alphatree | (tlen)(v) ==(0)}                                                                                                                                                    
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T1666)
(declare-fun |0| () Int)
(declare-fun tlen (T1666) Int)
(declare-fun leaf () T1666)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun sizel () Int)
(declare-fun ltree () T1666)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T1666)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u442 Int) (var_u441 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (= (tlen rtree) sizer)
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen leaf) 0)
         (= var_v3 false)
         a!4
         (= (tlen leaf) 0)))))
(assert (not (forall ((var_u443 Int)) (= (tlen leaf) sizer))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term rtree
 
 Type of the Scalar Term {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }}
 ################################################
 Skipping Variable rtree As this a  Formal Parameter to the current function Call
 ################################################
 
 Enumerating a Scalar Term ltree
 
 Type of the Scalar Term {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 ################################################
 Skipping Variable ltree As this a  Formal Parameter to the current function Call
 ################################################
 >>>>>>>>>>>>>>>>>> No Scalar found in Environment, Trying esynthesizePureApp <<<<<<<<<<<<<<<<<< 
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 TEST Overall List : List of Args for node
 TEST Overall List : List of Args for node
 EI s01
 EI n
 EI apply subs  (, sizel )
 EI apply subs  (, sizer )
 EI apply subs  (, s )
 EI apply subs  (, s01 )
 EI apply subs  (, root )
 EI s
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI apply subs  (, s0 )
 EI apply int_gen  (, dummy )
 EI s0
 TEST Overall List : List of Args for node
 TEST Overall List : List of Args for node
 EI s01
 EI n
 EI apply subs  (, sizel )
 EI apply subs  (, sizer )
 EI apply subs  (, s )
 EI apply subs  (, s01 )
 EI apply subs  (, root )
 EI s
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI apply subs  (, s0 )
 EI apply int_gen  (, dummy )
 EI s0
 TEST Overall List : List of Args for node
 EI apply int_gen  (, dummy )
 ##################################################################################
  *************** Synthesizing Args ei : Failed for some  arg
 >>>>>>>>>>>>>>>>>>> 5th Args option for node : rtree
 TEST Overall List : List of Args for node
 EI rtree
 TEST Overall List : List of Args for node
 EI sizer
 EI sizel
 EI root
 EI s01
 EI n
 EI apply subs  (, sizel )
 EI apply subs  (, sizer )
 EI apply subs  (, s )
 EI apply subs  (, s01 )
 EI apply subs  (, root )
 EI s
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI apply subs  (, s0 )
 EI apply int_gen  (, dummy )
 EI s0
 EI apply subs  (, s0 )
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI apply subs  (, s )
 EI apply subs  (, s01 )
 EI apply subs  (, root )
 EI apply subs  (, sizel )
 EI apply subs  (, sizer )
 TEST Overall List : List of Args for node
 EI ltree
 TEST Overall List : List of Args for node
 EI root
 EI n
 EI s01
 EI sizer
 EI sizel
 EI s
 EI apply int_gen  (, dummy )
 EI s0
 EI apply int_gen  (, dummy )
 TEST Overall List : List of Args for node
 EI apply int_gen  (, dummy )
 EI apply subs  (, s0 )
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI apply subs  (, s )
 EI apply subs  (, root )
 EI apply subs  (, sizel )
 EI apply subs  (, sizer )
 EI apply subs  (, s01 )
 ##################################################################################
  *************** Successfully Synthesized Args ei Forall i 
 Ith Argument Options for node
 EI apply int_gen  (, dummy )
 EI apply subs  (, s0 )
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI apply subs  (, s )
 EI apply subs  (, root )
 EI apply subs  (, sizel )
 EI apply subs  (, sizer )
 EI apply subs  (, s01 )
 Ith Argument Options for node
 EI root
 EI n
 EI s01
 EI sizer
 EI sizel
 EI s
 EI apply int_gen  (, dummy )
 EI s0
 EI apply int_gen  (, dummy )
 Ith Argument Options for node
 EI ltree
 Ith Argument Options for node
 EI sizer
 EI sizel
 EI root
 EI s01
 EI n
 EI apply subs  (, sizel )
 EI apply subs  (, sizer )
 EI apply subs  (, s )
 EI apply subs  (, s01 )
 EI apply subs  (, root )
 EI s
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI apply subs  (, s0 )
 EI apply int_gen  (, dummy )
 EI s0
 EI apply subs  (, s0 )
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI apply subs  (, s )
 EI apply subs  (, s01 )
 EI apply subs  (, root )
 EI apply subs  (, sizel )
 EI apply subs  (, sizer )
 Ith Argument Options for node
 EI rtree
 # of Possible Argument Options for node 1584
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI root
 EI ltree
 EI sizer
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI root
 EI ltree
 EI sizel
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI root
 EI ltree
 EI root
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI root
 EI ltree
 EI s01
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI root
 EI ltree
 EI n
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI root
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI root
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI root
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI root
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI root
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI root
 EI ltree
 EI s
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI root
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI root
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI root
 EI ltree
 EI apply int_gen  (, dummy )
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI root
 EI ltree
 EI s0
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI root
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI root
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI root
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI root
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI root
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI root
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI root
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI n
 EI ltree
 EI sizer
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI n
 EI ltree
 EI sizel
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI n
 EI ltree
 EI root
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI n
 EI ltree
 EI s01
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI n
 EI ltree
 EI n
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI n
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI n
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI n
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI n
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI n
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI n
 EI ltree
 EI s
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI n
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI n
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI n
 EI ltree
 EI apply int_gen  (, dummy )
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI n
 EI ltree
 EI s0
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI n
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI n
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI n
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI n
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI n
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI n
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI n
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI s01
 EI ltree
 EI sizer
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI s01
 EI ltree
 EI sizel
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI s01
 EI ltree
 EI root
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI s01
 EI ltree
 EI s01
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI s01
 EI ltree
 EI n
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI s01
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI s01
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI s01
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI s01
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI s01
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI s01
 EI ltree
 EI s
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI s01
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI s01
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI s01
 EI ltree
 EI apply int_gen  (, dummy )
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI s01
 EI ltree
 EI s0
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI s01
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI s01
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI s01
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI s01
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI s01
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI s01
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI s01
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI sizer
 EI ltree
 EI sizer
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI sizer
 EI ltree
 EI sizel
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI sizer
 EI ltree
 EI root
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI sizer
 EI ltree
 EI s01
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI sizer
 EI ltree
 EI n
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI sizer
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI sizer
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI sizer
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI sizer
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI sizer
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI sizer
 EI ltree
 EI s
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI sizer
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI sizer
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI sizer
 EI ltree
 EI apply int_gen  (, dummy )
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI sizer
 EI ltree
 EI s0
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI sizer
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI sizer
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI sizer
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI sizer
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI sizer
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI sizer
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI sizer
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI sizel
 EI ltree
 EI sizer
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI sizel
 EI ltree
 EI sizel
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI sizel
 EI ltree
 EI root
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI sizel
 EI ltree
 EI s01
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI sizel
 EI ltree
 EI n
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI sizel
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI sizel
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI sizel
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI sizel
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI sizel
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI sizel
 EI ltree
 EI s
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI sizel
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI sizel
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI sizel
 EI ltree
 EI apply int_gen  (, dummy )
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI sizel
 EI ltree
 EI s0
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI sizel
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI sizel
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI sizel
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI sizel
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI sizel
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI sizel
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI sizel
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI s
 EI ltree
 EI sizer
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI s
 EI ltree
 EI sizel
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI s
 EI ltree
 EI root
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI s
 EI ltree
 EI s01
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI s
 EI ltree
 EI n
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI s
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI s
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI s
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI s
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI s
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI s
 EI ltree
 EI s
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI s
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI s
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI s
 EI ltree
 EI apply int_gen  (, dummy )
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI s
 EI ltree
 EI s0
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI s
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI s
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI s
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI s
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI s
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI s
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI s
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI apply int_gen  (, dummy )
 EI ltree
 EI sizer
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI apply int_gen  (, dummy )
 EI ltree
 EI sizel
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI apply int_gen  (, dummy )
 EI ltree
 EI root
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI apply int_gen  (, dummy )
 EI ltree
 EI s01
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI apply int_gen  (, dummy )
 EI ltree
 EI n
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI apply int_gen  (, dummy )
 EI ltree
 EI s
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply int_gen  (, dummy )
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI apply int_gen  (, dummy )
 EI ltree
 EI s0
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI s0
 EI ltree
 EI sizer
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI s0
 EI ltree
 EI sizel
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI s0
 EI ltree
 EI root
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI s0
 EI ltree
 EI s01
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI s0
 EI ltree
 EI n
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI s0
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI s0
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI s0
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI s0
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI s0
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI s0
 EI ltree
 EI s
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI s0
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI s0
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI s0
 EI ltree
 EI apply int_gen  (, dummy )
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI s0
 EI ltree
 EI s0
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI s0
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI s0
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI s0
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI s0
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI s0
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI s0
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI s0
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI apply int_gen  (, dummy )
 EI ltree
 EI sizer
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI apply int_gen  (, dummy )
 EI ltree
 EI sizel
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI apply int_gen  (, dummy )
 EI ltree
 EI root
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI apply int_gen  (, dummy )
 EI ltree
 EI s01
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI apply int_gen  (, dummy )
 EI ltree
 EI n
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI apply int_gen  (, dummy )
 EI ltree
 EI s
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply int_gen  (, dummy )
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI apply int_gen  (, dummy )
 EI ltree
 EI s0
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply int_gen  (, dummy )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI root
 EI ltree
 EI sizer
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI root
 EI ltree
 EI sizel
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI root
 EI ltree
 EI root
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI root
 EI ltree
 EI s01
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI root
 EI ltree
 EI n
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI root
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI root
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI root
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI root
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI root
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI root
 EI ltree
 EI s
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI root
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI root
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI root
 EI ltree
 EI apply int_gen  (, dummy )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI root
 EI ltree
 EI s0
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI root
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI root
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI root
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI root
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI root
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI root
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI root
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI n
 EI ltree
 EI sizer
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI n
 EI ltree
 EI sizel
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI n
 EI ltree
 EI root
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI n
 EI ltree
 EI s01
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI n
 EI ltree
 EI n
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI n
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI n
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI n
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI n
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI n
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI n
 EI ltree
 EI s
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI n
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI n
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI n
 EI ltree
 EI apply int_gen  (, dummy )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI n
 EI ltree
 EI s0
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI n
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI n
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI n
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI n
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI n
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI n
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI n
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI s01
 EI ltree
 EI sizer
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI s01
 EI ltree
 EI sizel
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI s01
 EI ltree
 EI root
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI s01
 EI ltree
 EI s01
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI s01
 EI ltree
 EI n
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI s01
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI s01
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI s01
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI s01
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI s01
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI s01
 EI ltree
 EI s
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI s01
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI s01
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI s01
 EI ltree
 EI apply int_gen  (, dummy )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI s01
 EI ltree
 EI s0
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI s01
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI s01
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI s01
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI s01
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI s01
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI s01
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI s01
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI sizer
 EI ltree
 EI sizer
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI sizer
 EI ltree
 EI sizel
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI sizer
 EI ltree
 EI root
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI sizer
 EI ltree
 EI s01
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI sizer
 EI ltree
 EI n
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI sizer
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI sizer
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI sizer
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI sizer
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI sizer
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI sizer
 EI ltree
 EI s
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI sizer
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI sizer
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI sizer
 EI ltree
 EI apply int_gen  (, dummy )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI sizer
 EI ltree
 EI s0
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI sizer
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI sizer
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI sizer
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI sizer
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI sizer
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI sizer
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI sizer
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI sizel
 EI ltree
 EI sizer
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI sizel
 EI ltree
 EI sizel
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI sizel
 EI ltree
 EI root
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI sizel
 EI ltree
 EI s01
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI sizel
 EI ltree
 EI n
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI sizel
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI sizel
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI sizel
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI sizel
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI sizel
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI sizel
 EI ltree
 EI s
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI sizel
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI sizel
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI sizel
 EI ltree
 EI apply int_gen  (, dummy )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI sizel
 EI ltree
 EI s0
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI sizel
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI sizel
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI sizel
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI sizel
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI sizel
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI sizel
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI sizel
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI s
 EI ltree
 EI sizer
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI s
 EI ltree
 EI sizel
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI s
 EI ltree
 EI root
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI s
 EI ltree
 EI s01
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI s
 EI ltree
 EI n
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI s
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI s
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI s
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI s
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI s
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI s
 EI ltree
 EI s
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI s
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI s
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI s
 EI ltree
 EI apply int_gen  (, dummy )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI s
 EI ltree
 EI s0
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI s
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI s
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI s
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI s
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI s
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI s
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI s
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI apply int_gen  (, dummy )
 EI ltree
 EI sizer
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI apply int_gen  (, dummy )
 EI ltree
 EI sizel
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI apply int_gen  (, dummy )
 EI ltree
 EI root
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI apply int_gen  (, dummy )
 EI ltree
 EI s01
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI apply int_gen  (, dummy )
 EI ltree
 EI n
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI apply int_gen  (, dummy )
 EI ltree
 EI s
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply int_gen  (, dummy )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI apply int_gen  (, dummy )
 EI ltree
 EI s0
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI s0
 EI ltree
 EI sizer
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI s0
 EI ltree
 EI sizel
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI s0
 EI ltree
 EI root
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI s0
 EI ltree
 EI s01
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI s0
 EI ltree
 EI n
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI s0
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI s0
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI s0
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI s0
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI s0
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI s0
 EI ltree
 EI s
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI s0
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI s0
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI s0
 EI ltree
 EI apply int_gen  (, dummy )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI s0
 EI ltree
 EI s0
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI s0
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI s0
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI s0
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI s0
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI s0
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI s0
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI s0
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI apply int_gen  (, dummy )
 EI ltree
 EI sizer
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI apply int_gen  (, dummy )
 EI ltree
 EI sizel
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI apply int_gen  (, dummy )
 EI ltree
 EI root
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI apply int_gen  (, dummy )
 EI ltree
 EI s01
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI apply int_gen  (, dummy )
 EI ltree
 EI n
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI apply int_gen  (, dummy )
 EI ltree
 EI s
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply int_gen  (, dummy )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI apply int_gen  (, dummy )
 EI ltree
 EI s0
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s0 )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI root
 EI ltree
 EI sizer
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI root
 EI ltree
 EI sizel
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI root
 EI ltree
 EI root
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI root
 EI ltree
 EI s01
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI root
 EI ltree
 EI n
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI root
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI root
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI root
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI root
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI root
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI root
 EI ltree
 EI s
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI root
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI root
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI root
 EI ltree
 EI apply int_gen  (, dummy )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI root
 EI ltree
 EI s0
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI root
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI root
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI root
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI root
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI root
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI root
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI root
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI n
 EI ltree
 EI sizer
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI n
 EI ltree
 EI sizel
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI n
 EI ltree
 EI root
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI n
 EI ltree
 EI s01
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI n
 EI ltree
 EI n
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI n
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI n
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI n
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI n
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI n
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI n
 EI ltree
 EI s
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI n
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI n
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI n
 EI ltree
 EI apply int_gen  (, dummy )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI n
 EI ltree
 EI s0
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI n
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI n
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI n
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI n
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI n
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI n
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI n
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI s01
 EI ltree
 EI sizer
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI s01
 EI ltree
 EI sizel
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI s01
 EI ltree
 EI root
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI s01
 EI ltree
 EI s01
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI s01
 EI ltree
 EI n
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI s01
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI s01
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI s01
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI s01
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI s01
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI s01
 EI ltree
 EI s
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI s01
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI s01
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI s01
 EI ltree
 EI apply int_gen  (, dummy )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI s01
 EI ltree
 EI s0
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI s01
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI s01
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI s01
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI s01
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI s01
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI s01
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI s01
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI sizer
 EI ltree
 EI sizer
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI sizer
 EI ltree
 EI sizel
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI sizer
 EI ltree
 EI root
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI sizer
 EI ltree
 EI s01
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI sizer
 EI ltree
 EI n
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI sizer
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI sizer
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI sizer
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI sizer
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI sizer
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI sizer
 EI ltree
 EI s
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI sizer
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI sizer
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI sizer
 EI ltree
 EI apply int_gen  (, dummy )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI sizer
 EI ltree
 EI s0
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI sizer
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI sizer
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI sizer
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI sizer
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI sizer
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI sizer
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI sizer
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI sizel
 EI ltree
 EI sizer
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI sizel
 EI ltree
 EI sizel
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI sizel
 EI ltree
 EI root
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI sizel
 EI ltree
 EI s01
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI sizel
 EI ltree
 EI n
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI sizel
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI sizel
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI sizel
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI sizel
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI sizel
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI sizel
 EI ltree
 EI s
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI sizel
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI sizel
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI sizel
 EI ltree
 EI apply int_gen  (, dummy )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI sizel
 EI ltree
 EI s0
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI sizel
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI sizel
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI sizel
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI sizel
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI sizel
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI sizel
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI sizel
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI s
 EI ltree
 EI sizer
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI s
 EI ltree
 EI sizel
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI s
 EI ltree
 EI root
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI s
 EI ltree
 EI s01
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI s
 EI ltree
 EI n
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI s
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI s
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI s
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI s
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI s
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI s
 EI ltree
 EI s
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI s
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI s
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI s
 EI ltree
 EI apply int_gen  (, dummy )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI s
 EI ltree
 EI s0
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI s
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI s
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI s
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI s
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI s
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI s
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI s
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI apply int_gen  (, dummy )
 EI ltree
 EI sizer
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI apply int_gen  (, dummy )
 EI ltree
 EI sizel
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI apply int_gen  (, dummy )
 EI ltree
 EI root
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI apply int_gen  (, dummy )
 EI ltree
 EI s01
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI apply int_gen  (, dummy )
 EI ltree
 EI n
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI apply int_gen  (, dummy )
 EI ltree
 EI s
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply int_gen  (, dummy )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI apply int_gen  (, dummy )
 EI ltree
 EI s0
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI s0
 EI ltree
 EI sizer
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI s0
 EI ltree
 EI sizel
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI s0
 EI ltree
 EI root
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI s0
 EI ltree
 EI s01
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI s0
 EI ltree
 EI n
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI s0
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI s0
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI s0
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI s0
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI s0
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI s0
 EI ltree
 EI s
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI s0
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI s0
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI s0
 EI ltree
 EI apply int_gen  (, dummy )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI s0
 EI ltree
 EI s0
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI s0
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI s0
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI s0
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI s0
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI s0
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI s0
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI s0
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI apply int_gen  (, dummy )
 EI ltree
 EI sizer
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI apply int_gen  (, dummy )
 EI ltree
 EI sizel
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI apply int_gen  (, dummy )
 EI ltree
 EI root
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI apply int_gen  (, dummy )
 EI ltree
 EI s01
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI apply int_gen  (, dummy )
 EI ltree
 EI n
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI apply int_gen  (, dummy )
 EI ltree
 EI s
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply int_gen  (, dummy )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI apply int_gen  (, dummy )
 EI ltree
 EI s0
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI root
 EI ltree
 EI sizer
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI root
 EI ltree
 EI sizel
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI root
 EI ltree
 EI root
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI root
 EI ltree
 EI s01
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI root
 EI ltree
 EI n
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI root
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI root
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI root
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI root
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI root
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI root
 EI ltree
 EI s
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI root
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI root
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI root
 EI ltree
 EI apply int_gen  (, dummy )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI root
 EI ltree
 EI s0
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI root
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI root
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI root
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI root
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI root
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI root
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI root
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI n
 EI ltree
 EI sizer
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI n
 EI ltree
 EI sizel
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI n
 EI ltree
 EI root
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI n
 EI ltree
 EI s01
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI n
 EI ltree
 EI n
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI n
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI n
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI n
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI n
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI n
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI n
 EI ltree
 EI s
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI n
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI n
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI n
 EI ltree
 EI apply int_gen  (, dummy )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI n
 EI ltree
 EI s0
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI n
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI n
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI n
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI n
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI n
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI n
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI n
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI s01
 EI ltree
 EI sizer
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI s01
 EI ltree
 EI sizel
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI s01
 EI ltree
 EI root
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI s01
 EI ltree
 EI s01
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI s01
 EI ltree
 EI n
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI s01
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI s01
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI s01
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI s01
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI s01
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI s01
 EI ltree
 EI s
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI s01
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI s01
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI s01
 EI ltree
 EI apply int_gen  (, dummy )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI s01
 EI ltree
 EI s0
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI s01
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI s01
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI s01
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI s01
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI s01
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI s01
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI s01
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI sizer
 EI ltree
 EI sizer
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI sizer
 EI ltree
 EI sizel
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI sizer
 EI ltree
 EI root
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI sizer
 EI ltree
 EI s01
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI sizer
 EI ltree
 EI n
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI sizer
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI sizer
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI sizer
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI sizer
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI sizer
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI sizer
 EI ltree
 EI s
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI sizer
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI sizer
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI sizer
 EI ltree
 EI apply int_gen  (, dummy )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI sizer
 EI ltree
 EI s0
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI sizer
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI sizer
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI sizer
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI sizer
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI sizer
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI sizer
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI sizer
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI sizel
 EI ltree
 EI sizer
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI sizel
 EI ltree
 EI sizel
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI sizel
 EI ltree
 EI root
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI sizel
 EI ltree
 EI s01
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI sizel
 EI ltree
 EI n
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI sizel
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI sizel
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI sizel
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI sizel
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI sizel
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI sizel
 EI ltree
 EI s
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI sizel
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI sizel
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI sizel
 EI ltree
 EI apply int_gen  (, dummy )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI sizel
 EI ltree
 EI s0
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI sizel
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI sizel
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI sizel
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI sizel
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI sizel
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI sizel
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI sizel
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI s
 EI ltree
 EI sizer
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI s
 EI ltree
 EI sizel
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI s
 EI ltree
 EI root
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI s
 EI ltree
 EI s01
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI s
 EI ltree
 EI n
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI s
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI s
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI s
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI s
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI s
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI s
 EI ltree
 EI s
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI s
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI s
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI s
 EI ltree
 EI apply int_gen  (, dummy )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI s
 EI ltree
 EI s0
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI s
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI s
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI s
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI s
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI s
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI s
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI s
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI apply int_gen  (, dummy )
 EI ltree
 EI sizer
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI apply int_gen  (, dummy )
 EI ltree
 EI sizel
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI apply int_gen  (, dummy )
 EI ltree
 EI root
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI apply int_gen  (, dummy )
 EI ltree
 EI s01
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI apply int_gen  (, dummy )
 EI ltree
 EI n
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI apply int_gen  (, dummy )
 EI ltree
 EI s
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply int_gen  (, dummy )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI apply int_gen  (, dummy )
 EI ltree
 EI s0
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI s0
 EI ltree
 EI sizer
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI s0
 EI ltree
 EI sizel
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI s0
 EI ltree
 EI root
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI s0
 EI ltree
 EI s01
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI s0
 EI ltree
 EI n
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI s0
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI s0
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI s0
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI s0
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI s0
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI s0
 EI ltree
 EI s
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI s0
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI s0
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI s0
 EI ltree
 EI apply int_gen  (, dummy )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI s0
 EI ltree
 EI s0
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI s0
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI s0
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI s0
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI s0
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI s0
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI s0
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI s0
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI apply int_gen  (, dummy )
 EI ltree
 EI sizer
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI apply int_gen  (, dummy )
 EI ltree
 EI sizel
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI apply int_gen  (, dummy )
 EI ltree
 EI root
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI apply int_gen  (, dummy )
 EI ltree
 EI s01
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI apply int_gen  (, dummy )
 EI ltree
 EI n
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI apply int_gen  (, dummy )
 EI ltree
 EI s
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply int_gen  (, dummy )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI apply int_gen  (, dummy )
 EI ltree
 EI s0
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI root
 EI ltree
 EI sizer
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI root
 EI ltree
 EI sizel
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI root
 EI ltree
 EI root
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI root
 EI ltree
 EI s01
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI root
 EI ltree
 EI n
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI root
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI root
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI root
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI root
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI root
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI root
 EI ltree
 EI s
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI root
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI root
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI root
 EI ltree
 EI apply int_gen  (, dummy )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI root
 EI ltree
 EI s0
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI root
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI root
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI root
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI root
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI root
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI root
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI root
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI n
 EI ltree
 EI sizer
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI n
 EI ltree
 EI sizel
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI n
 EI ltree
 EI root
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI n
 EI ltree
 EI s01
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI n
 EI ltree
 EI n
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI n
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI n
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI n
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI n
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI n
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI n
 EI ltree
 EI s
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI n
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI n
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI n
 EI ltree
 EI apply int_gen  (, dummy )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI n
 EI ltree
 EI s0
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI n
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI n
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI n
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI n
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI n
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI n
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI n
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI s01
 EI ltree
 EI sizer
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI s01
 EI ltree
 EI sizel
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI s01
 EI ltree
 EI root
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI s01
 EI ltree
 EI s01
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI s01
 EI ltree
 EI n
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI s01
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI s01
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI s01
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI s01
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI s01
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI s01
 EI ltree
 EI s
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI s01
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI s01
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI s01
 EI ltree
 EI apply int_gen  (, dummy )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI s01
 EI ltree
 EI s0
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI s01
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI s01
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI s01
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI s01
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI s01
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI s01
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI s01
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI sizer
 EI ltree
 EI sizer
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI sizer
 EI ltree
 EI sizel
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI sizer
 EI ltree
 EI root
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI sizer
 EI ltree
 EI s01
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI sizer
 EI ltree
 EI n
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI sizer
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI sizer
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI sizer
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI sizer
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI sizer
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI sizer
 EI ltree
 EI s
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI sizer
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI sizer
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI sizer
 EI ltree
 EI apply int_gen  (, dummy )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI sizer
 EI ltree
 EI s0
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI sizer
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI sizer
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI sizer
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI sizer
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI sizer
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI sizer
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI sizer
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI sizel
 EI ltree
 EI sizer
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI sizel
 EI ltree
 EI sizel
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI sizel
 EI ltree
 EI root
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI sizel
 EI ltree
 EI s01
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI sizel
 EI ltree
 EI n
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI sizel
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI sizel
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI sizel
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI sizel
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI sizel
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI sizel
 EI ltree
 EI s
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI sizel
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI sizel
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI sizel
 EI ltree
 EI apply int_gen  (, dummy )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI sizel
 EI ltree
 EI s0
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI sizel
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI sizel
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI sizel
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI sizel
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI sizel
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI sizel
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI sizel
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI s
 EI ltree
 EI sizer
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI s
 EI ltree
 EI sizel
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI s
 EI ltree
 EI root
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI s
 EI ltree
 EI s01
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI s
 EI ltree
 EI n
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI s
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI s
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI s
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI s
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI s
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI s
 EI ltree
 EI s
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI s
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI s
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI s
 EI ltree
 EI apply int_gen  (, dummy )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI s
 EI ltree
 EI s0
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI s
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI s
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI s
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI s
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI s
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI s
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI s
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI apply int_gen  (, dummy )
 EI ltree
 EI sizer
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI apply int_gen  (, dummy )
 EI ltree
 EI sizel
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI apply int_gen  (, dummy )
 EI ltree
 EI root
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI apply int_gen  (, dummy )
 EI ltree
 EI s01
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI apply int_gen  (, dummy )
 EI ltree
 EI n
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI apply int_gen  (, dummy )
 EI ltree
 EI s
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply int_gen  (, dummy )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI apply int_gen  (, dummy )
 EI ltree
 EI s0
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI s0
 EI ltree
 EI sizer
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI s0
 EI ltree
 EI sizel
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI s0
 EI ltree
 EI root
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI s0
 EI ltree
 EI s01
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI s0
 EI ltree
 EI n
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI s0
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI s0
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI s0
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI s0
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI s0
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI s0
 EI ltree
 EI s
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI s0
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI s0
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI s0
 EI ltree
 EI apply int_gen  (, dummy )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI s0
 EI ltree
 EI s0
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI s0
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI s0
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI s0
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI s0
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI s0
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI s0
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI s0
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI apply int_gen  (, dummy )
 EI ltree
 EI sizer
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI apply int_gen  (, dummy )
 EI ltree
 EI sizel
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI apply int_gen  (, dummy )
 EI ltree
 EI root
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI apply int_gen  (, dummy )
 EI ltree
 EI s01
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI apply int_gen  (, dummy )
 EI ltree
 EI n
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI apply int_gen  (, dummy )
 EI ltree
 EI s
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply int_gen  (, dummy )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI apply int_gen  (, dummy )
 EI ltree
 EI s0
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, root )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI root
 EI ltree
 EI sizer
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI root
 EI ltree
 EI sizel
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI root
 EI ltree
 EI root
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI root
 EI ltree
 EI s01
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI root
 EI ltree
 EI n
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI root
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI root
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI root
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI root
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI root
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI root
 EI ltree
 EI s
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI root
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI root
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI root
 EI ltree
 EI apply int_gen  (, dummy )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI root
 EI ltree
 EI s0
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI root
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI root
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI root
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI root
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI root
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI root
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI root
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI n
 EI ltree
 EI sizer
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI n
 EI ltree
 EI sizel
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI n
 EI ltree
 EI root
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI n
 EI ltree
 EI s01
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI n
 EI ltree
 EI n
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI n
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI n
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI n
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI n
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI n
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI n
 EI ltree
 EI s
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI n
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI n
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI n
 EI ltree
 EI apply int_gen  (, dummy )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI n
 EI ltree
 EI s0
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI n
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI n
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI n
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI n
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI n
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI n
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI n
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI s01
 EI ltree
 EI sizer
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI s01
 EI ltree
 EI sizel
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI s01
 EI ltree
 EI root
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI s01
 EI ltree
 EI s01
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI s01
 EI ltree
 EI n
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI s01
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI s01
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI s01
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI s01
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI s01
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI s01
 EI ltree
 EI s
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI s01
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI s01
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI s01
 EI ltree
 EI apply int_gen  (, dummy )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI s01
 EI ltree
 EI s0
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI s01
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI s01
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI s01
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI s01
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI s01
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI s01
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI s01
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI sizer
 EI ltree
 EI sizer
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI sizer
 EI ltree
 EI sizel
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI sizer
 EI ltree
 EI root
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI sizer
 EI ltree
 EI s01
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI sizer
 EI ltree
 EI n
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI sizer
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI sizer
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI sizer
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI sizer
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI sizer
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI sizer
 EI ltree
 EI s
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI sizer
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI sizer
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI sizer
 EI ltree
 EI apply int_gen  (, dummy )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI sizer
 EI ltree
 EI s0
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI sizer
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI sizer
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI sizer
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI sizer
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI sizer
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI sizer
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI sizer
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI sizel
 EI ltree
 EI sizer
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI sizel
 EI ltree
 EI sizel
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI sizel
 EI ltree
 EI root
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI sizel
 EI ltree
 EI s01
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI sizel
 EI ltree
 EI n
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI sizel
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI sizel
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI sizel
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI sizel
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI sizel
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI sizel
 EI ltree
 EI s
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI sizel
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI sizel
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI sizel
 EI ltree
 EI apply int_gen  (, dummy )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI sizel
 EI ltree
 EI s0
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI sizel
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI sizel
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI sizel
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI sizel
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI sizel
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI sizel
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI sizel
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI s
 EI ltree
 EI sizer
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI s
 EI ltree
 EI sizel
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI s
 EI ltree
 EI root
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI s
 EI ltree
 EI s01
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI s
 EI ltree
 EI n
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI s
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI s
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI s
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI s
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI s
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI s
 EI ltree
 EI s
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI s
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI s
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI s
 EI ltree
 EI apply int_gen  (, dummy )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI s
 EI ltree
 EI s0
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI s
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI s
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI s
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI s
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI s
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI s
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI s
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI apply int_gen  (, dummy )
 EI ltree
 EI sizer
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI apply int_gen  (, dummy )
 EI ltree
 EI sizel
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI apply int_gen  (, dummy )
 EI ltree
 EI root
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI apply int_gen  (, dummy )
 EI ltree
 EI s01
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI apply int_gen  (, dummy )
 EI ltree
 EI n
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI apply int_gen  (, dummy )
 EI ltree
 EI s
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply int_gen  (, dummy )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI apply int_gen  (, dummy )
 EI ltree
 EI s0
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI s0
 EI ltree
 EI sizer
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI s0
 EI ltree
 EI sizel
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI s0
 EI ltree
 EI root
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI s0
 EI ltree
 EI s01
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI s0
 EI ltree
 EI n
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI s0
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI s0
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI s0
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI s0
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI s0
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI s0
 EI ltree
 EI s
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI s0
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI s0
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI s0
 EI ltree
 EI apply int_gen  (, dummy )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI s0
 EI ltree
 EI s0
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI s0
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI s0
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI s0
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI s0
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI s0
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI s0
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI s0
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI apply int_gen  (, dummy )
 EI ltree
 EI sizer
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI apply int_gen  (, dummy )
 EI ltree
 EI sizel
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI apply int_gen  (, dummy )
 EI ltree
 EI root
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI apply int_gen  (, dummy )
 EI ltree
 EI s01
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI apply int_gen  (, dummy )
 EI ltree
 EI n
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI apply int_gen  (, dummy )
 EI ltree
 EI s
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply int_gen  (, dummy )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI apply int_gen  (, dummy )
 EI ltree
 EI s0
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizel )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI root
 EI ltree
 EI sizer
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI root
 EI ltree
 EI sizel
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI root
 EI ltree
 EI root
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI root
 EI ltree
 EI s01
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI root
 EI ltree
 EI n
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI root
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI root
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI root
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI root
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI root
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI root
 EI ltree
 EI s
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI root
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI root
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI root
 EI ltree
 EI apply int_gen  (, dummy )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI root
 EI ltree
 EI s0
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI root
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI root
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI root
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI root
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI root
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI root
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI root
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI n
 EI ltree
 EI sizer
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI n
 EI ltree
 EI sizel
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI n
 EI ltree
 EI root
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI n
 EI ltree
 EI s01
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI n
 EI ltree
 EI n
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI n
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI n
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI n
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI n
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI n
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI n
 EI ltree
 EI s
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI n
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI n
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI n
 EI ltree
 EI apply int_gen  (, dummy )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI n
 EI ltree
 EI s0
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI n
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI n
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI n
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI n
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI n
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI n
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI n
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI s01
 EI ltree
 EI sizer
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI s01
 EI ltree
 EI sizel
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI s01
 EI ltree
 EI root
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI s01
 EI ltree
 EI s01
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI s01
 EI ltree
 EI n
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI s01
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI s01
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI s01
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI s01
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI s01
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI s01
 EI ltree
 EI s
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI s01
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI s01
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI s01
 EI ltree
 EI apply int_gen  (, dummy )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI s01
 EI ltree
 EI s0
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI s01
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI s01
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI s01
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI s01
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI s01
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI s01
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI s01
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI sizer
 EI ltree
 EI sizer
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI sizer
 EI ltree
 EI sizel
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI sizer
 EI ltree
 EI root
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI sizer
 EI ltree
 EI s01
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI sizer
 EI ltree
 EI n
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI sizer
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI sizer
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI sizer
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI sizer
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI sizer
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI sizer
 EI ltree
 EI s
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI sizer
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI sizer
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI sizer
 EI ltree
 EI apply int_gen  (, dummy )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI sizer
 EI ltree
 EI s0
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI sizer
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI sizer
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI sizer
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI sizer
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI sizer
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI sizer
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI sizer
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI sizel
 EI ltree
 EI sizer
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI sizel
 EI ltree
 EI sizel
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI sizel
 EI ltree
 EI root
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI sizel
 EI ltree
 EI s01
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI sizel
 EI ltree
 EI n
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI sizel
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI sizel
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI sizel
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI sizel
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI sizel
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI sizel
 EI ltree
 EI s
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI sizel
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI sizel
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI sizel
 EI ltree
 EI apply int_gen  (, dummy )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI sizel
 EI ltree
 EI s0
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI sizel
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI sizel
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI sizel
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI sizel
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI sizel
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI sizel
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI sizel
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI s
 EI ltree
 EI sizer
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI s
 EI ltree
 EI sizel
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI s
 EI ltree
 EI root
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI s
 EI ltree
 EI s01
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI s
 EI ltree
 EI n
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI s
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI s
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI s
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI s
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI s
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI s
 EI ltree
 EI s
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI s
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI s
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI s
 EI ltree
 EI apply int_gen  (, dummy )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI s
 EI ltree
 EI s0
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI s
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI s
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI s
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI s
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI s
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI s
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI s
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI apply int_gen  (, dummy )
 EI ltree
 EI sizer
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI apply int_gen  (, dummy )
 EI ltree
 EI sizel
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI apply int_gen  (, dummy )
 EI ltree
 EI root
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI apply int_gen  (, dummy )
 EI ltree
 EI s01
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI apply int_gen  (, dummy )
 EI ltree
 EI n
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI apply int_gen  (, dummy )
 EI ltree
 EI s
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply int_gen  (, dummy )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI apply int_gen  (, dummy )
 EI ltree
 EI s0
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI s0
 EI ltree
 EI sizer
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI s0
 EI ltree
 EI sizel
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI s0
 EI ltree
 EI root
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI s0
 EI ltree
 EI s01
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI s0
 EI ltree
 EI n
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI s0
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI s0
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI s0
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI s0
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI s0
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI s0
 EI ltree
 EI s
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI s0
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI s0
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI s0
 EI ltree
 EI apply int_gen  (, dummy )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI s0
 EI ltree
 EI s0
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI s0
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI s0
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI s0
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI s0
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI s0
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI s0
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI s0
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI apply int_gen  (, dummy )
 EI ltree
 EI sizer
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI apply int_gen  (, dummy )
 EI ltree
 EI sizel
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI apply int_gen  (, dummy )
 EI ltree
 EI root
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI apply int_gen  (, dummy )
 EI ltree
 EI s01
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI apply int_gen  (, dummy )
 EI ltree
 EI n
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI apply int_gen  (, dummy )
 EI ltree
 EI s
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply int_gen  (, dummy )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI apply int_gen  (, dummy )
 EI ltree
 EI s0
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, sizer )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI root
 EI ltree
 EI sizer
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI root
 EI ltree
 EI sizel
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI root
 EI ltree
 EI root
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI root
 EI ltree
 EI s01
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI root
 EI ltree
 EI n
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI root
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI root
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI root
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI root
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI root
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI root
 EI ltree
 EI s
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI root
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI root
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI root
 EI ltree
 EI apply int_gen  (, dummy )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI root
 EI ltree
 EI s0
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI root
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI root
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI root
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI root
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI root
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI root
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI root
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI n
 EI ltree
 EI sizer
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI n
 EI ltree
 EI sizel
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI n
 EI ltree
 EI root
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI n
 EI ltree
 EI s01
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI n
 EI ltree
 EI n
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI n
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI n
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI n
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI n
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI n
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI n
 EI ltree
 EI s
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI n
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI n
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI n
 EI ltree
 EI apply int_gen  (, dummy )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI n
 EI ltree
 EI s0
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI n
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI n
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI n
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI n
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI n
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI n
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI n
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI s01
 EI ltree
 EI sizer
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI s01
 EI ltree
 EI sizel
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI s01
 EI ltree
 EI root
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI s01
 EI ltree
 EI s01
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI s01
 EI ltree
 EI n
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI s01
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI s01
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI s01
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI s01
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI s01
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI s01
 EI ltree
 EI s
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI s01
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI s01
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI s01
 EI ltree
 EI apply int_gen  (, dummy )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI s01
 EI ltree
 EI s0
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI s01
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI s01
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI s01
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI s01
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI s01
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI s01
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI s01
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI sizer
 EI ltree
 EI sizer
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI sizer
 EI ltree
 EI sizel
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI sizer
 EI ltree
 EI root
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI sizer
 EI ltree
 EI s01
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI sizer
 EI ltree
 EI n
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI sizer
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI sizer
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI sizer
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI sizer
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI sizer
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI sizer
 EI ltree
 EI s
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI sizer
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI sizer
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI sizer
 EI ltree
 EI apply int_gen  (, dummy )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI sizer
 EI ltree
 EI s0
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI sizer
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI sizer
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI sizer
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI sizer
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI sizer
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI sizer
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI sizer
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI sizel
 EI ltree
 EI sizer
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI sizel
 EI ltree
 EI sizel
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI sizel
 EI ltree
 EI root
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI sizel
 EI ltree
 EI s01
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI sizel
 EI ltree
 EI n
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI sizel
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI sizel
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI sizel
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI sizel
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI sizel
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI sizel
 EI ltree
 EI s
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI sizel
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI sizel
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI sizel
 EI ltree
 EI apply int_gen  (, dummy )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI sizel
 EI ltree
 EI s0
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI sizel
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI sizel
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI sizel
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI sizel
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI sizel
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI sizel
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI sizel
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI s
 EI ltree
 EI sizer
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI s
 EI ltree
 EI sizel
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI s
 EI ltree
 EI root
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI s
 EI ltree
 EI s01
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI s
 EI ltree
 EI n
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI s
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI s
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI s
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI s
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI s
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI s
 EI ltree
 EI s
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI s
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI s
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI s
 EI ltree
 EI apply int_gen  (, dummy )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI s
 EI ltree
 EI s0
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI s
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI s
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI s
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI s
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI s
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI s
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI s
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI apply int_gen  (, dummy )
 EI ltree
 EI sizer
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI apply int_gen  (, dummy )
 EI ltree
 EI sizel
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI apply int_gen  (, dummy )
 EI ltree
 EI root
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI apply int_gen  (, dummy )
 EI ltree
 EI s01
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI apply int_gen  (, dummy )
 EI ltree
 EI n
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI apply int_gen  (, dummy )
 EI ltree
 EI s
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply int_gen  (, dummy )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI apply int_gen  (, dummy )
 EI ltree
 EI s0
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI s0
 EI ltree
 EI sizer
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI s0
 EI ltree
 EI sizel
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI s0
 EI ltree
 EI root
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI s0
 EI ltree
 EI s01
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI s0
 EI ltree
 EI n
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI s0
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI s0
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI s0
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI s0
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI s0
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI s0
 EI ltree
 EI s
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI s0
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI s0
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI s0
 EI ltree
 EI apply int_gen  (, dummy )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI s0
 EI ltree
 EI s0
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI s0
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI s0
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI s0
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI s0
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI s0
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI s0
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI s0
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI apply int_gen  (, dummy )
 EI ltree
 EI sizer
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI apply int_gen  (, dummy )
 EI ltree
 EI sizel
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI apply int_gen  (, dummy )
 EI ltree
 EI root
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI apply int_gen  (, dummy )
 EI ltree
 EI s01
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI apply int_gen  (, dummy )
 EI ltree
 EI n
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI apply int_gen  (, dummy )
 EI ltree
 EI s
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply int_gen  (, dummy )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI apply int_gen  (, dummy )
 EI ltree
 EI s0
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, s0 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, apply int_gen  (, dummy ) )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, s )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, s01 )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, root )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, sizel )
 EI rtree
 Possible Arg Options 
 EI apply subs  (, s01 )
 EI apply int_gen  (, dummy )
 EI ltree
 EI apply subs  (, sizer )
 EI rtree
 Show f (ei, e2, ....en) Case
 Finding Already seen tree for apply node  (, _lbv0 ), root ), ltree ), sizer ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), root ), ltree ), sizer ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), root ), ltree ), sizer ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument root :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  root > 0
 	,   root = 0>d 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument sizer :: {v:Ty_int | true} | true
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((_lbv0) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                                          
# of Final Z3 expressions 20
 Final solver 
 (declare-sort T1671)
(declare-fun |0| () Int)
(declare-fun tlen (T1671) Int)
(declare-fun v () T1671)
(declare-fun _lbv0 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T1671)
(declare-fun sizel () Int)
(declare-fun ltree () T1671)
(declare-fun root () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T1671)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u449 Int)
         (var_u448 Int)
         (var_u447 Int)
         (var_u446 Int)
         (var_u445 Int)
         (var_u444 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u446 (+ _lbv0 1)) (= (tlen v) var_u446))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u449 (+ _lbv0 1)) (= (tlen v) var_u449))))))
(assert (not (forall ((var_u450 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), root ), ltree ), sizer ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), root ), ltree ), sizel ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), root ), ltree ), sizel ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), root ), ltree ), sizel ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument root :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  root > 0
 	,   root = 0>d 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument sizel :: {v:Ty_int | true} | true
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((_lbv0) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                                          
# of Final Z3 expressions 20
 Final solver 
 (declare-sort T1677)
(declare-fun |0| () Int)
(declare-fun tlen (T1677) Int)
(declare-fun v () T1677)
(declare-fun _lbv0 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T1677)
(declare-fun sizel () Int)
(declare-fun ltree () T1677)
(declare-fun root () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T1677)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u456 Int)
         (var_u455 Int)
         (var_u454 Int)
         (var_u453 Int)
         (var_u452 Int)
         (var_u451 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u453 (+ _lbv0 1)) (= (tlen v) var_u453))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u456 (+ _lbv0 1)) (= (tlen v) var_u456))))))
(assert (not (forall ((var_u457 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), root ), ltree ), sizel ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), root ), ltree ), root ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), root ), ltree ), root ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), root ), ltree ), root ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument root :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  root > 0
 	,   root = 0>d 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument root :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  root > 0
 	,   root = 0>d 
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((_lbv0) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                                                     
# of Final Z3 expressions 22
 Final solver 
 (declare-sort T1683)
(declare-fun |0| () Int)
(declare-fun tlen (T1683) Int)
(declare-fun v () T1683)
(declare-fun _lbv0 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T1683)
(declare-fun root () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T1683)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T1683)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u463 Int)
         (var_u462 Int)
         (var_u461 Int)
         (var_u460 Int)
         (var_u459 Int)
         (var_u458 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u460 (+ _lbv0 1)) (= (tlen v) var_u460))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (or (> root |0|) (= root |0|))
         (= (tlen rtree) sizer)
         (=> (= var_u463 (+ _lbv0 1)) (= (tlen v) var_u463))))))
(assert (not (forall ((var_u464 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), root ), ltree ), root ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), root ), ltree ), s01 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), root ), ltree ), s01 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), root ), ltree ), s01 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument root :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  root > 0
 	,   root = 0>d 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument s01 :: {v:Ty_int | 
 	 Conj <c true
 	 , s0 > v >c } | 
 	 Conj <c true
 	 , s0 > s01 >c 
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((_lbv0) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                                               
# of Final Z3 expressions 20
 Final solver 
 (declare-sort T1689)
(declare-fun |0| () Int)
(declare-fun tlen (T1689) Int)
(declare-fun v () T1689)
(declare-fun _lbv0 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T1689)
(declare-fun s01 () Int)
(declare-fun s0 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T1689)
(declare-fun root () Int)
(declare-fun var_v3 () Bool)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T1689)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u470 Int)
         (var_u469 Int)
         (var_u468 Int)
         (var_u467 Int)
         (var_u466 Int)
         (var_u465 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u467 (+ _lbv0 1)) (= (tlen v) var_u467))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (> s0 s01)
         (= (tlen rtree) sizer)
         (=> (= var_u470 (+ _lbv0 1)) (= (tlen v) var_u470))))))
(assert (not (forall ((var_u471 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), root ), ltree ), s01 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), root ), ltree ), n ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), root ), ltree ), n ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), root ), ltree ), n ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument root :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  root > 0
 	,   root = 0>d 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument n :: {v:Ty_int | true} | true
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((_lbv0) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                                          
# of Final Z3 expressions 20
 Final solver 
 (declare-sort T1695)
(declare-fun |0| () Int)
(declare-fun tlen (T1695) Int)
(declare-fun v () T1695)
(declare-fun _lbv0 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T1695)
(declare-fun sizel () Int)
(declare-fun ltree () T1695)
(declare-fun root () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T1695)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u477 Int)
         (var_u476 Int)
         (var_u475 Int)
         (var_u474 Int)
         (var_u473 Int)
         (var_u472 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u474 (+ _lbv0 1)) (= (tlen v) var_u474))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u477 (+ _lbv0 1)) (= (tlen v) var_u477))))))
(assert (not (forall ((var_u478 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), root ), ltree ), n ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), root ), ltree ), _lbv10 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), root ), ltree ), apply subs  (, sizel ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), root ), ltree ), _lbv10 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument root :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  root > 0
 	,   root = 0>d 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv10 :: {v:Ty_int | (v) ==((sizel) -- (1))} | (_lbv10) ==((sizel) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((_lbv0) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                                          
# of Final Z3 expressions 20
 Final solver 
 (declare-sort T1701)
(declare-fun |0| () Int)
(declare-fun tlen (T1701) Int)
(declare-fun v () T1701)
(declare-fun _lbv0 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T1701)
(declare-fun sizel () Int)
(declare-fun _lbv10 () Int)
(declare-fun ltree () T1701)
(declare-fun root () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T1701)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u484 Int)
         (var_u483 Int)
         (var_u482 Int)
         (var_u481 Int)
         (var_u480 Int)
         (var_u479 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u481 (+ _lbv0 1)) (= (tlen v) var_u481))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= _lbv10 (- sizel 1))
         (= (tlen rtree) sizer)
         (=> (= var_u484 (+ _lbv0 1)) (= (tlen v) var_u484))))))
(assert (not (forall ((var_u485 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), root ), ltree ), _lbv10 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), root ), ltree ), _lbv9 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), root ), ltree ), apply subs  (, sizer ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), root ), ltree ), _lbv9 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument root :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  root > 0
 	,   root = 0>d 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv9 :: {v:Ty_int | (v) ==((sizer) -- (1))} | (_lbv9) ==((sizer) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((_lbv0) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                                          
# of Final Z3 expressions 20
 Final solver 
 (declare-sort T1707)
(declare-fun |0| () Int)
(declare-fun tlen (T1707) Int)
(declare-fun v () T1707)
(declare-fun _lbv0 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T1707)
(declare-fun _lbv9 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T1707)
(declare-fun root () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T1707)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u491 Int)
         (var_u490 Int)
         (var_u489 Int)
         (var_u488 Int)
         (var_u487 Int)
         (var_u486 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u488 (+ _lbv0 1)) (= (tlen v) var_u488))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= _lbv9 (- sizer 1))
         (= (tlen rtree) sizer)
         (=> (= var_u491 (+ _lbv0 1)) (= (tlen v) var_u491))))))
(assert (not (forall ((var_u492 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), root ), ltree ), _lbv9 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), root ), ltree ), _lbv8 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), root ), ltree ), apply subs  (, s ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), root ), ltree ), _lbv8 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument root :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  root > 0
 	,   root = 0>d 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv8 :: {v:Ty_int | (v) ==((s) -- (1))} | (_lbv8) ==((s) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((_lbv0) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                                          
# of Final Z3 expressions 20
 Final solver 
 (declare-sort T1713)
(declare-fun |0| () Int)
(declare-fun tlen (T1713) Int)
(declare-fun v () T1713)
(declare-fun _lbv0 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T1713)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T1713)
(declare-fun root () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T1713)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u498 Int)
         (var_u497 Int)
         (var_u496 Int)
         (var_u495 Int)
         (var_u494 Int)
         (var_u493 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u495 (+ _lbv0 1)) (= (tlen v) var_u495))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= _lbv8 (- s 1))
         (= (tlen rtree) sizer)
         (=> (= var_u498 (+ _lbv0 1)) (= (tlen v) var_u498))))))
(assert (not (forall ((var_u499 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), root ), ltree ), _lbv8 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), root ), ltree ), _lbv7 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), root ), ltree ), apply subs  (, s01 ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), root ), ltree ), _lbv7 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument root :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  root > 0
 	,   root = 0>d 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv7 :: {v:Ty_int | (v) ==((s01) -- (1))} | (_lbv7) ==((s01) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((_lbv0) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                                          
# of Final Z3 expressions 20
 Final solver 
 (declare-sort T1719)
(declare-fun |0| () Int)
(declare-fun tlen (T1719) Int)
(declare-fun v () T1719)
(declare-fun _lbv0 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T1719)
(declare-fun s01 () Int)
(declare-fun _lbv7 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T1719)
(declare-fun root () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T1719)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u505 Int)
         (var_u504 Int)
         (var_u503 Int)
         (var_u502 Int)
         (var_u501 Int)
         (var_u500 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u502 (+ _lbv0 1)) (= (tlen v) var_u502))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= _lbv7 (- s01 1))
         (= (tlen rtree) sizer)
         (=> (= var_u505 (+ _lbv0 1)) (= (tlen v) var_u505))))))
(assert (not (forall ((var_u506 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), root ), ltree ), _lbv7 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), root ), ltree ), _lbv6 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), root ), ltree ), apply subs  (, root ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), root ), ltree ), _lbv6 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument root :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  root > 0
 	,   root = 0>d 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv6 :: {v:Ty_int | (v) ==((root) -- (1))} | (_lbv6) ==((root) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((_lbv0) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                                          
# of Final Z3 expressions 20
 Final solver 
 (declare-sort T1725)
(declare-fun |0| () Int)
(declare-fun tlen (T1725) Int)
(declare-fun v () T1725)
(declare-fun _lbv0 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T1725)
(declare-fun root () Int)
(declare-fun _lbv6 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T1725)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T1725)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u512 Int)
         (var_u511 Int)
         (var_u510 Int)
         (var_u509 Int)
         (var_u508 Int)
         (var_u507 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u509 (+ _lbv0 1)) (= (tlen v) var_u509))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= _lbv6 (- root 1))
         (= (tlen rtree) sizer)
         (=> (= var_u512 (+ _lbv0 1)) (= (tlen v) var_u512))))))
(assert (not (forall ((var_u513 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), root ), ltree ), _lbv6 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), root ), ltree ), s ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), root ), ltree ), s ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), root ), ltree ), s ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument root :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  root > 0
 	,   root = 0>d 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument s :: {var_v0:Ty_int | true} | true
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((_lbv0) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                                          
# of Final Z3 expressions 20
 Final solver 
 (declare-sort T1731)
(declare-fun |0| () Int)
(declare-fun tlen (T1731) Int)
(declare-fun v () T1731)
(declare-fun _lbv0 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T1731)
(declare-fun sizel () Int)
(declare-fun ltree () T1731)
(declare-fun root () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T1731)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u519 Int)
         (var_u518 Int)
         (var_u517 Int)
         (var_u516 Int)
         (var_u515 Int)
         (var_u514 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u516 (+ _lbv0 1)) (= (tlen v) var_u516))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u519 (+ _lbv0 1)) (= (tlen v) var_u519))))))
(assert (not (forall ((var_u520 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), root ), ltree ), s ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), root ), ltree ), _lbv2 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), root ), ltree ), apply subs  (, apply int_gen  (, dummy ) ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), root ), ltree ), _lbv2 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument root :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  root > 0
 	,   root = 0>d 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv2 :: {v:Ty_int | (v) ==((_lbv0) -- (1))} | (_lbv2) ==((_lbv0) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((_lbv0) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                                          
# of Final Z3 expressions 20
 Final solver 
 (declare-sort T1737)
(declare-fun |0| () Int)
(declare-fun tlen (T1737) Int)
(declare-fun v () T1737)
(declare-fun _lbv0 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T1737)
(declare-fun _lbv2 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T1737)
(declare-fun root () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T1737)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u526 Int)
         (var_u525 Int)
         (var_u524 Int)
         (var_u523 Int)
         (var_u522 Int)
         (var_u521 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u523 (+ _lbv0 1)) (= (tlen v) var_u523))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= _lbv2 (- _lbv0 1))
         (= (tlen rtree) sizer)
         (=> (= var_u526 (+ _lbv0 1)) (= (tlen v) var_u526))))))
(assert (not (forall ((var_u527 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), root ), ltree ), _lbv2 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), root ), ltree ), _lbv1 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), root ), ltree ), apply subs  (, s0 ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), root ), ltree ), _lbv1 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument root :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  root > 0
 	,   root = 0>d 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((_lbv0) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                                          
# of Final Z3 expressions 20
 Final solver 
 (declare-sort T1743)
(declare-fun |0| () Int)
(declare-fun tlen (T1743) Int)
(declare-fun v () T1743)
(declare-fun _lbv0 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T1743)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T1743)
(declare-fun root () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T1743)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u533 Int)
         (var_u532 Int)
         (var_u531 Int)
         (var_u530 Int)
         (var_u529 Int)
         (var_u528 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u530 (+ _lbv0 1)) (= (tlen v) var_u530))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= _lbv1 (- s0 1))
         (= (tlen rtree) sizer)
         (=> (= var_u533 (+ _lbv0 1)) (= (tlen v) var_u533))))))
(assert (not (forall ((var_u534 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), root ), ltree ), _lbv1 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), root ), ltree ), _lbv0 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), root ), ltree ), apply int_gen  (, dummy ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), root ), ltree ), _lbv0 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument root :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  root > 0
 	,   root = 0>d 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((_lbv0) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                                                     
# of Final Z3 expressions 22
 Final solver 
 (declare-sort T1749)
(declare-fun |0| () Int)
(declare-fun tlen (T1749) Int)
(declare-fun v () T1749)
(declare-fun _lbv0 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T1749)
(declare-fun sizel () Int)
(declare-fun ltree () T1749)
(declare-fun root () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T1749)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u540 Int)
         (var_u539 Int)
         (var_u538 Int)
         (var_u537 Int)
         (var_u536 Int)
         (var_u535 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u537 (+ _lbv0 1)) (= (tlen v) var_u537))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen rtree) sizer)
         (=> (= var_u540 (+ _lbv0 1)) (= (tlen v) var_u540))))))
(assert (not (forall ((var_u541 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), root ), ltree ), _lbv0 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), root ), ltree ), s0 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), root ), ltree ), s0 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), root ), ltree ), s0 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument root :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  root > 0
 	,   root = 0>d 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument s0 :: {v:Ty_int | true} | true
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((_lbv0) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                                          
# of Final Z3 expressions 20
 Final solver 
 (declare-sort T1755)
(declare-fun |0| () Int)
(declare-fun tlen (T1755) Int)
(declare-fun v () T1755)
(declare-fun _lbv0 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T1755)
(declare-fun sizel () Int)
(declare-fun ltree () T1755)
(declare-fun root () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T1755)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u547 Int)
         (var_u546 Int)
         (var_u545 Int)
         (var_u544 Int)
         (var_u543 Int)
         (var_u542 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u544 (+ _lbv0 1)) (= (tlen v) var_u544))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u547 (+ _lbv0 1)) (= (tlen v) var_u547))))))
(assert (not (forall ((var_u548 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), root ), ltree ), s0 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), root ), ltree ), _lbv1 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), root ), ltree ), apply subs  (, s0 ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), root ), ltree ), _lbv1 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument root :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  root > 0
 	,   root = 0>d 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((_lbv0) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                                          
# of Final Z3 expressions 20
 Final solver 
 (declare-sort T1761)
(declare-fun |0| () Int)
(declare-fun tlen (T1761) Int)
(declare-fun v () T1761)
(declare-fun _lbv0 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T1761)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T1761)
(declare-fun root () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T1761)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u554 Int)
         (var_u553 Int)
         (var_u552 Int)
         (var_u551 Int)
         (var_u550 Int)
         (var_u549 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u551 (+ _lbv0 1)) (= (tlen v) var_u551))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= _lbv1 (- s0 1))
         (= (tlen rtree) sizer)
         (=> (= var_u554 (+ _lbv0 1)) (= (tlen v) var_u554))))))
(assert (not (forall ((var_u555 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), root ), ltree ), _lbv1 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), root ), ltree ), _lbv2 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), root ), ltree ), apply subs  (, apply int_gen  (, dummy ) ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), root ), ltree ), _lbv2 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument root :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  root > 0
 	,   root = 0>d 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv2 :: {v:Ty_int | (v) ==((_lbv0) -- (1))} | (_lbv2) ==((_lbv0) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((_lbv0) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                                          
# of Final Z3 expressions 20
 Final solver 
 (declare-sort T1767)
(declare-fun |0| () Int)
(declare-fun tlen (T1767) Int)
(declare-fun v () T1767)
(declare-fun _lbv0 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T1767)
(declare-fun _lbv2 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T1767)
(declare-fun root () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T1767)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u561 Int)
         (var_u560 Int)
         (var_u559 Int)
         (var_u558 Int)
         (var_u557 Int)
         (var_u556 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u558 (+ _lbv0 1)) (= (tlen v) var_u558))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= _lbv2 (- _lbv0 1))
         (= (tlen rtree) sizer)
         (=> (= var_u561 (+ _lbv0 1)) (= (tlen v) var_u561))))))
(assert (not (forall ((var_u562 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), root ), ltree ), _lbv2 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), root ), ltree ), _lbv8 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), root ), ltree ), apply subs  (, s ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), root ), ltree ), _lbv8 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument root :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  root > 0
 	,   root = 0>d 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv8 :: {v:Ty_int | (v) ==((s) -- (1))} | (_lbv8) ==((s) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((_lbv0) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                                          
# of Final Z3 expressions 20
 Final solver 
 (declare-sort T1773)
(declare-fun |0| () Int)
(declare-fun tlen (T1773) Int)
(declare-fun v () T1773)
(declare-fun _lbv0 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T1773)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T1773)
(declare-fun root () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T1773)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u568 Int)
         (var_u567 Int)
         (var_u566 Int)
         (var_u565 Int)
         (var_u564 Int)
         (var_u563 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u565 (+ _lbv0 1)) (= (tlen v) var_u565))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= _lbv8 (- s 1))
         (= (tlen rtree) sizer)
         (=> (= var_u568 (+ _lbv0 1)) (= (tlen v) var_u568))))))
(assert (not (forall ((var_u569 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), root ), ltree ), _lbv8 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), root ), ltree ), _lbv7 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), root ), ltree ), apply subs  (, s01 ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), root ), ltree ), _lbv7 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument root :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  root > 0
 	,   root = 0>d 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv7 :: {v:Ty_int | (v) ==((s01) -- (1))} | (_lbv7) ==((s01) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((_lbv0) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                                          
# of Final Z3 expressions 20
 Final solver 
 (declare-sort T1779)
(declare-fun |0| () Int)
(declare-fun tlen (T1779) Int)
(declare-fun v () T1779)
(declare-fun _lbv0 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T1779)
(declare-fun s01 () Int)
(declare-fun _lbv7 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T1779)
(declare-fun root () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T1779)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u575 Int)
         (var_u574 Int)
         (var_u573 Int)
         (var_u572 Int)
         (var_u571 Int)
         (var_u570 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u572 (+ _lbv0 1)) (= (tlen v) var_u572))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= _lbv7 (- s01 1))
         (= (tlen rtree) sizer)
         (=> (= var_u575 (+ _lbv0 1)) (= (tlen v) var_u575))))))
(assert (not (forall ((var_u576 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), root ), ltree ), _lbv7 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), root ), ltree ), _lbv6 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), root ), ltree ), apply subs  (, root ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), root ), ltree ), _lbv6 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument root :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  root > 0
 	,   root = 0>d 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv6 :: {v:Ty_int | (v) ==((root) -- (1))} | (_lbv6) ==((root) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((_lbv0) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                                          
# of Final Z3 expressions 20
 Final solver 
 (declare-sort T1785)
(declare-fun |0| () Int)
(declare-fun tlen (T1785) Int)
(declare-fun v () T1785)
(declare-fun _lbv0 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T1785)
(declare-fun root () Int)
(declare-fun _lbv6 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T1785)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T1785)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u582 Int)
         (var_u581 Int)
         (var_u580 Int)
         (var_u579 Int)
         (var_u578 Int)
         (var_u577 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u579 (+ _lbv0 1)) (= (tlen v) var_u579))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= _lbv6 (- root 1))
         (= (tlen rtree) sizer)
         (=> (= var_u582 (+ _lbv0 1)) (= (tlen v) var_u582))))))
(assert (not (forall ((var_u583 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), root ), ltree ), _lbv6 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), root ), ltree ), _lbv10 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), root ), ltree ), apply subs  (, sizel ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), root ), ltree ), _lbv10 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument root :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  root > 0
 	,   root = 0>d 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv10 :: {v:Ty_int | (v) ==((sizel) -- (1))} | (_lbv10) ==((sizel) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((_lbv0) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                                          
# of Final Z3 expressions 20
 Final solver 
 (declare-sort T1791)
(declare-fun |0| () Int)
(declare-fun tlen (T1791) Int)
(declare-fun v () T1791)
(declare-fun _lbv0 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T1791)
(declare-fun sizel () Int)
(declare-fun _lbv10 () Int)
(declare-fun ltree () T1791)
(declare-fun root () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T1791)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u589 Int)
         (var_u588 Int)
         (var_u587 Int)
         (var_u586 Int)
         (var_u585 Int)
         (var_u584 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u586 (+ _lbv0 1)) (= (tlen v) var_u586))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= _lbv10 (- sizel 1))
         (= (tlen rtree) sizer)
         (=> (= var_u589 (+ _lbv0 1)) (= (tlen v) var_u589))))))
(assert (not (forall ((var_u590 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), root ), ltree ), _lbv10 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), root ), ltree ), _lbv9 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), root ), ltree ), apply subs  (, sizer ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), root ), ltree ), _lbv9 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument root :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  root > 0
 	,   root = 0>d 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv9 :: {v:Ty_int | (v) ==((sizer) -- (1))} | (_lbv9) ==((sizer) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((_lbv0) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                                          
# of Final Z3 expressions 20
 Final solver 
 (declare-sort T1797)
(declare-fun |0| () Int)
(declare-fun tlen (T1797) Int)
(declare-fun v () T1797)
(declare-fun _lbv0 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T1797)
(declare-fun _lbv9 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T1797)
(declare-fun root () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T1797)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u596 Int)
         (var_u595 Int)
         (var_u594 Int)
         (var_u593 Int)
         (var_u592 Int)
         (var_u591 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u593 (+ _lbv0 1)) (= (tlen v) var_u593))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= _lbv9 (- sizer 1))
         (= (tlen rtree) sizer)
         (=> (= var_u596 (+ _lbv0 1)) (= (tlen v) var_u596))))))
(assert (not (forall ((var_u597 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), root ), ltree ), _lbv9 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), n ), ltree ), sizer ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), n ), ltree ), sizer ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), n ), ltree ), sizer ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument n :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument sizer :: {v:Ty_int | true} | true
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((n) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T1803)
(declare-fun |0| () Int)
(declare-fun tlen (T1803) Int)
(declare-fun v () T1803)
(declare-fun n () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T1803)
(declare-fun sizel () Int)
(declare-fun ltree () T1803)
(declare-fun _lbv0 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T1803)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u603 Int)
         (var_u602 Int)
         (var_u601 Int)
         (var_u600 Int)
         (var_u599 Int)
         (var_u598 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u600 (+ n 1)) (= (tlen v) var_u600))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u603 (+ n 1)) (= (tlen v) var_u603))))))
(assert (not (forall ((var_u604 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), n ), ltree ), sizer ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), n ), ltree ), sizel ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), n ), ltree ), sizel ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), n ), ltree ), sizel ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument n :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument sizel :: {v:Ty_int | true} | true
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((n) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T1809)
(declare-fun |0| () Int)
(declare-fun tlen (T1809) Int)
(declare-fun v () T1809)
(declare-fun n () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T1809)
(declare-fun sizel () Int)
(declare-fun ltree () T1809)
(declare-fun _lbv0 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T1809)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u610 Int)
         (var_u609 Int)
         (var_u608 Int)
         (var_u607 Int)
         (var_u606 Int)
         (var_u605 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u607 (+ n 1)) (= (tlen v) var_u607))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u610 (+ n 1)) (= (tlen v) var_u610))))))
(assert (not (forall ((var_u611 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), n ), ltree ), sizel ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), n ), ltree ), root ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), n ), ltree ), root ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), n ), ltree ), root ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument n :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument root :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  root > 0
 	,   root = 0>d 
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((n) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                                          
# of Final Z3 expressions 20
 Final solver 
 (declare-sort T1815)
(declare-fun |0| () Int)
(declare-fun tlen (T1815) Int)
(declare-fun v () T1815)
(declare-fun n () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T1815)
(declare-fun root () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T1815)
(declare-fun _lbv0 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T1815)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u617 Int)
         (var_u616 Int)
         (var_u615 Int)
         (var_u614 Int)
         (var_u613 Int)
         (var_u612 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u614 (+ n 1)) (= (tlen v) var_u614))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (or (> root |0|) (= root |0|))
         (= (tlen rtree) sizer)
         (=> (= var_u617 (+ n 1)) (= (tlen v) var_u617))))))
(assert (not (forall ((var_u618 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), n ), ltree ), root ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), n ), ltree ), s01 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), n ), ltree ), s01 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), n ), ltree ), s01 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument n :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument s01 :: {v:Ty_int | 
 	 Conj <c true
 	 , s0 > v >c } | 
 	 Conj <c true
 	 , s0 > s01 >c 
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((n) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                                    
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T1821)
(declare-fun |0| () Int)
(declare-fun tlen (T1821) Int)
(declare-fun v () T1821)
(declare-fun n () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T1821)
(declare-fun s01 () Int)
(declare-fun s0 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T1821)
(declare-fun _lbv0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T1821)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u624 Int)
         (var_u623 Int)
         (var_u622 Int)
         (var_u621 Int)
         (var_u620 Int)
         (var_u619 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u621 (+ n 1)) (= (tlen v) var_u621))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (> s0 s01)
         (= (tlen rtree) sizer)
         (=> (= var_u624 (+ n 1)) (= (tlen v) var_u624))))))
(assert (not (forall ((var_u625 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), n ), ltree ), s01 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), n ), ltree ), n ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), n ), ltree ), n ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), n ), ltree ), n ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument n :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument n :: {v:Ty_int | true} | true
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((n) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T1827)
(declare-fun |0| () Int)
(declare-fun tlen (T1827) Int)
(declare-fun v () T1827)
(declare-fun n () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T1827)
(declare-fun sizel () Int)
(declare-fun ltree () T1827)
(declare-fun _lbv0 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T1827)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u631 Int)
         (var_u630 Int)
         (var_u629 Int)
         (var_u628 Int)
         (var_u627 Int)
         (var_u626 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u628 (+ n 1)) (= (tlen v) var_u628))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u631 (+ n 1)) (= (tlen v) var_u631))))))
(assert (not (forall ((var_u632 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), n ), ltree ), n ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), n ), ltree ), _lbv10 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), n ), ltree ), apply subs  (, sizel ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), n ), ltree ), _lbv10 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument n :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv10 :: {v:Ty_int | (v) ==((sizel) -- (1))} | (_lbv10) ==((sizel) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((n) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T1833)
(declare-fun |0| () Int)
(declare-fun tlen (T1833) Int)
(declare-fun v () T1833)
(declare-fun n () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T1833)
(declare-fun sizel () Int)
(declare-fun _lbv10 () Int)
(declare-fun ltree () T1833)
(declare-fun _lbv0 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T1833)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u638 Int)
         (var_u637 Int)
         (var_u636 Int)
         (var_u635 Int)
         (var_u634 Int)
         (var_u633 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u635 (+ n 1)) (= (tlen v) var_u635))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= _lbv10 (- sizel 1))
         (= (tlen rtree) sizer)
         (=> (= var_u638 (+ n 1)) (= (tlen v) var_u638))))))
(assert (not (forall ((var_u639 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), n ), ltree ), _lbv10 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), n ), ltree ), _lbv9 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), n ), ltree ), apply subs  (, sizer ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), n ), ltree ), _lbv9 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument n :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv9 :: {v:Ty_int | (v) ==((sizer) -- (1))} | (_lbv9) ==((sizer) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((n) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T1839)
(declare-fun |0| () Int)
(declare-fun tlen (T1839) Int)
(declare-fun v () T1839)
(declare-fun n () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T1839)
(declare-fun _lbv9 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T1839)
(declare-fun _lbv0 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T1839)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u645 Int)
         (var_u644 Int)
         (var_u643 Int)
         (var_u642 Int)
         (var_u641 Int)
         (var_u640 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u642 (+ n 1)) (= (tlen v) var_u642))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= _lbv9 (- sizer 1))
         (= (tlen rtree) sizer)
         (=> (= var_u645 (+ n 1)) (= (tlen v) var_u645))))))
(assert (not (forall ((var_u646 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), n ), ltree ), _lbv9 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), n ), ltree ), _lbv8 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), n ), ltree ), apply subs  (, s ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), n ), ltree ), _lbv8 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument n :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv8 :: {v:Ty_int | (v) ==((s) -- (1))} | (_lbv8) ==((s) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((n) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T1845)
(declare-fun |0| () Int)
(declare-fun tlen (T1845) Int)
(declare-fun v () T1845)
(declare-fun n () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T1845)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T1845)
(declare-fun _lbv0 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T1845)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u652 Int)
         (var_u651 Int)
         (var_u650 Int)
         (var_u649 Int)
         (var_u648 Int)
         (var_u647 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u649 (+ n 1)) (= (tlen v) var_u649))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= _lbv8 (- s 1))
         (= (tlen rtree) sizer)
         (=> (= var_u652 (+ n 1)) (= (tlen v) var_u652))))))
(assert (not (forall ((var_u653 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), n ), ltree ), _lbv8 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), n ), ltree ), _lbv7 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), n ), ltree ), apply subs  (, s01 ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), n ), ltree ), _lbv7 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument n :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv7 :: {v:Ty_int | (v) ==((s01) -- (1))} | (_lbv7) ==((s01) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((n) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T1851)
(declare-fun |0| () Int)
(declare-fun tlen (T1851) Int)
(declare-fun v () T1851)
(declare-fun n () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T1851)
(declare-fun s01 () Int)
(declare-fun _lbv7 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T1851)
(declare-fun _lbv0 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T1851)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u659 Int)
         (var_u658 Int)
         (var_u657 Int)
         (var_u656 Int)
         (var_u655 Int)
         (var_u654 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u656 (+ n 1)) (= (tlen v) var_u656))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= _lbv7 (- s01 1))
         (= (tlen rtree) sizer)
         (=> (= var_u659 (+ n 1)) (= (tlen v) var_u659))))))
(assert (not (forall ((var_u660 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), n ), ltree ), _lbv7 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), n ), ltree ), _lbv6 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), n ), ltree ), apply subs  (, root ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), n ), ltree ), _lbv6 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument n :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv6 :: {v:Ty_int | (v) ==((root) -- (1))} | (_lbv6) ==((root) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((n) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T1857)
(declare-fun |0| () Int)
(declare-fun tlen (T1857) Int)
(declare-fun v () T1857)
(declare-fun n () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T1857)
(declare-fun root () Int)
(declare-fun _lbv6 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T1857)
(declare-fun _lbv0 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T1857)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u666 Int)
         (var_u665 Int)
         (var_u664 Int)
         (var_u663 Int)
         (var_u662 Int)
         (var_u661 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u663 (+ n 1)) (= (tlen v) var_u663))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= _lbv6 (- root 1))
         (= (tlen rtree) sizer)
         (=> (= var_u666 (+ n 1)) (= (tlen v) var_u666))))))
(assert (not (forall ((var_u667 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), n ), ltree ), _lbv6 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), n ), ltree ), s ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), n ), ltree ), s ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), n ), ltree ), s ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument n :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument s :: {var_v0:Ty_int | true} | true
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((n) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T1863)
(declare-fun |0| () Int)
(declare-fun tlen (T1863) Int)
(declare-fun v () T1863)
(declare-fun n () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T1863)
(declare-fun sizel () Int)
(declare-fun ltree () T1863)
(declare-fun _lbv0 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T1863)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u673 Int)
         (var_u672 Int)
         (var_u671 Int)
         (var_u670 Int)
         (var_u669 Int)
         (var_u668 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u670 (+ n 1)) (= (tlen v) var_u670))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u673 (+ n 1)) (= (tlen v) var_u673))))))
(assert (not (forall ((var_u674 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), n ), ltree ), s ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), n ), ltree ), _lbv2 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), n ), ltree ), apply subs  (, apply int_gen  (, dummy ) ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), n ), ltree ), _lbv2 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument n :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv2 :: {v:Ty_int | (v) ==((_lbv0) -- (1))} | (_lbv2) ==((_lbv0) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((n) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T1869)
(declare-fun |0| () Int)
(declare-fun tlen (T1869) Int)
(declare-fun v () T1869)
(declare-fun n () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T1869)
(declare-fun _lbv0 () Int)
(declare-fun _lbv2 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T1869)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T1869)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u680 Int)
         (var_u679 Int)
         (var_u678 Int)
         (var_u677 Int)
         (var_u676 Int)
         (var_u675 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u677 (+ n 1)) (= (tlen v) var_u677))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= _lbv2 (- _lbv0 1))
         (= (tlen rtree) sizer)
         (=> (= var_u680 (+ n 1)) (= (tlen v) var_u680))))))
(assert (not (forall ((var_u681 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), n ), ltree ), _lbv2 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), n ), ltree ), _lbv1 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), n ), ltree ), apply subs  (, s0 ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), n ), ltree ), _lbv1 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument n :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((n) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T1875)
(declare-fun |0| () Int)
(declare-fun tlen (T1875) Int)
(declare-fun v () T1875)
(declare-fun n () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T1875)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T1875)
(declare-fun _lbv0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T1875)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u687 Int)
         (var_u686 Int)
         (var_u685 Int)
         (var_u684 Int)
         (var_u683 Int)
         (var_u682 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u684 (+ n 1)) (= (tlen v) var_u684))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= _lbv1 (- s0 1))
         (= (tlen rtree) sizer)
         (=> (= var_u687 (+ n 1)) (= (tlen v) var_u687))))))
(assert (not (forall ((var_u688 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), n ), ltree ), _lbv1 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), n ), ltree ), _lbv0 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), n ), ltree ), apply int_gen  (, dummy ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), n ), ltree ), _lbv0 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument n :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((n) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                                          
# of Final Z3 expressions 20
 Final solver 
 (declare-sort T1881)
(declare-fun |0| () Int)
(declare-fun tlen (T1881) Int)
(declare-fun v () T1881)
(declare-fun n () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T1881)
(declare-fun _lbv0 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T1881)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T1881)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u694 Int)
         (var_u693 Int)
         (var_u692 Int)
         (var_u691 Int)
         (var_u690 Int)
         (var_u689 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u691 (+ n 1)) (= (tlen v) var_u691))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen rtree) sizer)
         (=> (= var_u694 (+ n 1)) (= (tlen v) var_u694))))))
(assert (not (forall ((var_u695 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), n ), ltree ), _lbv0 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), n ), ltree ), s0 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), n ), ltree ), s0 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), n ), ltree ), s0 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument n :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument s0 :: {v:Ty_int | true} | true
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((n) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T1887)
(declare-fun |0| () Int)
(declare-fun tlen (T1887) Int)
(declare-fun v () T1887)
(declare-fun n () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T1887)
(declare-fun sizel () Int)
(declare-fun ltree () T1887)
(declare-fun _lbv0 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T1887)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u701 Int)
         (var_u700 Int)
         (var_u699 Int)
         (var_u698 Int)
         (var_u697 Int)
         (var_u696 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u698 (+ n 1)) (= (tlen v) var_u698))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u701 (+ n 1)) (= (tlen v) var_u701))))))
(assert (not (forall ((var_u702 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), n ), ltree ), s0 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), n ), ltree ), _lbv1 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), n ), ltree ), apply subs  (, s0 ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), n ), ltree ), _lbv1 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument n :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((n) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T1893)
(declare-fun |0| () Int)
(declare-fun tlen (T1893) Int)
(declare-fun v () T1893)
(declare-fun n () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T1893)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T1893)
(declare-fun _lbv0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T1893)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u708 Int)
         (var_u707 Int)
         (var_u706 Int)
         (var_u705 Int)
         (var_u704 Int)
         (var_u703 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u705 (+ n 1)) (= (tlen v) var_u705))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= _lbv1 (- s0 1))
         (= (tlen rtree) sizer)
         (=> (= var_u708 (+ n 1)) (= (tlen v) var_u708))))))
(assert (not (forall ((var_u709 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), n ), ltree ), _lbv1 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), n ), ltree ), _lbv2 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), n ), ltree ), apply subs  (, apply int_gen  (, dummy ) ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), n ), ltree ), _lbv2 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument n :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv2 :: {v:Ty_int | (v) ==((_lbv0) -- (1))} | (_lbv2) ==((_lbv0) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((n) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T1899)
(declare-fun |0| () Int)
(declare-fun tlen (T1899) Int)
(declare-fun v () T1899)
(declare-fun n () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T1899)
(declare-fun _lbv0 () Int)
(declare-fun _lbv2 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T1899)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T1899)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u715 Int)
         (var_u714 Int)
         (var_u713 Int)
         (var_u712 Int)
         (var_u711 Int)
         (var_u710 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u712 (+ n 1)) (= (tlen v) var_u712))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= _lbv2 (- _lbv0 1))
         (= (tlen rtree) sizer)
         (=> (= var_u715 (+ n 1)) (= (tlen v) var_u715))))))
(assert (not (forall ((var_u716 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), n ), ltree ), _lbv2 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), n ), ltree ), _lbv8 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), n ), ltree ), apply subs  (, s ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), n ), ltree ), _lbv8 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument n :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv8 :: {v:Ty_int | (v) ==((s) -- (1))} | (_lbv8) ==((s) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((n) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T1905)
(declare-fun |0| () Int)
(declare-fun tlen (T1905) Int)
(declare-fun v () T1905)
(declare-fun n () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T1905)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T1905)
(declare-fun _lbv0 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T1905)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u722 Int)
         (var_u721 Int)
         (var_u720 Int)
         (var_u719 Int)
         (var_u718 Int)
         (var_u717 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u719 (+ n 1)) (= (tlen v) var_u719))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= _lbv8 (- s 1))
         (= (tlen rtree) sizer)
         (=> (= var_u722 (+ n 1)) (= (tlen v) var_u722))))))
(assert (not (forall ((var_u723 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), n ), ltree ), _lbv8 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), n ), ltree ), _lbv7 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), n ), ltree ), apply subs  (, s01 ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), n ), ltree ), _lbv7 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument n :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv7 :: {v:Ty_int | (v) ==((s01) -- (1))} | (_lbv7) ==((s01) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((n) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T1911)
(declare-fun |0| () Int)
(declare-fun tlen (T1911) Int)
(declare-fun v () T1911)
(declare-fun n () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T1911)
(declare-fun s01 () Int)
(declare-fun _lbv7 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T1911)
(declare-fun _lbv0 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T1911)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u729 Int)
         (var_u728 Int)
         (var_u727 Int)
         (var_u726 Int)
         (var_u725 Int)
         (var_u724 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u726 (+ n 1)) (= (tlen v) var_u726))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= _lbv7 (- s01 1))
         (= (tlen rtree) sizer)
         (=> (= var_u729 (+ n 1)) (= (tlen v) var_u729))))))
(assert (not (forall ((var_u730 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), n ), ltree ), _lbv7 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), n ), ltree ), _lbv6 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), n ), ltree ), apply subs  (, root ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), n ), ltree ), _lbv6 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument n :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv6 :: {v:Ty_int | (v) ==((root) -- (1))} | (_lbv6) ==((root) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((n) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T1917)
(declare-fun |0| () Int)
(declare-fun tlen (T1917) Int)
(declare-fun v () T1917)
(declare-fun n () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T1917)
(declare-fun root () Int)
(declare-fun _lbv6 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T1917)
(declare-fun _lbv0 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T1917)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u736 Int)
         (var_u735 Int)
         (var_u734 Int)
         (var_u733 Int)
         (var_u732 Int)
         (var_u731 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u733 (+ n 1)) (= (tlen v) var_u733))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= _lbv6 (- root 1))
         (= (tlen rtree) sizer)
         (=> (= var_u736 (+ n 1)) (= (tlen v) var_u736))))))
(assert (not (forall ((var_u737 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), n ), ltree ), _lbv6 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), n ), ltree ), _lbv10 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), n ), ltree ), apply subs  (, sizel ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), n ), ltree ), _lbv10 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument n :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv10 :: {v:Ty_int | (v) ==((sizel) -- (1))} | (_lbv10) ==((sizel) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((n) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T1923)
(declare-fun |0| () Int)
(declare-fun tlen (T1923) Int)
(declare-fun v () T1923)
(declare-fun n () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T1923)
(declare-fun sizel () Int)
(declare-fun _lbv10 () Int)
(declare-fun ltree () T1923)
(declare-fun _lbv0 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T1923)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u743 Int)
         (var_u742 Int)
         (var_u741 Int)
         (var_u740 Int)
         (var_u739 Int)
         (var_u738 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u740 (+ n 1)) (= (tlen v) var_u740))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= _lbv10 (- sizel 1))
         (= (tlen rtree) sizer)
         (=> (= var_u743 (+ n 1)) (= (tlen v) var_u743))))))
(assert (not (forall ((var_u744 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), n ), ltree ), _lbv10 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), n ), ltree ), _lbv9 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), n ), ltree ), apply subs  (, sizer ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), n ), ltree ), _lbv9 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument n :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv9 :: {v:Ty_int | (v) ==((sizer) -- (1))} | (_lbv9) ==((sizer) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((n) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T1929)
(declare-fun |0| () Int)
(declare-fun tlen (T1929) Int)
(declare-fun v () T1929)
(declare-fun n () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T1929)
(declare-fun _lbv9 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T1929)
(declare-fun _lbv0 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T1929)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u750 Int)
         (var_u749 Int)
         (var_u748 Int)
         (var_u747 Int)
         (var_u746 Int)
         (var_u745 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u747 (+ n 1)) (= (tlen v) var_u747))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= _lbv9 (- sizer 1))
         (= (tlen rtree) sizer)
         (=> (= var_u750 (+ n 1)) (= (tlen v) var_u750))))))
(assert (not (forall ((var_u751 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), n ), ltree ), _lbv9 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), s01 ), ltree ), sizer ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), s01 ), ltree ), sizer ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), s01 ), ltree ), sizer ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument s01 :: {v:Ty_int | 
 	 Conj <c true
 	 , s0 > v >c } | 
 	 Conj <c true
 	 , s0 > s01 >c 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument sizer :: {v:Ty_int | true} | true
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((s01) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                                    
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T1935)
(declare-fun |0| () Int)
(declare-fun tlen (T1935) Int)
(declare-fun v () T1935)
(declare-fun s01 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T1935)
(declare-fun sizel () Int)
(declare-fun ltree () T1935)
(declare-fun s0 () Int)
(declare-fun _lbv0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T1935)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u757 Int)
         (var_u756 Int)
         (var_u755 Int)
         (var_u754 Int)
         (var_u753 Int)
         (var_u752 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u754 (+ s01 1)) (= (tlen v) var_u754))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (> s0 s01)
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u757 (+ s01 1)) (= (tlen v) var_u757))))))
(assert (not (forall ((var_u758 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), s01 ), ltree ), sizer ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), s01 ), ltree ), sizel ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), s01 ), ltree ), sizel ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), s01 ), ltree ), sizel ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument s01 :: {v:Ty_int | 
 	 Conj <c true
 	 , s0 > v >c } | 
 	 Conj <c true
 	 , s0 > s01 >c 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument sizel :: {v:Ty_int | true} | true
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((s01) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                                    
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T1941)
(declare-fun |0| () Int)
(declare-fun tlen (T1941) Int)
(declare-fun v () T1941)
(declare-fun s01 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T1941)
(declare-fun sizel () Int)
(declare-fun ltree () T1941)
(declare-fun s0 () Int)
(declare-fun _lbv0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T1941)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u764 Int)
         (var_u763 Int)
         (var_u762 Int)
         (var_u761 Int)
         (var_u760 Int)
         (var_u759 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u761 (+ s01 1)) (= (tlen v) var_u761))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (> s0 s01)
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u764 (+ s01 1)) (= (tlen v) var_u764))))))
(assert (not (forall ((var_u765 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), s01 ), ltree ), sizel ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), s01 ), ltree ), root ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), s01 ), ltree ), root ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), s01 ), ltree ), root ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument s01 :: {v:Ty_int | 
 	 Conj <c true
 	 , s0 > v >c } | 
 	 Conj <c true
 	 , s0 > s01 >c 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument root :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  root > 0
 	,   root = 0>d 
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((s01) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                                               
# of Final Z3 expressions 20
 Final solver 
 (declare-sort T1947)
(declare-fun |0| () Int)
(declare-fun tlen (T1947) Int)
(declare-fun v () T1947)
(declare-fun s01 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T1947)
(declare-fun root () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T1947)
(declare-fun s0 () Int)
(declare-fun _lbv0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T1947)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u771 Int)
         (var_u770 Int)
         (var_u769 Int)
         (var_u768 Int)
         (var_u767 Int)
         (var_u766 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u768 (+ s01 1)) (= (tlen v) var_u768))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (> s0 s01)
         (= (tlen ltree) sizel)
         (or (> root |0|) (= root |0|))
         (= (tlen rtree) sizer)
         (=> (= var_u771 (+ s01 1)) (= (tlen v) var_u771))))))
(assert (not (forall ((var_u772 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), s01 ), ltree ), root ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), s01 ), ltree ), s01 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), s01 ), ltree ), s01 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), s01 ), ltree ), s01 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument s01 :: {v:Ty_int | 
 	 Conj <c true
 	 , s0 > v >c } | 
 	 Conj <c true
 	 , s0 > s01 >c 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument s01 :: {v:Ty_int | 
 	 Conj <c true
 	 , s0 > v >c } | 
 	 Conj <c true
 	 , s0 > s01 >c 
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((s01) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                                         
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T1953)
(declare-fun |0| () Int)
(declare-fun tlen (T1953) Int)
(declare-fun v () T1953)
(declare-fun s01 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T1953)
(declare-fun s0 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T1953)
(declare-fun _lbv0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T1953)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u778 Int)
         (var_u777 Int)
         (var_u776 Int)
         (var_u775 Int)
         (var_u774 Int)
         (var_u773 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u775 (+ s01 1)) (= (tlen v) var_u775))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (> s0 s01)
         (= (tlen ltree) sizel)
         (> s0 s01)
         (= (tlen rtree) sizer)
         (=> (= var_u778 (+ s01 1)) (= (tlen v) var_u778))))))
(assert (not (forall ((var_u779 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), s01 ), ltree ), s01 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), s01 ), ltree ), n ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), s01 ), ltree ), n ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), s01 ), ltree ), n ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument s01 :: {v:Ty_int | 
 	 Conj <c true
 	 , s0 > v >c } | 
 	 Conj <c true
 	 , s0 > s01 >c 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument n :: {v:Ty_int | true} | true
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((s01) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                                    
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T1959)
(declare-fun |0| () Int)
(declare-fun tlen (T1959) Int)
(declare-fun v () T1959)
(declare-fun s01 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T1959)
(declare-fun sizel () Int)
(declare-fun ltree () T1959)
(declare-fun s0 () Int)
(declare-fun _lbv0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T1959)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u785 Int)
         (var_u784 Int)
         (var_u783 Int)
         (var_u782 Int)
         (var_u781 Int)
         (var_u780 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u782 (+ s01 1)) (= (tlen v) var_u782))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (> s0 s01)
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u785 (+ s01 1)) (= (tlen v) var_u785))))))
(assert (not (forall ((var_u786 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), s01 ), ltree ), n ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), s01 ), ltree ), _lbv10 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), s01 ), ltree ), apply subs  (, sizel ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), s01 ), ltree ), _lbv10 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument s01 :: {v:Ty_int | 
 	 Conj <c true
 	 , s0 > v >c } | 
 	 Conj <c true
 	 , s0 > s01 >c 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv10 :: {v:Ty_int | (v) ==((sizel) -- (1))} | (_lbv10) ==((sizel) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((s01) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                                    
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T1965)
(declare-fun |0| () Int)
(declare-fun tlen (T1965) Int)
(declare-fun v () T1965)
(declare-fun s01 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T1965)
(declare-fun sizel () Int)
(declare-fun _lbv10 () Int)
(declare-fun ltree () T1965)
(declare-fun s0 () Int)
(declare-fun _lbv0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T1965)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u792 Int)
         (var_u791 Int)
         (var_u790 Int)
         (var_u789 Int)
         (var_u788 Int)
         (var_u787 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u789 (+ s01 1)) (= (tlen v) var_u789))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (> s0 s01)
         (= (tlen ltree) sizel)
         (= _lbv10 (- sizel 1))
         (= (tlen rtree) sizer)
         (=> (= var_u792 (+ s01 1)) (= (tlen v) var_u792))))))
(assert (not (forall ((var_u793 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), s01 ), ltree ), _lbv10 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), s01 ), ltree ), _lbv9 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), s01 ), ltree ), apply subs  (, sizer ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), s01 ), ltree ), _lbv9 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument s01 :: {v:Ty_int | 
 	 Conj <c true
 	 , s0 > v >c } | 
 	 Conj <c true
 	 , s0 > s01 >c 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv9 :: {v:Ty_int | (v) ==((sizer) -- (1))} | (_lbv9) ==((sizer) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((s01) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                                    
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T1971)
(declare-fun |0| () Int)
(declare-fun tlen (T1971) Int)
(declare-fun v () T1971)
(declare-fun s01 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T1971)
(declare-fun _lbv9 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T1971)
(declare-fun s0 () Int)
(declare-fun _lbv0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun _lbv10 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T1971)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u799 Int)
         (var_u798 Int)
         (var_u797 Int)
         (var_u796 Int)
         (var_u795 Int)
         (var_u794 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u796 (+ s01 1)) (= (tlen v) var_u796))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (> s0 s01)
         (= (tlen ltree) sizel)
         (= _lbv9 (- sizer 1))
         (= (tlen rtree) sizer)
         (=> (= var_u799 (+ s01 1)) (= (tlen v) var_u799))))))
(assert (not (forall ((var_u800 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), s01 ), ltree ), _lbv9 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), s01 ), ltree ), _lbv8 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), s01 ), ltree ), apply subs  (, s ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), s01 ), ltree ), _lbv8 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument s01 :: {v:Ty_int | 
 	 Conj <c true
 	 , s0 > v >c } | 
 	 Conj <c true
 	 , s0 > s01 >c 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv8 :: {v:Ty_int | (v) ==((s) -- (1))} | (_lbv8) ==((s) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((s01) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                                    
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T1977)
(declare-fun |0| () Int)
(declare-fun tlen (T1977) Int)
(declare-fun v () T1977)
(declare-fun s01 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T1977)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T1977)
(declare-fun s0 () Int)
(declare-fun _lbv0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T1977)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u806 Int)
         (var_u805 Int)
         (var_u804 Int)
         (var_u803 Int)
         (var_u802 Int)
         (var_u801 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u803 (+ s01 1)) (= (tlen v) var_u803))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (> s0 s01)
         (= (tlen ltree) sizel)
         (= _lbv8 (- s 1))
         (= (tlen rtree) sizer)
         (=> (= var_u806 (+ s01 1)) (= (tlen v) var_u806))))))
(assert (not (forall ((var_u807 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), s01 ), ltree ), _lbv8 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), s01 ), ltree ), _lbv7 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), s01 ), ltree ), apply subs  (, s01 ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), s01 ), ltree ), _lbv7 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument s01 :: {v:Ty_int | 
 	 Conj <c true
 	 , s0 > v >c } | 
 	 Conj <c true
 	 , s0 > s01 >c 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv7 :: {v:Ty_int | (v) ==((s01) -- (1))} | (_lbv7) ==((s01) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((s01) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                                    
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T1983)
(declare-fun |0| () Int)
(declare-fun tlen (T1983) Int)
(declare-fun v () T1983)
(declare-fun s01 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T1983)
(declare-fun _lbv7 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T1983)
(declare-fun s0 () Int)
(declare-fun _lbv0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T1983)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u813 Int)
         (var_u812 Int)
         (var_u811 Int)
         (var_u810 Int)
         (var_u809 Int)
         (var_u808 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u810 (+ s01 1)) (= (tlen v) var_u810))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (> s0 s01)
         (= (tlen ltree) sizel)
         (= _lbv7 (- s01 1))
         (= (tlen rtree) sizer)
         (=> (= var_u813 (+ s01 1)) (= (tlen v) var_u813))))))
(assert (not (forall ((var_u814 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), s01 ), ltree ), _lbv7 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), s01 ), ltree ), _lbv6 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), s01 ), ltree ), apply subs  (, root ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), s01 ), ltree ), _lbv6 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument s01 :: {v:Ty_int | 
 	 Conj <c true
 	 , s0 > v >c } | 
 	 Conj <c true
 	 , s0 > s01 >c 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv6 :: {v:Ty_int | (v) ==((root) -- (1))} | (_lbv6) ==((root) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((s01) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                                    
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T1989)
(declare-fun |0| () Int)
(declare-fun tlen (T1989) Int)
(declare-fun v () T1989)
(declare-fun s01 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T1989)
(declare-fun root () Int)
(declare-fun _lbv6 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T1989)
(declare-fun s0 () Int)
(declare-fun _lbv0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T1989)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u820 Int)
         (var_u819 Int)
         (var_u818 Int)
         (var_u817 Int)
         (var_u816 Int)
         (var_u815 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u817 (+ s01 1)) (= (tlen v) var_u817))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (> s0 s01)
         (= (tlen ltree) sizel)
         (= _lbv6 (- root 1))
         (= (tlen rtree) sizer)
         (=> (= var_u820 (+ s01 1)) (= (tlen v) var_u820))))))
(assert (not (forall ((var_u821 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), s01 ), ltree ), _lbv6 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), s01 ), ltree ), s ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), s01 ), ltree ), s ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), s01 ), ltree ), s ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument s01 :: {v:Ty_int | 
 	 Conj <c true
 	 , s0 > v >c } | 
 	 Conj <c true
 	 , s0 > s01 >c 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument s :: {var_v0:Ty_int | true} | true
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((s01) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                                    
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T1995)
(declare-fun |0| () Int)
(declare-fun tlen (T1995) Int)
(declare-fun v () T1995)
(declare-fun s01 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T1995)
(declare-fun sizel () Int)
(declare-fun ltree () T1995)
(declare-fun s0 () Int)
(declare-fun _lbv0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T1995)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u827 Int)
         (var_u826 Int)
         (var_u825 Int)
         (var_u824 Int)
         (var_u823 Int)
         (var_u822 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u824 (+ s01 1)) (= (tlen v) var_u824))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (> s0 s01)
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u827 (+ s01 1)) (= (tlen v) var_u827))))))
(assert (not (forall ((var_u828 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), s01 ), ltree ), s ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), s01 ), ltree ), _lbv2 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), s01 ), ltree ), apply subs  (, apply int_gen  (, dummy ) ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), s01 ), ltree ), _lbv2 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument s01 :: {v:Ty_int | 
 	 Conj <c true
 	 , s0 > v >c } | 
 	 Conj <c true
 	 , s0 > s01 >c 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv2 :: {v:Ty_int | (v) ==((_lbv0) -- (1))} | (_lbv2) ==((_lbv0) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((s01) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                                    
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T2001)
(declare-fun |0| () Int)
(declare-fun tlen (T2001) Int)
(declare-fun v () T2001)
(declare-fun s01 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2001)
(declare-fun _lbv0 () Int)
(declare-fun _lbv2 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T2001)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2001)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u834 Int)
         (var_u833 Int)
         (var_u832 Int)
         (var_u831 Int)
         (var_u830 Int)
         (var_u829 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u831 (+ s01 1)) (= (tlen v) var_u831))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (> s0 s01)
         (= (tlen ltree) sizel)
         (= _lbv2 (- _lbv0 1))
         (= (tlen rtree) sizer)
         (=> (= var_u834 (+ s01 1)) (= (tlen v) var_u834))))))
(assert (not (forall ((var_u835 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), s01 ), ltree ), _lbv2 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), s01 ), ltree ), _lbv1 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), s01 ), ltree ), apply subs  (, s0 ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), s01 ), ltree ), _lbv1 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument s01 :: {v:Ty_int | 
 	 Conj <c true
 	 , s0 > v >c } | 
 	 Conj <c true
 	 , s0 > s01 >c 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((s01) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                                    
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T2007)
(declare-fun |0| () Int)
(declare-fun tlen (T2007) Int)
(declare-fun v () T2007)
(declare-fun s01 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2007)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T2007)
(declare-fun _lbv0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2007)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u841 Int)
         (var_u840 Int)
         (var_u839 Int)
         (var_u838 Int)
         (var_u837 Int)
         (var_u836 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u838 (+ s01 1)) (= (tlen v) var_u838))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (> s0 s01)
         (= (tlen ltree) sizel)
         (= _lbv1 (- s0 1))
         (= (tlen rtree) sizer)
         (=> (= var_u841 (+ s01 1)) (= (tlen v) var_u841))))))
(assert (not (forall ((var_u842 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), s01 ), ltree ), _lbv1 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), s01 ), ltree ), _lbv0 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), s01 ), ltree ), apply int_gen  (, dummy ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), s01 ), ltree ), _lbv0 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument s01 :: {v:Ty_int | 
 	 Conj <c true
 	 , s0 > v >c } | 
 	 Conj <c true
 	 , s0 > s01 >c 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((s01) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                                               
# of Final Z3 expressions 20
 Final solver 
 (declare-sort T2013)
(declare-fun |0| () Int)
(declare-fun tlen (T2013) Int)
(declare-fun v () T2013)
(declare-fun s01 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2013)
(declare-fun _lbv0 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T2013)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2013)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u848 Int)
         (var_u847 Int)
         (var_u846 Int)
         (var_u845 Int)
         (var_u844 Int)
         (var_u843 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u845 (+ s01 1)) (= (tlen v) var_u845))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (> s0 s01)
         (= (tlen ltree) sizel)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen rtree) sizer)
         (=> (= var_u848 (+ s01 1)) (= (tlen v) var_u848))))))
(assert (not (forall ((var_u849 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), s01 ), ltree ), _lbv0 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), s01 ), ltree ), s0 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), s01 ), ltree ), s0 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), s01 ), ltree ), s0 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument s01 :: {v:Ty_int | 
 	 Conj <c true
 	 , s0 > v >c } | 
 	 Conj <c true
 	 , s0 > s01 >c 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument s0 :: {v:Ty_int | true} | true
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((s01) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                                    
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T2019)
(declare-fun |0| () Int)
(declare-fun tlen (T2019) Int)
(declare-fun v () T2019)
(declare-fun s01 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2019)
(declare-fun sizel () Int)
(declare-fun ltree () T2019)
(declare-fun s0 () Int)
(declare-fun _lbv0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2019)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u855 Int)
         (var_u854 Int)
         (var_u853 Int)
         (var_u852 Int)
         (var_u851 Int)
         (var_u850 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u852 (+ s01 1)) (= (tlen v) var_u852))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (> s0 s01)
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u855 (+ s01 1)) (= (tlen v) var_u855))))))
(assert (not (forall ((var_u856 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), s01 ), ltree ), s0 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), s01 ), ltree ), _lbv1 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), s01 ), ltree ), apply subs  (, s0 ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), s01 ), ltree ), _lbv1 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument s01 :: {v:Ty_int | 
 	 Conj <c true
 	 , s0 > v >c } | 
 	 Conj <c true
 	 , s0 > s01 >c 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((s01) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                                    
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T2025)
(declare-fun |0| () Int)
(declare-fun tlen (T2025) Int)
(declare-fun v () T2025)
(declare-fun s01 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2025)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T2025)
(declare-fun _lbv0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2025)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u862 Int)
         (var_u861 Int)
         (var_u860 Int)
         (var_u859 Int)
         (var_u858 Int)
         (var_u857 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u859 (+ s01 1)) (= (tlen v) var_u859))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (> s0 s01)
         (= (tlen ltree) sizel)
         (= _lbv1 (- s0 1))
         (= (tlen rtree) sizer)
         (=> (= var_u862 (+ s01 1)) (= (tlen v) var_u862))))))
(assert (not (forall ((var_u863 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), s01 ), ltree ), _lbv1 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), s01 ), ltree ), _lbv2 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), s01 ), ltree ), apply subs  (, apply int_gen  (, dummy ) ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), s01 ), ltree ), _lbv2 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument s01 :: {v:Ty_int | 
 	 Conj <c true
 	 , s0 > v >c } | 
 	 Conj <c true
 	 , s0 > s01 >c 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv2 :: {v:Ty_int | (v) ==((_lbv0) -- (1))} | (_lbv2) ==((_lbv0) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((s01) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                                    
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T2031)
(declare-fun |0| () Int)
(declare-fun tlen (T2031) Int)
(declare-fun v () T2031)
(declare-fun s01 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2031)
(declare-fun _lbv0 () Int)
(declare-fun _lbv2 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T2031)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2031)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u869 Int)
         (var_u868 Int)
         (var_u867 Int)
         (var_u866 Int)
         (var_u865 Int)
         (var_u864 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u866 (+ s01 1)) (= (tlen v) var_u866))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (> s0 s01)
         (= (tlen ltree) sizel)
         (= _lbv2 (- _lbv0 1))
         (= (tlen rtree) sizer)
         (=> (= var_u869 (+ s01 1)) (= (tlen v) var_u869))))))
(assert (not (forall ((var_u870 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), s01 ), ltree ), _lbv2 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), s01 ), ltree ), _lbv8 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), s01 ), ltree ), apply subs  (, s ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), s01 ), ltree ), _lbv8 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument s01 :: {v:Ty_int | 
 	 Conj <c true
 	 , s0 > v >c } | 
 	 Conj <c true
 	 , s0 > s01 >c 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv8 :: {v:Ty_int | (v) ==((s) -- (1))} | (_lbv8) ==((s) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((s01) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                                    
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T2037)
(declare-fun |0| () Int)
(declare-fun tlen (T2037) Int)
(declare-fun v () T2037)
(declare-fun s01 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2037)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T2037)
(declare-fun s0 () Int)
(declare-fun _lbv0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2037)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u876 Int)
         (var_u875 Int)
         (var_u874 Int)
         (var_u873 Int)
         (var_u872 Int)
         (var_u871 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u873 (+ s01 1)) (= (tlen v) var_u873))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (> s0 s01)
         (= (tlen ltree) sizel)
         (= _lbv8 (- s 1))
         (= (tlen rtree) sizer)
         (=> (= var_u876 (+ s01 1)) (= (tlen v) var_u876))))))
(assert (not (forall ((var_u877 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), s01 ), ltree ), _lbv8 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), s01 ), ltree ), _lbv7 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), s01 ), ltree ), apply subs  (, s01 ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), s01 ), ltree ), _lbv7 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument s01 :: {v:Ty_int | 
 	 Conj <c true
 	 , s0 > v >c } | 
 	 Conj <c true
 	 , s0 > s01 >c 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv7 :: {v:Ty_int | (v) ==((s01) -- (1))} | (_lbv7) ==((s01) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((s01) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                                    
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T2043)
(declare-fun |0| () Int)
(declare-fun tlen (T2043) Int)
(declare-fun v () T2043)
(declare-fun s01 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2043)
(declare-fun _lbv7 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T2043)
(declare-fun s0 () Int)
(declare-fun _lbv0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2043)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u883 Int)
         (var_u882 Int)
         (var_u881 Int)
         (var_u880 Int)
         (var_u879 Int)
         (var_u878 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u880 (+ s01 1)) (= (tlen v) var_u880))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (> s0 s01)
         (= (tlen ltree) sizel)
         (= _lbv7 (- s01 1))
         (= (tlen rtree) sizer)
         (=> (= var_u883 (+ s01 1)) (= (tlen v) var_u883))))))
(assert (not (forall ((var_u884 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), s01 ), ltree ), _lbv7 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), s01 ), ltree ), _lbv6 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), s01 ), ltree ), apply subs  (, root ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), s01 ), ltree ), _lbv6 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument s01 :: {v:Ty_int | 
 	 Conj <c true
 	 , s0 > v >c } | 
 	 Conj <c true
 	 , s0 > s01 >c 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv6 :: {v:Ty_int | (v) ==((root) -- (1))} | (_lbv6) ==((root) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((s01) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                                    
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T2049)
(declare-fun |0| () Int)
(declare-fun tlen (T2049) Int)
(declare-fun v () T2049)
(declare-fun s01 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2049)
(declare-fun root () Int)
(declare-fun _lbv6 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T2049)
(declare-fun s0 () Int)
(declare-fun _lbv0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2049)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u890 Int)
         (var_u889 Int)
         (var_u888 Int)
         (var_u887 Int)
         (var_u886 Int)
         (var_u885 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u887 (+ s01 1)) (= (tlen v) var_u887))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (> s0 s01)
         (= (tlen ltree) sizel)
         (= _lbv6 (- root 1))
         (= (tlen rtree) sizer)
         (=> (= var_u890 (+ s01 1)) (= (tlen v) var_u890))))))
(assert (not (forall ((var_u891 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), s01 ), ltree ), _lbv6 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), s01 ), ltree ), _lbv10 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), s01 ), ltree ), apply subs  (, sizel ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), s01 ), ltree ), _lbv10 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument s01 :: {v:Ty_int | 
 	 Conj <c true
 	 , s0 > v >c } | 
 	 Conj <c true
 	 , s0 > s01 >c 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv10 :: {v:Ty_int | (v) ==((sizel) -- (1))} | (_lbv10) ==((sizel) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((s01) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                                    
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T2055)
(declare-fun |0| () Int)
(declare-fun tlen (T2055) Int)
(declare-fun v () T2055)
(declare-fun s01 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2055)
(declare-fun sizel () Int)
(declare-fun _lbv10 () Int)
(declare-fun ltree () T2055)
(declare-fun s0 () Int)
(declare-fun _lbv0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2055)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u897 Int)
         (var_u896 Int)
         (var_u895 Int)
         (var_u894 Int)
         (var_u893 Int)
         (var_u892 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u894 (+ s01 1)) (= (tlen v) var_u894))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (> s0 s01)
         (= (tlen ltree) sizel)
         (= _lbv10 (- sizel 1))
         (= (tlen rtree) sizer)
         (=> (= var_u897 (+ s01 1)) (= (tlen v) var_u897))))))
(assert (not (forall ((var_u898 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), s01 ), ltree ), _lbv10 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), s01 ), ltree ), _lbv9 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), s01 ), ltree ), apply subs  (, sizer ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), s01 ), ltree ), _lbv9 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument s01 :: {v:Ty_int | 
 	 Conj <c true
 	 , s0 > v >c } | 
 	 Conj <c true
 	 , s0 > s01 >c 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv9 :: {v:Ty_int | (v) ==((sizer) -- (1))} | (_lbv9) ==((sizer) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((s01) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                                    
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T2061)
(declare-fun |0| () Int)
(declare-fun tlen (T2061) Int)
(declare-fun v () T2061)
(declare-fun s01 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2061)
(declare-fun _lbv9 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T2061)
(declare-fun s0 () Int)
(declare-fun _lbv0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun _lbv10 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2061)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u904 Int)
         (var_u903 Int)
         (var_u902 Int)
         (var_u901 Int)
         (var_u900 Int)
         (var_u899 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u901 (+ s01 1)) (= (tlen v) var_u901))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (> s0 s01)
         (= (tlen ltree) sizel)
         (= _lbv9 (- sizer 1))
         (= (tlen rtree) sizer)
         (=> (= var_u904 (+ s01 1)) (= (tlen v) var_u904))))))
(assert (not (forall ((var_u905 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), s01 ), ltree ), _lbv9 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), sizer ), ltree ), sizer ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), sizer ), ltree ), sizer ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), sizer ), ltree ), sizer ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument sizer :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument sizer :: {v:Ty_int | true} | true
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((sizer) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T2067)
(declare-fun |0| () Int)
(declare-fun tlen (T2067) Int)
(declare-fun v () T2067)
(declare-fun sizer () Int)
(declare-fun rtree () T2067)
(declare-fun sizel () Int)
(declare-fun ltree () T2067)
(declare-fun _lbv0 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2067)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u911 Int)
         (var_u910 Int)
         (var_u909 Int)
         (var_u908 Int)
         (var_u907 Int)
         (var_u906 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u908 (+ sizer 1)) (= (tlen v) var_u908))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u911 (+ sizer 1)) (= (tlen v) var_u911))))))
(assert (not (forall ((var_u912 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), sizer ), ltree ), sizer ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), sizer ), ltree ), sizel ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), sizer ), ltree ), sizel ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), sizer ), ltree ), sizel ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument sizer :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument sizel :: {v:Ty_int | true} | true
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((sizer) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T2073)
(declare-fun |0| () Int)
(declare-fun tlen (T2073) Int)
(declare-fun v () T2073)
(declare-fun sizer () Int)
(declare-fun rtree () T2073)
(declare-fun sizel () Int)
(declare-fun ltree () T2073)
(declare-fun _lbv0 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2073)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u918 Int)
         (var_u917 Int)
         (var_u916 Int)
         (var_u915 Int)
         (var_u914 Int)
         (var_u913 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u915 (+ sizer 1)) (= (tlen v) var_u915))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u918 (+ sizer 1)) (= (tlen v) var_u918))))))
(assert (not (forall ((var_u919 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), sizer ), ltree ), sizel ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), sizer ), ltree ), root ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), sizer ), ltree ), root ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), sizer ), ltree ), root ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument sizer :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument root :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  root > 0
 	,   root = 0>d 
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((sizer) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                                          
# of Final Z3 expressions 20
 Final solver 
 (declare-sort T2079)
(declare-fun |0| () Int)
(declare-fun tlen (T2079) Int)
(declare-fun v () T2079)
(declare-fun sizer () Int)
(declare-fun rtree () T2079)
(declare-fun root () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T2079)
(declare-fun _lbv0 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2079)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u925 Int)
         (var_u924 Int)
         (var_u923 Int)
         (var_u922 Int)
         (var_u921 Int)
         (var_u920 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u922 (+ sizer 1)) (= (tlen v) var_u922))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (or (> root |0|) (= root |0|))
         (= (tlen rtree) sizer)
         (=> (= var_u925 (+ sizer 1)) (= (tlen v) var_u925))))))
(assert (not (forall ((var_u926 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), sizer ), ltree ), root ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), sizer ), ltree ), s01 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), sizer ), ltree ), s01 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), sizer ), ltree ), s01 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument sizer :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument s01 :: {v:Ty_int | 
 	 Conj <c true
 	 , s0 > v >c } | 
 	 Conj <c true
 	 , s0 > s01 >c 
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((sizer) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                                    
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T2085)
(declare-fun |0| () Int)
(declare-fun tlen (T2085) Int)
(declare-fun v () T2085)
(declare-fun sizer () Int)
(declare-fun rtree () T2085)
(declare-fun s01 () Int)
(declare-fun s0 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T2085)
(declare-fun _lbv0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2085)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u932 Int)
         (var_u931 Int)
         (var_u930 Int)
         (var_u929 Int)
         (var_u928 Int)
         (var_u927 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u929 (+ sizer 1)) (= (tlen v) var_u929))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (> s0 s01)
         (= (tlen rtree) sizer)
         (=> (= var_u932 (+ sizer 1)) (= (tlen v) var_u932))))))
(assert (not (forall ((var_u933 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), sizer ), ltree ), s01 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), sizer ), ltree ), n ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), sizer ), ltree ), n ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), sizer ), ltree ), n ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument sizer :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument n :: {v:Ty_int | true} | true
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((sizer) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T2091)
(declare-fun |0| () Int)
(declare-fun tlen (T2091) Int)
(declare-fun v () T2091)
(declare-fun sizer () Int)
(declare-fun rtree () T2091)
(declare-fun sizel () Int)
(declare-fun ltree () T2091)
(declare-fun _lbv0 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2091)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u939 Int)
         (var_u938 Int)
         (var_u937 Int)
         (var_u936 Int)
         (var_u935 Int)
         (var_u934 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u936 (+ sizer 1)) (= (tlen v) var_u936))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u939 (+ sizer 1)) (= (tlen v) var_u939))))))
(assert (not (forall ((var_u940 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), sizer ), ltree ), n ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), sizer ), ltree ), _lbv10 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), sizer ), ltree ), apply subs  (, sizel ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), sizer ), ltree ), _lbv10 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument sizer :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv10 :: {v:Ty_int | (v) ==((sizel) -- (1))} | (_lbv10) ==((sizel) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((sizer) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T2097)
(declare-fun |0| () Int)
(declare-fun tlen (T2097) Int)
(declare-fun v () T2097)
(declare-fun sizer () Int)
(declare-fun rtree () T2097)
(declare-fun sizel () Int)
(declare-fun _lbv10 () Int)
(declare-fun ltree () T2097)
(declare-fun _lbv0 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2097)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u946 Int)
         (var_u945 Int)
         (var_u944 Int)
         (var_u943 Int)
         (var_u942 Int)
         (var_u941 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u943 (+ sizer 1)) (= (tlen v) var_u943))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= _lbv10 (- sizel 1))
         (= (tlen rtree) sizer)
         (=> (= var_u946 (+ sizer 1)) (= (tlen v) var_u946))))))
(assert (not (forall ((var_u947 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), sizer ), ltree ), _lbv10 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), sizer ), ltree ), _lbv9 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), sizer ), ltree ), apply subs  (, sizer ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), sizer ), ltree ), _lbv9 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument sizer :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv9 :: {v:Ty_int | (v) ==((sizer) -- (1))} | (_lbv9) ==((sizer) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((sizer) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T2103)
(declare-fun |0| () Int)
(declare-fun tlen (T2103) Int)
(declare-fun v () T2103)
(declare-fun sizer () Int)
(declare-fun rtree () T2103)
(declare-fun _lbv9 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T2103)
(declare-fun _lbv0 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2103)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u953 Int)
         (var_u952 Int)
         (var_u951 Int)
         (var_u950 Int)
         (var_u949 Int)
         (var_u948 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u950 (+ sizer 1)) (= (tlen v) var_u950))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= _lbv9 (- sizer 1))
         (= (tlen rtree) sizer)
         (=> (= var_u953 (+ sizer 1)) (= (tlen v) var_u953))))))
(assert (not (forall ((var_u954 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), sizer ), ltree ), _lbv9 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), sizer ), ltree ), _lbv8 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), sizer ), ltree ), apply subs  (, s ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), sizer ), ltree ), _lbv8 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument sizer :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv8 :: {v:Ty_int | (v) ==((s) -- (1))} | (_lbv8) ==((s) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((sizer) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T2109)
(declare-fun |0| () Int)
(declare-fun tlen (T2109) Int)
(declare-fun v () T2109)
(declare-fun sizer () Int)
(declare-fun rtree () T2109)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T2109)
(declare-fun _lbv0 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2109)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u960 Int)
         (var_u959 Int)
         (var_u958 Int)
         (var_u957 Int)
         (var_u956 Int)
         (var_u955 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u957 (+ sizer 1)) (= (tlen v) var_u957))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= _lbv8 (- s 1))
         (= (tlen rtree) sizer)
         (=> (= var_u960 (+ sizer 1)) (= (tlen v) var_u960))))))
(assert (not (forall ((var_u961 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), sizer ), ltree ), _lbv8 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), sizer ), ltree ), _lbv7 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), sizer ), ltree ), apply subs  (, s01 ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), sizer ), ltree ), _lbv7 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument sizer :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv7 :: {v:Ty_int | (v) ==((s01) -- (1))} | (_lbv7) ==((s01) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((sizer) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T2115)
(declare-fun |0| () Int)
(declare-fun tlen (T2115) Int)
(declare-fun v () T2115)
(declare-fun sizer () Int)
(declare-fun rtree () T2115)
(declare-fun s01 () Int)
(declare-fun _lbv7 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T2115)
(declare-fun _lbv0 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2115)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u967 Int)
         (var_u966 Int)
         (var_u965 Int)
         (var_u964 Int)
         (var_u963 Int)
         (var_u962 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u964 (+ sizer 1)) (= (tlen v) var_u964))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= _lbv7 (- s01 1))
         (= (tlen rtree) sizer)
         (=> (= var_u967 (+ sizer 1)) (= (tlen v) var_u967))))))
(assert (not (forall ((var_u968 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), sizer ), ltree ), _lbv7 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), sizer ), ltree ), _lbv6 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), sizer ), ltree ), apply subs  (, root ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), sizer ), ltree ), _lbv6 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument sizer :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv6 :: {v:Ty_int | (v) ==((root) -- (1))} | (_lbv6) ==((root) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((sizer) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T2121)
(declare-fun |0| () Int)
(declare-fun tlen (T2121) Int)
(declare-fun v () T2121)
(declare-fun sizer () Int)
(declare-fun rtree () T2121)
(declare-fun root () Int)
(declare-fun _lbv6 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T2121)
(declare-fun _lbv0 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2121)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u974 Int)
         (var_u973 Int)
         (var_u972 Int)
         (var_u971 Int)
         (var_u970 Int)
         (var_u969 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u971 (+ sizer 1)) (= (tlen v) var_u971))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= _lbv6 (- root 1))
         (= (tlen rtree) sizer)
         (=> (= var_u974 (+ sizer 1)) (= (tlen v) var_u974))))))
(assert (not (forall ((var_u975 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), sizer ), ltree ), _lbv6 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), sizer ), ltree ), s ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), sizer ), ltree ), s ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), sizer ), ltree ), s ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument sizer :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument s :: {var_v0:Ty_int | true} | true
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((sizer) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T2127)
(declare-fun |0| () Int)
(declare-fun tlen (T2127) Int)
(declare-fun v () T2127)
(declare-fun sizer () Int)
(declare-fun rtree () T2127)
(declare-fun sizel () Int)
(declare-fun ltree () T2127)
(declare-fun _lbv0 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2127)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u981 Int)
         (var_u980 Int)
         (var_u979 Int)
         (var_u978 Int)
         (var_u977 Int)
         (var_u976 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u978 (+ sizer 1)) (= (tlen v) var_u978))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u981 (+ sizer 1)) (= (tlen v) var_u981))))))
(assert (not (forall ((var_u982 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), sizer ), ltree ), s ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), sizer ), ltree ), _lbv2 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), sizer ), ltree ), apply subs  (, apply int_gen  (, dummy ) ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), sizer ), ltree ), _lbv2 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument sizer :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv2 :: {v:Ty_int | (v) ==((_lbv0) -- (1))} | (_lbv2) ==((_lbv0) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((sizer) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T2133)
(declare-fun |0| () Int)
(declare-fun tlen (T2133) Int)
(declare-fun v () T2133)
(declare-fun sizer () Int)
(declare-fun rtree () T2133)
(declare-fun _lbv0 () Int)
(declare-fun _lbv2 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T2133)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2133)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u988 Int)
         (var_u987 Int)
         (var_u986 Int)
         (var_u985 Int)
         (var_u984 Int)
         (var_u983 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u985 (+ sizer 1)) (= (tlen v) var_u985))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= _lbv2 (- _lbv0 1))
         (= (tlen rtree) sizer)
         (=> (= var_u988 (+ sizer 1)) (= (tlen v) var_u988))))))
(assert (not (forall ((var_u989 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), sizer ), ltree ), _lbv2 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), sizer ), ltree ), _lbv1 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), sizer ), ltree ), apply subs  (, s0 ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), sizer ), ltree ), _lbv1 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument sizer :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((sizer) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T2139)
(declare-fun |0| () Int)
(declare-fun tlen (T2139) Int)
(declare-fun v () T2139)
(declare-fun sizer () Int)
(declare-fun rtree () T2139)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T2139)
(declare-fun _lbv0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2139)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u995 Int)
         (var_u994 Int)
         (var_u993 Int)
         (var_u992 Int)
         (var_u991 Int)
         (var_u990 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u992 (+ sizer 1)) (= (tlen v) var_u992))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= _lbv1 (- s0 1))
         (= (tlen rtree) sizer)
         (=> (= var_u995 (+ sizer 1)) (= (tlen v) var_u995))))))
(assert (not (forall ((var_u996 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), sizer ), ltree ), _lbv1 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), sizer ), ltree ), _lbv0 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), sizer ), ltree ), apply int_gen  (, dummy ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), sizer ), ltree ), _lbv0 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument sizer :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((sizer) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                                          
# of Final Z3 expressions 20
 Final solver 
 (declare-sort T2145)
(declare-fun |0| () Int)
(declare-fun tlen (T2145) Int)
(declare-fun v () T2145)
(declare-fun sizer () Int)
(declare-fun rtree () T2145)
(declare-fun _lbv0 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T2145)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2145)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1002 Int)
         (var_u1001 Int)
         (var_u1000 Int)
         (var_u999 Int)
         (var_u998 Int)
         (var_u997 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u999 (+ sizer 1)) (= (tlen v) var_u999))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen rtree) sizer)
         (=> (= var_u1002 (+ sizer 1)) (= (tlen v) var_u1002))))))
(assert (not (forall ((var_u1003 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), sizer ), ltree ), _lbv0 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), sizer ), ltree ), s0 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), sizer ), ltree ), s0 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), sizer ), ltree ), s0 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument sizer :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument s0 :: {v:Ty_int | true} | true
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((sizer) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T2151)
(declare-fun |0| () Int)
(declare-fun tlen (T2151) Int)
(declare-fun v () T2151)
(declare-fun sizer () Int)
(declare-fun rtree () T2151)
(declare-fun sizel () Int)
(declare-fun ltree () T2151)
(declare-fun _lbv0 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2151)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1009 Int)
         (var_u1008 Int)
         (var_u1007 Int)
         (var_u1006 Int)
         (var_u1005 Int)
         (var_u1004 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1006 (+ sizer 1)) (= (tlen v) var_u1006))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1009 (+ sizer 1)) (= (tlen v) var_u1009))))))
(assert (not (forall ((var_u1010 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), sizer ), ltree ), s0 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), sizer ), ltree ), _lbv1 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), sizer ), ltree ), apply subs  (, s0 ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), sizer ), ltree ), _lbv1 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument sizer :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((sizer) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T2157)
(declare-fun |0| () Int)
(declare-fun tlen (T2157) Int)
(declare-fun v () T2157)
(declare-fun sizer () Int)
(declare-fun rtree () T2157)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T2157)
(declare-fun _lbv0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2157)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1016 Int)
         (var_u1015 Int)
         (var_u1014 Int)
         (var_u1013 Int)
         (var_u1012 Int)
         (var_u1011 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1013 (+ sizer 1)) (= (tlen v) var_u1013))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= _lbv1 (- s0 1))
         (= (tlen rtree) sizer)
         (=> (= var_u1016 (+ sizer 1)) (= (tlen v) var_u1016))))))
(assert (not (forall ((var_u1017 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), sizer ), ltree ), _lbv1 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), sizer ), ltree ), _lbv2 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), sizer ), ltree ), apply subs  (, apply int_gen  (, dummy ) ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), sizer ), ltree ), _lbv2 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument sizer :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv2 :: {v:Ty_int | (v) ==((_lbv0) -- (1))} | (_lbv2) ==((_lbv0) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((sizer) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T2163)
(declare-fun |0| () Int)
(declare-fun tlen (T2163) Int)
(declare-fun v () T2163)
(declare-fun sizer () Int)
(declare-fun rtree () T2163)
(declare-fun _lbv0 () Int)
(declare-fun _lbv2 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T2163)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2163)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1023 Int)
         (var_u1022 Int)
         (var_u1021 Int)
         (var_u1020 Int)
         (var_u1019 Int)
         (var_u1018 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1020 (+ sizer 1)) (= (tlen v) var_u1020))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= _lbv2 (- _lbv0 1))
         (= (tlen rtree) sizer)
         (=> (= var_u1023 (+ sizer 1)) (= (tlen v) var_u1023))))))
(assert (not (forall ((var_u1024 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), sizer ), ltree ), _lbv2 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), sizer ), ltree ), _lbv8 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), sizer ), ltree ), apply subs  (, s ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), sizer ), ltree ), _lbv8 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument sizer :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv8 :: {v:Ty_int | (v) ==((s) -- (1))} | (_lbv8) ==((s) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((sizer) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T2169)
(declare-fun |0| () Int)
(declare-fun tlen (T2169) Int)
(declare-fun v () T2169)
(declare-fun sizer () Int)
(declare-fun rtree () T2169)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T2169)
(declare-fun _lbv0 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2169)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1030 Int)
         (var_u1029 Int)
         (var_u1028 Int)
         (var_u1027 Int)
         (var_u1026 Int)
         (var_u1025 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1027 (+ sizer 1)) (= (tlen v) var_u1027))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= _lbv8 (- s 1))
         (= (tlen rtree) sizer)
         (=> (= var_u1030 (+ sizer 1)) (= (tlen v) var_u1030))))))
(assert (not (forall ((var_u1031 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), sizer ), ltree ), _lbv8 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), sizer ), ltree ), _lbv7 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), sizer ), ltree ), apply subs  (, s01 ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), sizer ), ltree ), _lbv7 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument sizer :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv7 :: {v:Ty_int | (v) ==((s01) -- (1))} | (_lbv7) ==((s01) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((sizer) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T2175)
(declare-fun |0| () Int)
(declare-fun tlen (T2175) Int)
(declare-fun v () T2175)
(declare-fun sizer () Int)
(declare-fun rtree () T2175)
(declare-fun s01 () Int)
(declare-fun _lbv7 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T2175)
(declare-fun _lbv0 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2175)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1037 Int)
         (var_u1036 Int)
         (var_u1035 Int)
         (var_u1034 Int)
         (var_u1033 Int)
         (var_u1032 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1034 (+ sizer 1)) (= (tlen v) var_u1034))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= _lbv7 (- s01 1))
         (= (tlen rtree) sizer)
         (=> (= var_u1037 (+ sizer 1)) (= (tlen v) var_u1037))))))
(assert (not (forall ((var_u1038 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), sizer ), ltree ), _lbv7 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), sizer ), ltree ), _lbv6 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), sizer ), ltree ), apply subs  (, root ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), sizer ), ltree ), _lbv6 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument sizer :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv6 :: {v:Ty_int | (v) ==((root) -- (1))} | (_lbv6) ==((root) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((sizer) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T2181)
(declare-fun |0| () Int)
(declare-fun tlen (T2181) Int)
(declare-fun v () T2181)
(declare-fun sizer () Int)
(declare-fun rtree () T2181)
(declare-fun root () Int)
(declare-fun _lbv6 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T2181)
(declare-fun _lbv0 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2181)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1044 Int)
         (var_u1043 Int)
         (var_u1042 Int)
         (var_u1041 Int)
         (var_u1040 Int)
         (var_u1039 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1041 (+ sizer 1)) (= (tlen v) var_u1041))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= _lbv6 (- root 1))
         (= (tlen rtree) sizer)
         (=> (= var_u1044 (+ sizer 1)) (= (tlen v) var_u1044))))))
(assert (not (forall ((var_u1045 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), sizer ), ltree ), _lbv6 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), sizer ), ltree ), _lbv10 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), sizer ), ltree ), apply subs  (, sizel ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), sizer ), ltree ), _lbv10 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument sizer :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv10 :: {v:Ty_int | (v) ==((sizel) -- (1))} | (_lbv10) ==((sizel) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((sizer) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T2187)
(declare-fun |0| () Int)
(declare-fun tlen (T2187) Int)
(declare-fun v () T2187)
(declare-fun sizer () Int)
(declare-fun rtree () T2187)
(declare-fun sizel () Int)
(declare-fun _lbv10 () Int)
(declare-fun ltree () T2187)
(declare-fun _lbv0 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2187)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1051 Int)
         (var_u1050 Int)
         (var_u1049 Int)
         (var_u1048 Int)
         (var_u1047 Int)
         (var_u1046 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1048 (+ sizer 1)) (= (tlen v) var_u1048))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= _lbv10 (- sizel 1))
         (= (tlen rtree) sizer)
         (=> (= var_u1051 (+ sizer 1)) (= (tlen v) var_u1051))))))
(assert (not (forall ((var_u1052 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), sizer ), ltree ), _lbv10 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), sizer ), ltree ), _lbv9 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), sizer ), ltree ), apply subs  (, sizer ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), sizer ), ltree ), _lbv9 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument sizer :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv9 :: {v:Ty_int | (v) ==((sizer) -- (1))} | (_lbv9) ==((sizer) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((sizer) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T2193)
(declare-fun |0| () Int)
(declare-fun tlen (T2193) Int)
(declare-fun v () T2193)
(declare-fun sizer () Int)
(declare-fun rtree () T2193)
(declare-fun _lbv9 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T2193)
(declare-fun _lbv0 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2193)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1058 Int)
         (var_u1057 Int)
         (var_u1056 Int)
         (var_u1055 Int)
         (var_u1054 Int)
         (var_u1053 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1055 (+ sizer 1)) (= (tlen v) var_u1055))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= _lbv9 (- sizer 1))
         (= (tlen rtree) sizer)
         (=> (= var_u1058 (+ sizer 1)) (= (tlen v) var_u1058))))))
(assert (not (forall ((var_u1059 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), sizer ), ltree ), _lbv9 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), sizel ), ltree ), sizer ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), sizel ), ltree ), sizer ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), sizel ), ltree ), sizer ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument sizel :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument sizer :: {v:Ty_int | true} | true
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((sizel) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T2199)
(declare-fun |0| () Int)
(declare-fun tlen (T2199) Int)
(declare-fun v () T2199)
(declare-fun sizel () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2199)
(declare-fun ltree () T2199)
(declare-fun _lbv0 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2199)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1065 Int)
         (var_u1064 Int)
         (var_u1063 Int)
         (var_u1062 Int)
         (var_u1061 Int)
         (var_u1060 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1062 (+ sizel 1)) (= (tlen v) var_u1062))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1065 (+ sizel 1)) (= (tlen v) var_u1065))))))
(assert (not (forall ((var_u1066 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), sizel ), ltree ), sizer ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), sizel ), ltree ), sizel ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), sizel ), ltree ), sizel ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), sizel ), ltree ), sizel ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument sizel :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument sizel :: {v:Ty_int | true} | true
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((sizel) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T2205)
(declare-fun |0| () Int)
(declare-fun tlen (T2205) Int)
(declare-fun v () T2205)
(declare-fun sizel () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2205)
(declare-fun ltree () T2205)
(declare-fun _lbv0 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2205)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1072 Int)
         (var_u1071 Int)
         (var_u1070 Int)
         (var_u1069 Int)
         (var_u1068 Int)
         (var_u1067 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1069 (+ sizel 1)) (= (tlen v) var_u1069))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1072 (+ sizel 1)) (= (tlen v) var_u1072))))))
(assert (not (forall ((var_u1073 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), sizel ), ltree ), sizel ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), sizel ), ltree ), root ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), sizel ), ltree ), root ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), sizel ), ltree ), root ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument sizel :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument root :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  root > 0
 	,   root = 0>d 
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((sizel) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                                          
# of Final Z3 expressions 20
 Final solver 
 (declare-sort T2211)
(declare-fun |0| () Int)
(declare-fun tlen (T2211) Int)
(declare-fun v () T2211)
(declare-fun sizel () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2211)
(declare-fun root () Int)
(declare-fun ltree () T2211)
(declare-fun _lbv0 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2211)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1079 Int)
         (var_u1078 Int)
         (var_u1077 Int)
         (var_u1076 Int)
         (var_u1075 Int)
         (var_u1074 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1076 (+ sizel 1)) (= (tlen v) var_u1076))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (or (> root |0|) (= root |0|))
         (= (tlen rtree) sizer)
         (=> (= var_u1079 (+ sizel 1)) (= (tlen v) var_u1079))))))
(assert (not (forall ((var_u1080 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), sizel ), ltree ), root ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), sizel ), ltree ), s01 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), sizel ), ltree ), s01 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), sizel ), ltree ), s01 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument sizel :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument s01 :: {v:Ty_int | 
 	 Conj <c true
 	 , s0 > v >c } | 
 	 Conj <c true
 	 , s0 > s01 >c 
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((sizel) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                                    
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T2217)
(declare-fun |0| () Int)
(declare-fun tlen (T2217) Int)
(declare-fun v () T2217)
(declare-fun sizel () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2217)
(declare-fun s01 () Int)
(declare-fun s0 () Int)
(declare-fun ltree () T2217)
(declare-fun _lbv0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2217)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1086 Int)
         (var_u1085 Int)
         (var_u1084 Int)
         (var_u1083 Int)
         (var_u1082 Int)
         (var_u1081 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1083 (+ sizel 1)) (= (tlen v) var_u1083))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (> s0 s01)
         (= (tlen rtree) sizer)
         (=> (= var_u1086 (+ sizel 1)) (= (tlen v) var_u1086))))))
(assert (not (forall ((var_u1087 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), sizel ), ltree ), s01 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), sizel ), ltree ), n ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), sizel ), ltree ), n ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), sizel ), ltree ), n ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument sizel :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument n :: {v:Ty_int | true} | true
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((sizel) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T2223)
(declare-fun |0| () Int)
(declare-fun tlen (T2223) Int)
(declare-fun v () T2223)
(declare-fun sizel () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2223)
(declare-fun ltree () T2223)
(declare-fun _lbv0 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2223)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1093 Int)
         (var_u1092 Int)
         (var_u1091 Int)
         (var_u1090 Int)
         (var_u1089 Int)
         (var_u1088 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1090 (+ sizel 1)) (= (tlen v) var_u1090))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1093 (+ sizel 1)) (= (tlen v) var_u1093))))))
(assert (not (forall ((var_u1094 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), sizel ), ltree ), n ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), sizel ), ltree ), _lbv10 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), sizel ), ltree ), apply subs  (, sizel ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), sizel ), ltree ), _lbv10 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument sizel :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv10 :: {v:Ty_int | (v) ==((sizel) -- (1))} | (_lbv10) ==((sizel) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((sizel) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T2229)
(declare-fun |0| () Int)
(declare-fun tlen (T2229) Int)
(declare-fun v () T2229)
(declare-fun sizel () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2229)
(declare-fun _lbv10 () Int)
(declare-fun ltree () T2229)
(declare-fun _lbv0 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2229)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1100 Int)
         (var_u1099 Int)
         (var_u1098 Int)
         (var_u1097 Int)
         (var_u1096 Int)
         (var_u1095 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1097 (+ sizel 1)) (= (tlen v) var_u1097))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= _lbv10 (- sizel 1))
         (= (tlen rtree) sizer)
         (=> (= var_u1100 (+ sizel 1)) (= (tlen v) var_u1100))))))
(assert (not (forall ((var_u1101 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), sizel ), ltree ), _lbv10 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), sizel ), ltree ), _lbv9 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), sizel ), ltree ), apply subs  (, sizer ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), sizel ), ltree ), _lbv9 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument sizel :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv9 :: {v:Ty_int | (v) ==((sizer) -- (1))} | (_lbv9) ==((sizer) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((sizel) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T2235)
(declare-fun |0| () Int)
(declare-fun tlen (T2235) Int)
(declare-fun v () T2235)
(declare-fun sizel () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2235)
(declare-fun _lbv9 () Int)
(declare-fun ltree () T2235)
(declare-fun _lbv0 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2235)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1107 Int)
         (var_u1106 Int)
         (var_u1105 Int)
         (var_u1104 Int)
         (var_u1103 Int)
         (var_u1102 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1104 (+ sizel 1)) (= (tlen v) var_u1104))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= _lbv9 (- sizer 1))
         (= (tlen rtree) sizer)
         (=> (= var_u1107 (+ sizel 1)) (= (tlen v) var_u1107))))))
(assert (not (forall ((var_u1108 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), sizel ), ltree ), _lbv9 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), sizel ), ltree ), _lbv8 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), sizel ), ltree ), apply subs  (, s ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), sizel ), ltree ), _lbv8 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument sizel :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv8 :: {v:Ty_int | (v) ==((s) -- (1))} | (_lbv8) ==((s) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((sizel) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T2241)
(declare-fun |0| () Int)
(declare-fun tlen (T2241) Int)
(declare-fun v () T2241)
(declare-fun sizel () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2241)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun ltree () T2241)
(declare-fun _lbv0 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2241)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1114 Int)
         (var_u1113 Int)
         (var_u1112 Int)
         (var_u1111 Int)
         (var_u1110 Int)
         (var_u1109 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1111 (+ sizel 1)) (= (tlen v) var_u1111))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= _lbv8 (- s 1))
         (= (tlen rtree) sizer)
         (=> (= var_u1114 (+ sizel 1)) (= (tlen v) var_u1114))))))
(assert (not (forall ((var_u1115 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), sizel ), ltree ), _lbv8 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), sizel ), ltree ), _lbv7 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), sizel ), ltree ), apply subs  (, s01 ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), sizel ), ltree ), _lbv7 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument sizel :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv7 :: {v:Ty_int | (v) ==((s01) -- (1))} | (_lbv7) ==((s01) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((sizel) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T2247)
(declare-fun |0| () Int)
(declare-fun tlen (T2247) Int)
(declare-fun v () T2247)
(declare-fun sizel () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2247)
(declare-fun s01 () Int)
(declare-fun _lbv7 () Int)
(declare-fun ltree () T2247)
(declare-fun _lbv0 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2247)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1121 Int)
         (var_u1120 Int)
         (var_u1119 Int)
         (var_u1118 Int)
         (var_u1117 Int)
         (var_u1116 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1118 (+ sizel 1)) (= (tlen v) var_u1118))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= _lbv7 (- s01 1))
         (= (tlen rtree) sizer)
         (=> (= var_u1121 (+ sizel 1)) (= (tlen v) var_u1121))))))
(assert (not (forall ((var_u1122 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), sizel ), ltree ), _lbv7 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), sizel ), ltree ), _lbv6 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), sizel ), ltree ), apply subs  (, root ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), sizel ), ltree ), _lbv6 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument sizel :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv6 :: {v:Ty_int | (v) ==((root) -- (1))} | (_lbv6) ==((root) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((sizel) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T2253)
(declare-fun |0| () Int)
(declare-fun tlen (T2253) Int)
(declare-fun v () T2253)
(declare-fun sizel () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2253)
(declare-fun root () Int)
(declare-fun _lbv6 () Int)
(declare-fun ltree () T2253)
(declare-fun _lbv0 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2253)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1128 Int)
         (var_u1127 Int)
         (var_u1126 Int)
         (var_u1125 Int)
         (var_u1124 Int)
         (var_u1123 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1125 (+ sizel 1)) (= (tlen v) var_u1125))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= _lbv6 (- root 1))
         (= (tlen rtree) sizer)
         (=> (= var_u1128 (+ sizel 1)) (= (tlen v) var_u1128))))))
(assert (not (forall ((var_u1129 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), sizel ), ltree ), _lbv6 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), sizel ), ltree ), s ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), sizel ), ltree ), s ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), sizel ), ltree ), s ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument sizel :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument s :: {var_v0:Ty_int | true} | true
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((sizel) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T2259)
(declare-fun |0| () Int)
(declare-fun tlen (T2259) Int)
(declare-fun v () T2259)
(declare-fun sizel () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2259)
(declare-fun ltree () T2259)
(declare-fun _lbv0 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2259)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1135 Int)
         (var_u1134 Int)
         (var_u1133 Int)
         (var_u1132 Int)
         (var_u1131 Int)
         (var_u1130 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1132 (+ sizel 1)) (= (tlen v) var_u1132))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1135 (+ sizel 1)) (= (tlen v) var_u1135))))))
(assert (not (forall ((var_u1136 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), sizel ), ltree ), s ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), sizel ), ltree ), _lbv2 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), sizel ), ltree ), apply subs  (, apply int_gen  (, dummy ) ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), sizel ), ltree ), _lbv2 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument sizel :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv2 :: {v:Ty_int | (v) ==((_lbv0) -- (1))} | (_lbv2) ==((_lbv0) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((sizel) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T2265)
(declare-fun |0| () Int)
(declare-fun tlen (T2265) Int)
(declare-fun v () T2265)
(declare-fun sizel () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2265)
(declare-fun _lbv0 () Int)
(declare-fun _lbv2 () Int)
(declare-fun ltree () T2265)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2265)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1142 Int)
         (var_u1141 Int)
         (var_u1140 Int)
         (var_u1139 Int)
         (var_u1138 Int)
         (var_u1137 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1139 (+ sizel 1)) (= (tlen v) var_u1139))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= _lbv2 (- _lbv0 1))
         (= (tlen rtree) sizer)
         (=> (= var_u1142 (+ sizel 1)) (= (tlen v) var_u1142))))))
(assert (not (forall ((var_u1143 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), sizel ), ltree ), _lbv2 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), sizel ), ltree ), _lbv1 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), sizel ), ltree ), apply subs  (, s0 ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), sizel ), ltree ), _lbv1 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument sizel :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((sizel) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T2271)
(declare-fun |0| () Int)
(declare-fun tlen (T2271) Int)
(declare-fun v () T2271)
(declare-fun sizel () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2271)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun ltree () T2271)
(declare-fun _lbv0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2271)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1149 Int)
         (var_u1148 Int)
         (var_u1147 Int)
         (var_u1146 Int)
         (var_u1145 Int)
         (var_u1144 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1146 (+ sizel 1)) (= (tlen v) var_u1146))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= _lbv1 (- s0 1))
         (= (tlen rtree) sizer)
         (=> (= var_u1149 (+ sizel 1)) (= (tlen v) var_u1149))))))
(assert (not (forall ((var_u1150 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), sizel ), ltree ), _lbv1 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), sizel ), ltree ), _lbv0 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), sizel ), ltree ), apply int_gen  (, dummy ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), sizel ), ltree ), _lbv0 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument sizel :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((sizel) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                                          
# of Final Z3 expressions 20
 Final solver 
 (declare-sort T2277)
(declare-fun |0| () Int)
(declare-fun tlen (T2277) Int)
(declare-fun v () T2277)
(declare-fun sizel () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2277)
(declare-fun _lbv0 () Int)
(declare-fun ltree () T2277)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2277)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1156 Int)
         (var_u1155 Int)
         (var_u1154 Int)
         (var_u1153 Int)
         (var_u1152 Int)
         (var_u1151 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1153 (+ sizel 1)) (= (tlen v) var_u1153))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen rtree) sizer)
         (=> (= var_u1156 (+ sizel 1)) (= (tlen v) var_u1156))))))
(assert (not (forall ((var_u1157 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), sizel ), ltree ), _lbv0 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), sizel ), ltree ), s0 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), sizel ), ltree ), s0 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), sizel ), ltree ), s0 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument sizel :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument s0 :: {v:Ty_int | true} | true
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((sizel) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T2283)
(declare-fun |0| () Int)
(declare-fun tlen (T2283) Int)
(declare-fun v () T2283)
(declare-fun sizel () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2283)
(declare-fun ltree () T2283)
(declare-fun _lbv0 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2283)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1163 Int)
         (var_u1162 Int)
         (var_u1161 Int)
         (var_u1160 Int)
         (var_u1159 Int)
         (var_u1158 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1160 (+ sizel 1)) (= (tlen v) var_u1160))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1163 (+ sizel 1)) (= (tlen v) var_u1163))))))
(assert (not (forall ((var_u1164 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), sizel ), ltree ), s0 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), sizel ), ltree ), _lbv1 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), sizel ), ltree ), apply subs  (, s0 ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), sizel ), ltree ), _lbv1 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument sizel :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((sizel) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T2289)
(declare-fun |0| () Int)
(declare-fun tlen (T2289) Int)
(declare-fun v () T2289)
(declare-fun sizel () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2289)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun ltree () T2289)
(declare-fun _lbv0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2289)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1170 Int)
         (var_u1169 Int)
         (var_u1168 Int)
         (var_u1167 Int)
         (var_u1166 Int)
         (var_u1165 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1167 (+ sizel 1)) (= (tlen v) var_u1167))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= _lbv1 (- s0 1))
         (= (tlen rtree) sizer)
         (=> (= var_u1170 (+ sizel 1)) (= (tlen v) var_u1170))))))
(assert (not (forall ((var_u1171 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), sizel ), ltree ), _lbv1 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), sizel ), ltree ), _lbv2 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), sizel ), ltree ), apply subs  (, apply int_gen  (, dummy ) ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), sizel ), ltree ), _lbv2 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument sizel :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv2 :: {v:Ty_int | (v) ==((_lbv0) -- (1))} | (_lbv2) ==((_lbv0) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((sizel) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T2295)
(declare-fun |0| () Int)
(declare-fun tlen (T2295) Int)
(declare-fun v () T2295)
(declare-fun sizel () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2295)
(declare-fun _lbv0 () Int)
(declare-fun _lbv2 () Int)
(declare-fun ltree () T2295)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2295)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1177 Int)
         (var_u1176 Int)
         (var_u1175 Int)
         (var_u1174 Int)
         (var_u1173 Int)
         (var_u1172 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1174 (+ sizel 1)) (= (tlen v) var_u1174))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= _lbv2 (- _lbv0 1))
         (= (tlen rtree) sizer)
         (=> (= var_u1177 (+ sizel 1)) (= (tlen v) var_u1177))))))
(assert (not (forall ((var_u1178 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), sizel ), ltree ), _lbv2 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), sizel ), ltree ), _lbv8 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), sizel ), ltree ), apply subs  (, s ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), sizel ), ltree ), _lbv8 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument sizel :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv8 :: {v:Ty_int | (v) ==((s) -- (1))} | (_lbv8) ==((s) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((sizel) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T2301)
(declare-fun |0| () Int)
(declare-fun tlen (T2301) Int)
(declare-fun v () T2301)
(declare-fun sizel () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2301)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun ltree () T2301)
(declare-fun _lbv0 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2301)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1184 Int)
         (var_u1183 Int)
         (var_u1182 Int)
         (var_u1181 Int)
         (var_u1180 Int)
         (var_u1179 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1181 (+ sizel 1)) (= (tlen v) var_u1181))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= _lbv8 (- s 1))
         (= (tlen rtree) sizer)
         (=> (= var_u1184 (+ sizel 1)) (= (tlen v) var_u1184))))))
(assert (not (forall ((var_u1185 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), sizel ), ltree ), _lbv8 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), sizel ), ltree ), _lbv7 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), sizel ), ltree ), apply subs  (, s01 ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), sizel ), ltree ), _lbv7 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument sizel :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv7 :: {v:Ty_int | (v) ==((s01) -- (1))} | (_lbv7) ==((s01) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((sizel) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T2307)
(declare-fun |0| () Int)
(declare-fun tlen (T2307) Int)
(declare-fun v () T2307)
(declare-fun sizel () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2307)
(declare-fun s01 () Int)
(declare-fun _lbv7 () Int)
(declare-fun ltree () T2307)
(declare-fun _lbv0 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2307)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1191 Int)
         (var_u1190 Int)
         (var_u1189 Int)
         (var_u1188 Int)
         (var_u1187 Int)
         (var_u1186 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1188 (+ sizel 1)) (= (tlen v) var_u1188))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= _lbv7 (- s01 1))
         (= (tlen rtree) sizer)
         (=> (= var_u1191 (+ sizel 1)) (= (tlen v) var_u1191))))))
(assert (not (forall ((var_u1192 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), sizel ), ltree ), _lbv7 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), sizel ), ltree ), _lbv6 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), sizel ), ltree ), apply subs  (, root ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), sizel ), ltree ), _lbv6 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument sizel :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv6 :: {v:Ty_int | (v) ==((root) -- (1))} | (_lbv6) ==((root) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((sizel) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T2313)
(declare-fun |0| () Int)
(declare-fun tlen (T2313) Int)
(declare-fun v () T2313)
(declare-fun sizel () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2313)
(declare-fun root () Int)
(declare-fun _lbv6 () Int)
(declare-fun ltree () T2313)
(declare-fun _lbv0 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2313)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1198 Int)
         (var_u1197 Int)
         (var_u1196 Int)
         (var_u1195 Int)
         (var_u1194 Int)
         (var_u1193 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1195 (+ sizel 1)) (= (tlen v) var_u1195))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= _lbv6 (- root 1))
         (= (tlen rtree) sizer)
         (=> (= var_u1198 (+ sizel 1)) (= (tlen v) var_u1198))))))
(assert (not (forall ((var_u1199 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), sizel ), ltree ), _lbv6 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), sizel ), ltree ), _lbv10 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), sizel ), ltree ), apply subs  (, sizel ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), sizel ), ltree ), _lbv10 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument sizel :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv10 :: {v:Ty_int | (v) ==((sizel) -- (1))} | (_lbv10) ==((sizel) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((sizel) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T2319)
(declare-fun |0| () Int)
(declare-fun tlen (T2319) Int)
(declare-fun v () T2319)
(declare-fun sizel () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2319)
(declare-fun _lbv10 () Int)
(declare-fun ltree () T2319)
(declare-fun _lbv0 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2319)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1205 Int)
         (var_u1204 Int)
         (var_u1203 Int)
         (var_u1202 Int)
         (var_u1201 Int)
         (var_u1200 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1202 (+ sizel 1)) (= (tlen v) var_u1202))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= _lbv10 (- sizel 1))
         (= (tlen rtree) sizer)
         (=> (= var_u1205 (+ sizel 1)) (= (tlen v) var_u1205))))))
(assert (not (forall ((var_u1206 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), sizel ), ltree ), _lbv10 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), sizel ), ltree ), _lbv9 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), sizel ), ltree ), apply subs  (, sizer ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), sizel ), ltree ), _lbv9 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument sizel :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv9 :: {v:Ty_int | (v) ==((sizer) -- (1))} | (_lbv9) ==((sizer) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((sizel) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T2325)
(declare-fun |0| () Int)
(declare-fun tlen (T2325) Int)
(declare-fun v () T2325)
(declare-fun sizel () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2325)
(declare-fun _lbv9 () Int)
(declare-fun ltree () T2325)
(declare-fun _lbv0 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2325)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1212 Int)
         (var_u1211 Int)
         (var_u1210 Int)
         (var_u1209 Int)
         (var_u1208 Int)
         (var_u1207 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1209 (+ sizel 1)) (= (tlen v) var_u1209))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= _lbv9 (- sizer 1))
         (= (tlen rtree) sizer)
         (=> (= var_u1212 (+ sizel 1)) (= (tlen v) var_u1212))))))
(assert (not (forall ((var_u1213 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), sizel ), ltree ), _lbv9 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), s ), ltree ), sizer ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), s ), ltree ), sizer ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), s ), ltree ), sizer ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument s :: {var_v0:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument sizer :: {v:Ty_int | true} | true
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((s) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T2331)
(declare-fun |0| () Int)
(declare-fun tlen (T2331) Int)
(declare-fun v () T2331)
(declare-fun s () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2331)
(declare-fun sizel () Int)
(declare-fun ltree () T2331)
(declare-fun _lbv0 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2331)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1219 Int)
         (var_u1218 Int)
         (var_u1217 Int)
         (var_u1216 Int)
         (var_u1215 Int)
         (var_u1214 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1216 (+ s 1)) (= (tlen v) var_u1216))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1219 (+ s 1)) (= (tlen v) var_u1219))))))
(assert (not (forall ((var_u1220 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), s ), ltree ), sizer ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), s ), ltree ), sizel ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), s ), ltree ), sizel ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), s ), ltree ), sizel ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument s :: {var_v0:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument sizel :: {v:Ty_int | true} | true
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((s) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T2337)
(declare-fun |0| () Int)
(declare-fun tlen (T2337) Int)
(declare-fun v () T2337)
(declare-fun s () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2337)
(declare-fun sizel () Int)
(declare-fun ltree () T2337)
(declare-fun _lbv0 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2337)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1226 Int)
         (var_u1225 Int)
         (var_u1224 Int)
         (var_u1223 Int)
         (var_u1222 Int)
         (var_u1221 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1223 (+ s 1)) (= (tlen v) var_u1223))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1226 (+ s 1)) (= (tlen v) var_u1226))))))
(assert (not (forall ((var_u1227 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), s ), ltree ), sizel ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), s ), ltree ), root ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), s ), ltree ), root ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), s ), ltree ), root ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument s :: {var_v0:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument root :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  root > 0
 	,   root = 0>d 
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((s) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                                          
# of Final Z3 expressions 20
 Final solver 
 (declare-sort T2343)
(declare-fun |0| () Int)
(declare-fun tlen (T2343) Int)
(declare-fun v () T2343)
(declare-fun s () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2343)
(declare-fun root () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T2343)
(declare-fun _lbv0 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2343)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1233 Int)
         (var_u1232 Int)
         (var_u1231 Int)
         (var_u1230 Int)
         (var_u1229 Int)
         (var_u1228 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1230 (+ s 1)) (= (tlen v) var_u1230))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (or (> root |0|) (= root |0|))
         (= (tlen rtree) sizer)
         (=> (= var_u1233 (+ s 1)) (= (tlen v) var_u1233))))))
(assert (not (forall ((var_u1234 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), s ), ltree ), root ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), s ), ltree ), s01 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), s ), ltree ), s01 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), s ), ltree ), s01 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument s :: {var_v0:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument s01 :: {v:Ty_int | 
 	 Conj <c true
 	 , s0 > v >c } | 
 	 Conj <c true
 	 , s0 > s01 >c 
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((s) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                                    
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T2349)
(declare-fun |0| () Int)
(declare-fun tlen (T2349) Int)
(declare-fun v () T2349)
(declare-fun s () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2349)
(declare-fun s01 () Int)
(declare-fun s0 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T2349)
(declare-fun _lbv0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2349)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1240 Int)
         (var_u1239 Int)
         (var_u1238 Int)
         (var_u1237 Int)
         (var_u1236 Int)
         (var_u1235 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1237 (+ s 1)) (= (tlen v) var_u1237))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (> s0 s01)
         (= (tlen rtree) sizer)
         (=> (= var_u1240 (+ s 1)) (= (tlen v) var_u1240))))))
(assert (not (forall ((var_u1241 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), s ), ltree ), s01 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), s ), ltree ), n ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), s ), ltree ), n ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), s ), ltree ), n ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument s :: {var_v0:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument n :: {v:Ty_int | true} | true
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((s) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T2355)
(declare-fun |0| () Int)
(declare-fun tlen (T2355) Int)
(declare-fun v () T2355)
(declare-fun s () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2355)
(declare-fun sizel () Int)
(declare-fun ltree () T2355)
(declare-fun _lbv0 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2355)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1247 Int)
         (var_u1246 Int)
         (var_u1245 Int)
         (var_u1244 Int)
         (var_u1243 Int)
         (var_u1242 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1244 (+ s 1)) (= (tlen v) var_u1244))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1247 (+ s 1)) (= (tlen v) var_u1247))))))
(assert (not (forall ((var_u1248 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), s ), ltree ), n ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), s ), ltree ), _lbv10 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), s ), ltree ), apply subs  (, sizel ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), s ), ltree ), _lbv10 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument s :: {var_v0:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv10 :: {v:Ty_int | (v) ==((sizel) -- (1))} | (_lbv10) ==((sizel) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((s) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T2361)
(declare-fun |0| () Int)
(declare-fun tlen (T2361) Int)
(declare-fun v () T2361)
(declare-fun s () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2361)
(declare-fun sizel () Int)
(declare-fun _lbv10 () Int)
(declare-fun ltree () T2361)
(declare-fun _lbv0 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv9 () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2361)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1254 Int)
         (var_u1253 Int)
         (var_u1252 Int)
         (var_u1251 Int)
         (var_u1250 Int)
         (var_u1249 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1251 (+ s 1)) (= (tlen v) var_u1251))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= _lbv10 (- sizel 1))
         (= (tlen rtree) sizer)
         (=> (= var_u1254 (+ s 1)) (= (tlen v) var_u1254))))))
(assert (not (forall ((var_u1255 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), s ), ltree ), _lbv10 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), s ), ltree ), _lbv9 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), s ), ltree ), apply subs  (, sizer ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), s ), ltree ), _lbv9 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument s :: {var_v0:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv9 :: {v:Ty_int | (v) ==((sizer) -- (1))} | (_lbv9) ==((sizer) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((s) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T2367)
(declare-fun |0| () Int)
(declare-fun tlen (T2367) Int)
(declare-fun v () T2367)
(declare-fun s () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2367)
(declare-fun _lbv9 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T2367)
(declare-fun _lbv0 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2367)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1261 Int)
         (var_u1260 Int)
         (var_u1259 Int)
         (var_u1258 Int)
         (var_u1257 Int)
         (var_u1256 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1258 (+ s 1)) (= (tlen v) var_u1258))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= _lbv9 (- sizer 1))
         (= (tlen rtree) sizer)
         (=> (= var_u1261 (+ s 1)) (= (tlen v) var_u1261))))))
(assert (not (forall ((var_u1262 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), s ), ltree ), _lbv9 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), s ), ltree ), _lbv8 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), s ), ltree ), apply subs  (, s ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), s ), ltree ), _lbv8 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument s :: {var_v0:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv8 :: {v:Ty_int | (v) ==((s) -- (1))} | (_lbv8) ==((s) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((s) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T2373)
(declare-fun |0| () Int)
(declare-fun tlen (T2373) Int)
(declare-fun v () T2373)
(declare-fun s () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2373)
(declare-fun _lbv8 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T2373)
(declare-fun _lbv0 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2373)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1268 Int)
         (var_u1267 Int)
         (var_u1266 Int)
         (var_u1265 Int)
         (var_u1264 Int)
         (var_u1263 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1265 (+ s 1)) (= (tlen v) var_u1265))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= _lbv8 (- s 1))
         (= (tlen rtree) sizer)
         (=> (= var_u1268 (+ s 1)) (= (tlen v) var_u1268))))))
(assert (not (forall ((var_u1269 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), s ), ltree ), _lbv8 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), s ), ltree ), _lbv7 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), s ), ltree ), apply subs  (, s01 ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), s ), ltree ), _lbv7 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument s :: {var_v0:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv7 :: {v:Ty_int | (v) ==((s01) -- (1))} | (_lbv7) ==((s01) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((s) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T2379)
(declare-fun |0| () Int)
(declare-fun tlen (T2379) Int)
(declare-fun v () T2379)
(declare-fun s () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2379)
(declare-fun s01 () Int)
(declare-fun _lbv7 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T2379)
(declare-fun _lbv0 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2379)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1275 Int)
         (var_u1274 Int)
         (var_u1273 Int)
         (var_u1272 Int)
         (var_u1271 Int)
         (var_u1270 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1272 (+ s 1)) (= (tlen v) var_u1272))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= _lbv7 (- s01 1))
         (= (tlen rtree) sizer)
         (=> (= var_u1275 (+ s 1)) (= (tlen v) var_u1275))))))
(assert (not (forall ((var_u1276 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), s ), ltree ), _lbv7 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), s ), ltree ), _lbv6 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), s ), ltree ), apply subs  (, root ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), s ), ltree ), _lbv6 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument s :: {var_v0:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv6 :: {v:Ty_int | (v) ==((root) -- (1))} | (_lbv6) ==((root) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((s) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T2385)
(declare-fun |0| () Int)
(declare-fun tlen (T2385) Int)
(declare-fun v () T2385)
(declare-fun s () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2385)
(declare-fun root () Int)
(declare-fun _lbv6 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T2385)
(declare-fun _lbv0 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2385)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1282 Int)
         (var_u1281 Int)
         (var_u1280 Int)
         (var_u1279 Int)
         (var_u1278 Int)
         (var_u1277 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1279 (+ s 1)) (= (tlen v) var_u1279))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= _lbv6 (- root 1))
         (= (tlen rtree) sizer)
         (=> (= var_u1282 (+ s 1)) (= (tlen v) var_u1282))))))
(assert (not (forall ((var_u1283 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), s ), ltree ), _lbv6 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), s ), ltree ), s ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), s ), ltree ), s ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), s ), ltree ), s ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument s :: {var_v0:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument s :: {var_v0:Ty_int | true} | true
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((s) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T2391)
(declare-fun |0| () Int)
(declare-fun tlen (T2391) Int)
(declare-fun v () T2391)
(declare-fun s () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2391)
(declare-fun sizel () Int)
(declare-fun ltree () T2391)
(declare-fun _lbv0 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2391)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1289 Int)
         (var_u1288 Int)
         (var_u1287 Int)
         (var_u1286 Int)
         (var_u1285 Int)
         (var_u1284 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1286 (+ s 1)) (= (tlen v) var_u1286))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1289 (+ s 1)) (= (tlen v) var_u1289))))))
(assert (not (forall ((var_u1290 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), s ), ltree ), s ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), s ), ltree ), _lbv2 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), s ), ltree ), apply subs  (, apply int_gen  (, dummy ) ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), s ), ltree ), _lbv2 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument s :: {var_v0:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv2 :: {v:Ty_int | (v) ==((_lbv0) -- (1))} | (_lbv2) ==((_lbv0) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((s) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T2397)
(declare-fun |0| () Int)
(declare-fun tlen (T2397) Int)
(declare-fun v () T2397)
(declare-fun s () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2397)
(declare-fun _lbv0 () Int)
(declare-fun _lbv2 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T2397)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2397)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1296 Int)
         (var_u1295 Int)
         (var_u1294 Int)
         (var_u1293 Int)
         (var_u1292 Int)
         (var_u1291 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1293 (+ s 1)) (= (tlen v) var_u1293))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= _lbv2 (- _lbv0 1))
         (= (tlen rtree) sizer)
         (=> (= var_u1296 (+ s 1)) (= (tlen v) var_u1296))))))
(assert (not (forall ((var_u1297 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), s ), ltree ), _lbv2 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), s ), ltree ), _lbv1 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), s ), ltree ), apply subs  (, s0 ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), s ), ltree ), _lbv1 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument s :: {var_v0:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((s) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T2403)
(declare-fun |0| () Int)
(declare-fun tlen (T2403) Int)
(declare-fun v () T2403)
(declare-fun s () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2403)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T2403)
(declare-fun _lbv0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2403)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1303 Int)
         (var_u1302 Int)
         (var_u1301 Int)
         (var_u1300 Int)
         (var_u1299 Int)
         (var_u1298 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1300 (+ s 1)) (= (tlen v) var_u1300))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= _lbv1 (- s0 1))
         (= (tlen rtree) sizer)
         (=> (= var_u1303 (+ s 1)) (= (tlen v) var_u1303))))))
(assert (not (forall ((var_u1304 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), s ), ltree ), _lbv1 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), s ), ltree ), _lbv0 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), s ), ltree ), apply int_gen  (, dummy ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), s ), ltree ), _lbv0 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument s :: {var_v0:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((s) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                                          
# of Final Z3 expressions 20
 Final solver 
 (declare-sort T2409)
(declare-fun |0| () Int)
(declare-fun tlen (T2409) Int)
(declare-fun v () T2409)
(declare-fun s () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2409)
(declare-fun _lbv0 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T2409)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2409)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1310 Int)
         (var_u1309 Int)
         (var_u1308 Int)
         (var_u1307 Int)
         (var_u1306 Int)
         (var_u1305 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1307 (+ s 1)) (= (tlen v) var_u1307))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen rtree) sizer)
         (=> (= var_u1310 (+ s 1)) (= (tlen v) var_u1310))))))
(assert (not (forall ((var_u1311 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), s ), ltree ), _lbv0 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), s ), ltree ), s0 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), s ), ltree ), s0 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), s ), ltree ), s0 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument s :: {var_v0:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument s0 :: {v:Ty_int | true} | true
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((s) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T2415)
(declare-fun |0| () Int)
(declare-fun tlen (T2415) Int)
(declare-fun v () T2415)
(declare-fun s () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2415)
(declare-fun sizel () Int)
(declare-fun ltree () T2415)
(declare-fun _lbv0 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2415)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1317 Int)
         (var_u1316 Int)
         (var_u1315 Int)
         (var_u1314 Int)
         (var_u1313 Int)
         (var_u1312 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1314 (+ s 1)) (= (tlen v) var_u1314))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1317 (+ s 1)) (= (tlen v) var_u1317))))))
(assert (not (forall ((var_u1318 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), s ), ltree ), s0 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), s ), ltree ), _lbv1 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), s ), ltree ), apply subs  (, s0 ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), s ), ltree ), _lbv1 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument s :: {var_v0:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((s) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T2421)
(declare-fun |0| () Int)
(declare-fun tlen (T2421) Int)
(declare-fun v () T2421)
(declare-fun s () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2421)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T2421)
(declare-fun _lbv0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2421)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1324 Int)
         (var_u1323 Int)
         (var_u1322 Int)
         (var_u1321 Int)
         (var_u1320 Int)
         (var_u1319 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1321 (+ s 1)) (= (tlen v) var_u1321))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= _lbv1 (- s0 1))
         (= (tlen rtree) sizer)
         (=> (= var_u1324 (+ s 1)) (= (tlen v) var_u1324))))))
(assert (not (forall ((var_u1325 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), s ), ltree ), _lbv1 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), s ), ltree ), _lbv2 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), s ), ltree ), apply subs  (, apply int_gen  (, dummy ) ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), s ), ltree ), _lbv2 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument s :: {var_v0:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv2 :: {v:Ty_int | (v) ==((_lbv0) -- (1))} | (_lbv2) ==((_lbv0) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((s) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T2427)
(declare-fun |0| () Int)
(declare-fun tlen (T2427) Int)
(declare-fun v () T2427)
(declare-fun s () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2427)
(declare-fun _lbv0 () Int)
(declare-fun _lbv2 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T2427)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2427)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1331 Int)
         (var_u1330 Int)
         (var_u1329 Int)
         (var_u1328 Int)
         (var_u1327 Int)
         (var_u1326 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1328 (+ s 1)) (= (tlen v) var_u1328))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= _lbv2 (- _lbv0 1))
         (= (tlen rtree) sizer)
         (=> (= var_u1331 (+ s 1)) (= (tlen v) var_u1331))))))
(assert (not (forall ((var_u1332 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), s ), ltree ), _lbv2 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), s ), ltree ), _lbv8 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), s ), ltree ), apply subs  (, s ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), s ), ltree ), _lbv8 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument s :: {var_v0:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv8 :: {v:Ty_int | (v) ==((s) -- (1))} | (_lbv8) ==((s) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((s) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T2433)
(declare-fun |0| () Int)
(declare-fun tlen (T2433) Int)
(declare-fun v () T2433)
(declare-fun s () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2433)
(declare-fun _lbv8 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T2433)
(declare-fun _lbv0 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2433)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1338 Int)
         (var_u1337 Int)
         (var_u1336 Int)
         (var_u1335 Int)
         (var_u1334 Int)
         (var_u1333 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1335 (+ s 1)) (= (tlen v) var_u1335))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= _lbv8 (- s 1))
         (= (tlen rtree) sizer)
         (=> (= var_u1338 (+ s 1)) (= (tlen v) var_u1338))))))
(assert (not (forall ((var_u1339 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), s ), ltree ), _lbv8 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), s ), ltree ), _lbv7 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), s ), ltree ), apply subs  (, s01 ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), s ), ltree ), _lbv7 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument s :: {var_v0:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv7 :: {v:Ty_int | (v) ==((s01) -- (1))} | (_lbv7) ==((s01) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((s) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T2439)
(declare-fun |0| () Int)
(declare-fun tlen (T2439) Int)
(declare-fun v () T2439)
(declare-fun s () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2439)
(declare-fun s01 () Int)
(declare-fun _lbv7 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T2439)
(declare-fun _lbv0 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2439)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1345 Int)
         (var_u1344 Int)
         (var_u1343 Int)
         (var_u1342 Int)
         (var_u1341 Int)
         (var_u1340 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1342 (+ s 1)) (= (tlen v) var_u1342))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= _lbv7 (- s01 1))
         (= (tlen rtree) sizer)
         (=> (= var_u1345 (+ s 1)) (= (tlen v) var_u1345))))))
(assert (not (forall ((var_u1346 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), s ), ltree ), _lbv7 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), s ), ltree ), _lbv6 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), s ), ltree ), apply subs  (, root ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), s ), ltree ), _lbv6 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument s :: {var_v0:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv6 :: {v:Ty_int | (v) ==((root) -- (1))} | (_lbv6) ==((root) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((s) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T2445)
(declare-fun |0| () Int)
(declare-fun tlen (T2445) Int)
(declare-fun v () T2445)
(declare-fun s () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2445)
(declare-fun root () Int)
(declare-fun _lbv6 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T2445)
(declare-fun _lbv0 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2445)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1352 Int)
         (var_u1351 Int)
         (var_u1350 Int)
         (var_u1349 Int)
         (var_u1348 Int)
         (var_u1347 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1349 (+ s 1)) (= (tlen v) var_u1349))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= _lbv6 (- root 1))
         (= (tlen rtree) sizer)
         (=> (= var_u1352 (+ s 1)) (= (tlen v) var_u1352))))))
(assert (not (forall ((var_u1353 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), s ), ltree ), _lbv6 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), s ), ltree ), _lbv10 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), s ), ltree ), apply subs  (, sizel ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), s ), ltree ), _lbv10 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument s :: {var_v0:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv10 :: {v:Ty_int | (v) ==((sizel) -- (1))} | (_lbv10) ==((sizel) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((s) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T2451)
(declare-fun |0| () Int)
(declare-fun tlen (T2451) Int)
(declare-fun v () T2451)
(declare-fun s () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2451)
(declare-fun sizel () Int)
(declare-fun _lbv10 () Int)
(declare-fun ltree () T2451)
(declare-fun _lbv0 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv9 () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2451)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1359 Int)
         (var_u1358 Int)
         (var_u1357 Int)
         (var_u1356 Int)
         (var_u1355 Int)
         (var_u1354 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1356 (+ s 1)) (= (tlen v) var_u1356))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= _lbv10 (- sizel 1))
         (= (tlen rtree) sizer)
         (=> (= var_u1359 (+ s 1)) (= (tlen v) var_u1359))))))
(assert (not (forall ((var_u1360 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), s ), ltree ), _lbv10 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), s ), ltree ), _lbv9 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), s ), ltree ), apply subs  (, sizer ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), s ), ltree ), _lbv9 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument s :: {var_v0:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv9 :: {v:Ty_int | (v) ==((sizer) -- (1))} | (_lbv9) ==((sizer) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((s) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T2457)
(declare-fun |0| () Int)
(declare-fun tlen (T2457) Int)
(declare-fun v () T2457)
(declare-fun s () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2457)
(declare-fun _lbv9 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T2457)
(declare-fun _lbv0 () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2457)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1366 Int)
         (var_u1365 Int)
         (var_u1364 Int)
         (var_u1363 Int)
         (var_u1362 Int)
         (var_u1361 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1363 (+ s 1)) (= (tlen v) var_u1363))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= _lbv9 (- sizer 1))
         (= (tlen rtree) sizer)
         (=> (= var_u1366 (+ s 1)) (= (tlen v) var_u1366))))))
(assert (not (forall ((var_u1367 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), s ), ltree ), _lbv9 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), _lbv0 ), ltree ), sizer ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), apply int_gen  (, dummy ) ), ltree ), sizer ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), _lbv0 ), ltree ), sizer ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument sizer :: {v:Ty_int | true} | true
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((_lbv0) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                                          
# of Final Z3 expressions 20
 Final solver 
 (declare-sort T2463)
(declare-fun |0| () Int)
(declare-fun tlen (T2463) Int)
(declare-fun v () T2463)
(declare-fun _lbv0 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2463)
(declare-fun sizel () Int)
(declare-fun ltree () T2463)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2463)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1373 Int)
         (var_u1372 Int)
         (var_u1371 Int)
         (var_u1370 Int)
         (var_u1369 Int)
         (var_u1368 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1370 (+ _lbv0 1)) (= (tlen v) var_u1370))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1373 (+ _lbv0 1)) (= (tlen v) var_u1373))))))
(assert (not (forall ((var_u1374 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), _lbv0 ), ltree ), sizer ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), _lbv0 ), ltree ), sizel ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), apply int_gen  (, dummy ) ), ltree ), sizel ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), _lbv0 ), ltree ), sizel ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument sizel :: {v:Ty_int | true} | true
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((_lbv0) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                                          
# of Final Z3 expressions 20
 Final solver 
 (declare-sort T2469)
(declare-fun |0| () Int)
(declare-fun tlen (T2469) Int)
(declare-fun v () T2469)
(declare-fun _lbv0 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2469)
(declare-fun sizel () Int)
(declare-fun ltree () T2469)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2469)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1380 Int)
         (var_u1379 Int)
         (var_u1378 Int)
         (var_u1377 Int)
         (var_u1376 Int)
         (var_u1375 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1377 (+ _lbv0 1)) (= (tlen v) var_u1377))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1380 (+ _lbv0 1)) (= (tlen v) var_u1380))))))
(assert (not (forall ((var_u1381 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), _lbv0 ), ltree ), sizel ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), _lbv0 ), ltree ), root ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), apply int_gen  (, dummy ) ), ltree ), root ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), _lbv0 ), ltree ), root ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument root :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  root > 0
 	,   root = 0>d 
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((_lbv0) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                                                     
# of Final Z3 expressions 22
 Final solver 
 (declare-sort T2475)
(declare-fun |0| () Int)
(declare-fun tlen (T2475) Int)
(declare-fun v () T2475)
(declare-fun _lbv0 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2475)
(declare-fun root () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T2475)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2475)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1387 Int)
         (var_u1386 Int)
         (var_u1385 Int)
         (var_u1384 Int)
         (var_u1383 Int)
         (var_u1382 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1384 (+ _lbv0 1)) (= (tlen v) var_u1384))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (or (> root |0|) (= root |0|))
         (= (tlen rtree) sizer)
         (=> (= var_u1387 (+ _lbv0 1)) (= (tlen v) var_u1387))))))
(assert (not (forall ((var_u1388 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), _lbv0 ), ltree ), root ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), _lbv0 ), ltree ), s01 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), apply int_gen  (, dummy ) ), ltree ), s01 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), _lbv0 ), ltree ), s01 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument s01 :: {v:Ty_int | 
 	 Conj <c true
 	 , s0 > v >c } | 
 	 Conj <c true
 	 , s0 > s01 >c 
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((_lbv0) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                                               
# of Final Z3 expressions 20
 Final solver 
 (declare-sort T2481)
(declare-fun |0| () Int)
(declare-fun tlen (T2481) Int)
(declare-fun v () T2481)
(declare-fun _lbv0 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2481)
(declare-fun s01 () Int)
(declare-fun s0 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T2481)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2481)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1394 Int)
         (var_u1393 Int)
         (var_u1392 Int)
         (var_u1391 Int)
         (var_u1390 Int)
         (var_u1389 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1391 (+ _lbv0 1)) (= (tlen v) var_u1391))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (> s0 s01)
         (= (tlen rtree) sizer)
         (=> (= var_u1394 (+ _lbv0 1)) (= (tlen v) var_u1394))))))
(assert (not (forall ((var_u1395 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), _lbv0 ), ltree ), s01 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), _lbv0 ), ltree ), n ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), apply int_gen  (, dummy ) ), ltree ), n ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), _lbv0 ), ltree ), n ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument n :: {v:Ty_int | true} | true
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((_lbv0) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                                          
# of Final Z3 expressions 20
 Final solver 
 (declare-sort T2487)
(declare-fun |0| () Int)
(declare-fun tlen (T2487) Int)
(declare-fun v () T2487)
(declare-fun _lbv0 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2487)
(declare-fun sizel () Int)
(declare-fun ltree () T2487)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2487)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1401 Int)
         (var_u1400 Int)
         (var_u1399 Int)
         (var_u1398 Int)
         (var_u1397 Int)
         (var_u1396 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1398 (+ _lbv0 1)) (= (tlen v) var_u1398))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1401 (+ _lbv0 1)) (= (tlen v) var_u1401))))))
(assert (not (forall ((var_u1402 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), _lbv0 ), ltree ), n ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), _lbv0 ), ltree ), _lbv10 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), apply int_gen  (, dummy ) ), ltree ), apply subs  (, sizel ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), _lbv0 ), ltree ), _lbv10 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv10 :: {v:Ty_int | (v) ==((sizel) -- (1))} | (_lbv10) ==((sizel) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((_lbv0) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                                          
# of Final Z3 expressions 20
 Final solver 
 (declare-sort T2493)
(declare-fun |0| () Int)
(declare-fun tlen (T2493) Int)
(declare-fun v () T2493)
(declare-fun _lbv0 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2493)
(declare-fun sizel () Int)
(declare-fun _lbv10 () Int)
(declare-fun ltree () T2493)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2493)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1408 Int)
         (var_u1407 Int)
         (var_u1406 Int)
         (var_u1405 Int)
         (var_u1404 Int)
         (var_u1403 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1405 (+ _lbv0 1)) (= (tlen v) var_u1405))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= _lbv10 (- sizel 1))
         (= (tlen rtree) sizer)
         (=> (= var_u1408 (+ _lbv0 1)) (= (tlen v) var_u1408))))))
(assert (not (forall ((var_u1409 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), _lbv0 ), ltree ), _lbv10 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), _lbv0 ), ltree ), _lbv9 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), apply int_gen  (, dummy ) ), ltree ), apply subs  (, sizer ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), _lbv0 ), ltree ), _lbv9 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv9 :: {v:Ty_int | (v) ==((sizer) -- (1))} | (_lbv9) ==((sizer) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((_lbv0) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                                          
# of Final Z3 expressions 20
 Final solver 
 (declare-sort T2499)
(declare-fun |0| () Int)
(declare-fun tlen (T2499) Int)
(declare-fun v () T2499)
(declare-fun _lbv0 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2499)
(declare-fun _lbv9 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T2499)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2499)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1415 Int)
         (var_u1414 Int)
         (var_u1413 Int)
         (var_u1412 Int)
         (var_u1411 Int)
         (var_u1410 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1412 (+ _lbv0 1)) (= (tlen v) var_u1412))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= _lbv9 (- sizer 1))
         (= (tlen rtree) sizer)
         (=> (= var_u1415 (+ _lbv0 1)) (= (tlen v) var_u1415))))))
(assert (not (forall ((var_u1416 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), _lbv0 ), ltree ), _lbv9 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), _lbv0 ), ltree ), _lbv8 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), apply int_gen  (, dummy ) ), ltree ), apply subs  (, s ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), _lbv0 ), ltree ), _lbv8 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv8 :: {v:Ty_int | (v) ==((s) -- (1))} | (_lbv8) ==((s) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((_lbv0) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                                          
# of Final Z3 expressions 20
 Final solver 
 (declare-sort T2505)
(declare-fun |0| () Int)
(declare-fun tlen (T2505) Int)
(declare-fun v () T2505)
(declare-fun _lbv0 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2505)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T2505)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2505)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1422 Int)
         (var_u1421 Int)
         (var_u1420 Int)
         (var_u1419 Int)
         (var_u1418 Int)
         (var_u1417 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1419 (+ _lbv0 1)) (= (tlen v) var_u1419))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= _lbv8 (- s 1))
         (= (tlen rtree) sizer)
         (=> (= var_u1422 (+ _lbv0 1)) (= (tlen v) var_u1422))))))
(assert (not (forall ((var_u1423 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), _lbv0 ), ltree ), _lbv8 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), _lbv0 ), ltree ), _lbv7 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), apply int_gen  (, dummy ) ), ltree ), apply subs  (, s01 ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), _lbv0 ), ltree ), _lbv7 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv7 :: {v:Ty_int | (v) ==((s01) -- (1))} | (_lbv7) ==((s01) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((_lbv0) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                                          
# of Final Z3 expressions 20
 Final solver 
 (declare-sort T2511)
(declare-fun |0| () Int)
(declare-fun tlen (T2511) Int)
(declare-fun v () T2511)
(declare-fun _lbv0 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2511)
(declare-fun s01 () Int)
(declare-fun _lbv7 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T2511)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2511)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1429 Int)
         (var_u1428 Int)
         (var_u1427 Int)
         (var_u1426 Int)
         (var_u1425 Int)
         (var_u1424 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1426 (+ _lbv0 1)) (= (tlen v) var_u1426))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= _lbv7 (- s01 1))
         (= (tlen rtree) sizer)
         (=> (= var_u1429 (+ _lbv0 1)) (= (tlen v) var_u1429))))))
(assert (not (forall ((var_u1430 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), _lbv0 ), ltree ), _lbv7 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), _lbv0 ), ltree ), _lbv6 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), apply int_gen  (, dummy ) ), ltree ), apply subs  (, root ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), _lbv0 ), ltree ), _lbv6 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv6 :: {v:Ty_int | (v) ==((root) -- (1))} | (_lbv6) ==((root) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((_lbv0) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                                          
# of Final Z3 expressions 20
 Final solver 
 (declare-sort T2517)
(declare-fun |0| () Int)
(declare-fun tlen (T2517) Int)
(declare-fun v () T2517)
(declare-fun _lbv0 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2517)
(declare-fun root () Int)
(declare-fun _lbv6 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T2517)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2517)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1436 Int)
         (var_u1435 Int)
         (var_u1434 Int)
         (var_u1433 Int)
         (var_u1432 Int)
         (var_u1431 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1433 (+ _lbv0 1)) (= (tlen v) var_u1433))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= _lbv6 (- root 1))
         (= (tlen rtree) sizer)
         (=> (= var_u1436 (+ _lbv0 1)) (= (tlen v) var_u1436))))))
(assert (not (forall ((var_u1437 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), _lbv0 ), ltree ), _lbv6 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), _lbv0 ), ltree ), s ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), apply int_gen  (, dummy ) ), ltree ), s ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), _lbv0 ), ltree ), s ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument s :: {var_v0:Ty_int | true} | true
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((_lbv0) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                                          
# of Final Z3 expressions 20
 Final solver 
 (declare-sort T2523)
(declare-fun |0| () Int)
(declare-fun tlen (T2523) Int)
(declare-fun v () T2523)
(declare-fun _lbv0 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2523)
(declare-fun sizel () Int)
(declare-fun ltree () T2523)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2523)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1443 Int)
         (var_u1442 Int)
         (var_u1441 Int)
         (var_u1440 Int)
         (var_u1439 Int)
         (var_u1438 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1440 (+ _lbv0 1)) (= (tlen v) var_u1440))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1443 (+ _lbv0 1)) (= (tlen v) var_u1443))))))
(assert (not (forall ((var_u1444 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), _lbv0 ), ltree ), s ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), _lbv0 ), ltree ), _lbv2 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), apply int_gen  (, dummy ) ), ltree ), apply subs  (, apply int_gen  (, dummy ) ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), _lbv0 ), ltree ), _lbv2 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv2 :: {v:Ty_int | (v) ==((_lbv0) -- (1))} | (_lbv2) ==((_lbv0) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((_lbv0) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                                          
# of Final Z3 expressions 20
 Final solver 
 (declare-sort T2529)
(declare-fun |0| () Int)
(declare-fun tlen (T2529) Int)
(declare-fun v () T2529)
(declare-fun _lbv0 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2529)
(declare-fun _lbv2 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T2529)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2529)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1450 Int)
         (var_u1449 Int)
         (var_u1448 Int)
         (var_u1447 Int)
         (var_u1446 Int)
         (var_u1445 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1447 (+ _lbv0 1)) (= (tlen v) var_u1447))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= _lbv2 (- _lbv0 1))
         (= (tlen rtree) sizer)
         (=> (= var_u1450 (+ _lbv0 1)) (= (tlen v) var_u1450))))))
(assert (not (forall ((var_u1451 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), _lbv0 ), ltree ), _lbv2 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), _lbv0 ), ltree ), _lbv1 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), apply int_gen  (, dummy ) ), ltree ), apply subs  (, s0 ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), _lbv0 ), ltree ), _lbv1 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((_lbv0) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                                          
# of Final Z3 expressions 20
 Final solver 
 (declare-sort T2535)
(declare-fun |0| () Int)
(declare-fun tlen (T2535) Int)
(declare-fun v () T2535)
(declare-fun _lbv0 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2535)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T2535)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2535)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1457 Int)
         (var_u1456 Int)
         (var_u1455 Int)
         (var_u1454 Int)
         (var_u1453 Int)
         (var_u1452 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1454 (+ _lbv0 1)) (= (tlen v) var_u1454))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= _lbv1 (- s0 1))
         (= (tlen rtree) sizer)
         (=> (= var_u1457 (+ _lbv0 1)) (= (tlen v) var_u1457))))))
(assert (not (forall ((var_u1458 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), _lbv0 ), ltree ), _lbv1 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), _lbv0 ), ltree ), _lbv0 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), apply int_gen  (, dummy ) ), ltree ), apply int_gen  (, dummy ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), _lbv0 ), ltree ), _lbv0 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((_lbv0) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                                                     
# of Final Z3 expressions 22
 Final solver 
 (declare-sort T2541)
(declare-fun |0| () Int)
(declare-fun tlen (T2541) Int)
(declare-fun v () T2541)
(declare-fun _lbv0 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2541)
(declare-fun sizel () Int)
(declare-fun ltree () T2541)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2541)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1464 Int)
         (var_u1463 Int)
         (var_u1462 Int)
         (var_u1461 Int)
         (var_u1460 Int)
         (var_u1459 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1461 (+ _lbv0 1)) (= (tlen v) var_u1461))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen rtree) sizer)
         (=> (= var_u1464 (+ _lbv0 1)) (= (tlen v) var_u1464))))))
(assert (not (forall ((var_u1465 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), _lbv0 ), ltree ), _lbv0 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), _lbv0 ), ltree ), s0 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), apply int_gen  (, dummy ) ), ltree ), s0 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), _lbv0 ), ltree ), s0 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument s0 :: {v:Ty_int | true} | true
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((_lbv0) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                                          
# of Final Z3 expressions 20
 Final solver 
 (declare-sort T2547)
(declare-fun |0| () Int)
(declare-fun tlen (T2547) Int)
(declare-fun v () T2547)
(declare-fun _lbv0 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2547)
(declare-fun sizel () Int)
(declare-fun ltree () T2547)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2547)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1471 Int)
         (var_u1470 Int)
         (var_u1469 Int)
         (var_u1468 Int)
         (var_u1467 Int)
         (var_u1466 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1468 (+ _lbv0 1)) (= (tlen v) var_u1468))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1471 (+ _lbv0 1)) (= (tlen v) var_u1471))))))
(assert (not (forall ((var_u1472 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), _lbv0 ), ltree ), s0 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), _lbv0 ), ltree ), _lbv1 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), apply int_gen  (, dummy ) ), ltree ), apply subs  (, s0 ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), _lbv0 ), ltree ), _lbv1 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((_lbv0) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                                          
# of Final Z3 expressions 20
 Final solver 
 (declare-sort T2553)
(declare-fun |0| () Int)
(declare-fun tlen (T2553) Int)
(declare-fun v () T2553)
(declare-fun _lbv0 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2553)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T2553)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2553)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1478 Int)
         (var_u1477 Int)
         (var_u1476 Int)
         (var_u1475 Int)
         (var_u1474 Int)
         (var_u1473 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1475 (+ _lbv0 1)) (= (tlen v) var_u1475))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= _lbv1 (- s0 1))
         (= (tlen rtree) sizer)
         (=> (= var_u1478 (+ _lbv0 1)) (= (tlen v) var_u1478))))))
(assert (not (forall ((var_u1479 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), _lbv0 ), ltree ), _lbv1 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), _lbv0 ), ltree ), _lbv2 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), apply int_gen  (, dummy ) ), ltree ), apply subs  (, apply int_gen  (, dummy ) ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), _lbv0 ), ltree ), _lbv2 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv2 :: {v:Ty_int | (v) ==((_lbv0) -- (1))} | (_lbv2) ==((_lbv0) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((_lbv0) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                                          
# of Final Z3 expressions 20
 Final solver 
 (declare-sort T2559)
(declare-fun |0| () Int)
(declare-fun tlen (T2559) Int)
(declare-fun v () T2559)
(declare-fun _lbv0 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2559)
(declare-fun _lbv2 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T2559)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2559)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1485 Int)
         (var_u1484 Int)
         (var_u1483 Int)
         (var_u1482 Int)
         (var_u1481 Int)
         (var_u1480 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1482 (+ _lbv0 1)) (= (tlen v) var_u1482))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= _lbv2 (- _lbv0 1))
         (= (tlen rtree) sizer)
         (=> (= var_u1485 (+ _lbv0 1)) (= (tlen v) var_u1485))))))
(assert (not (forall ((var_u1486 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), _lbv0 ), ltree ), _lbv2 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), _lbv0 ), ltree ), _lbv8 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), apply int_gen  (, dummy ) ), ltree ), apply subs  (, s ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), _lbv0 ), ltree ), _lbv8 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv8 :: {v:Ty_int | (v) ==((s) -- (1))} | (_lbv8) ==((s) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((_lbv0) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                                          
# of Final Z3 expressions 20
 Final solver 
 (declare-sort T2565)
(declare-fun |0| () Int)
(declare-fun tlen (T2565) Int)
(declare-fun v () T2565)
(declare-fun _lbv0 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2565)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T2565)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2565)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1492 Int)
         (var_u1491 Int)
         (var_u1490 Int)
         (var_u1489 Int)
         (var_u1488 Int)
         (var_u1487 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1489 (+ _lbv0 1)) (= (tlen v) var_u1489))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= _lbv8 (- s 1))
         (= (tlen rtree) sizer)
         (=> (= var_u1492 (+ _lbv0 1)) (= (tlen v) var_u1492))))))
(assert (not (forall ((var_u1493 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), _lbv0 ), ltree ), _lbv8 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), _lbv0 ), ltree ), _lbv7 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), apply int_gen  (, dummy ) ), ltree ), apply subs  (, s01 ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), _lbv0 ), ltree ), _lbv7 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv7 :: {v:Ty_int | (v) ==((s01) -- (1))} | (_lbv7) ==((s01) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((_lbv0) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                                          
# of Final Z3 expressions 20
 Final solver 
 (declare-sort T2571)
(declare-fun |0| () Int)
(declare-fun tlen (T2571) Int)
(declare-fun v () T2571)
(declare-fun _lbv0 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2571)
(declare-fun s01 () Int)
(declare-fun _lbv7 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T2571)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2571)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1499 Int)
         (var_u1498 Int)
         (var_u1497 Int)
         (var_u1496 Int)
         (var_u1495 Int)
         (var_u1494 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1496 (+ _lbv0 1)) (= (tlen v) var_u1496))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= _lbv7 (- s01 1))
         (= (tlen rtree) sizer)
         (=> (= var_u1499 (+ _lbv0 1)) (= (tlen v) var_u1499))))))
(assert (not (forall ((var_u1500 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), _lbv0 ), ltree ), _lbv7 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), _lbv0 ), ltree ), _lbv6 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), apply int_gen  (, dummy ) ), ltree ), apply subs  (, root ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), _lbv0 ), ltree ), _lbv6 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv6 :: {v:Ty_int | (v) ==((root) -- (1))} | (_lbv6) ==((root) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((_lbv0) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                                          
# of Final Z3 expressions 20
 Final solver 
 (declare-sort T2577)
(declare-fun |0| () Int)
(declare-fun tlen (T2577) Int)
(declare-fun v () T2577)
(declare-fun _lbv0 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2577)
(declare-fun root () Int)
(declare-fun _lbv6 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T2577)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2577)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1506 Int)
         (var_u1505 Int)
         (var_u1504 Int)
         (var_u1503 Int)
         (var_u1502 Int)
         (var_u1501 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1503 (+ _lbv0 1)) (= (tlen v) var_u1503))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= _lbv6 (- root 1))
         (= (tlen rtree) sizer)
         (=> (= var_u1506 (+ _lbv0 1)) (= (tlen v) var_u1506))))))
(assert (not (forall ((var_u1507 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), _lbv0 ), ltree ), _lbv6 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), _lbv0 ), ltree ), _lbv10 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), apply int_gen  (, dummy ) ), ltree ), apply subs  (, sizel ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), _lbv0 ), ltree ), _lbv10 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv10 :: {v:Ty_int | (v) ==((sizel) -- (1))} | (_lbv10) ==((sizel) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((_lbv0) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                                          
# of Final Z3 expressions 20
 Final solver 
 (declare-sort T2583)
(declare-fun |0| () Int)
(declare-fun tlen (T2583) Int)
(declare-fun v () T2583)
(declare-fun _lbv0 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2583)
(declare-fun sizel () Int)
(declare-fun _lbv10 () Int)
(declare-fun ltree () T2583)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2583)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1513 Int)
         (var_u1512 Int)
         (var_u1511 Int)
         (var_u1510 Int)
         (var_u1509 Int)
         (var_u1508 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1510 (+ _lbv0 1)) (= (tlen v) var_u1510))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= _lbv10 (- sizel 1))
         (= (tlen rtree) sizer)
         (=> (= var_u1513 (+ _lbv0 1)) (= (tlen v) var_u1513))))))
(assert (not (forall ((var_u1514 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), _lbv0 ), ltree ), _lbv10 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), _lbv0 ), ltree ), _lbv9 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), apply int_gen  (, dummy ) ), ltree ), apply subs  (, sizer ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), _lbv0 ), ltree ), _lbv9 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv9 :: {v:Ty_int | (v) ==((sizer) -- (1))} | (_lbv9) ==((sizer) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((_lbv0) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                                          
# of Final Z3 expressions 20
 Final solver 
 (declare-sort T2589)
(declare-fun |0| () Int)
(declare-fun tlen (T2589) Int)
(declare-fun v () T2589)
(declare-fun _lbv0 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2589)
(declare-fun _lbv9 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T2589)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2589)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1520 Int)
         (var_u1519 Int)
         (var_u1518 Int)
         (var_u1517 Int)
         (var_u1516 Int)
         (var_u1515 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1517 (+ _lbv0 1)) (= (tlen v) var_u1517))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= _lbv9 (- sizer 1))
         (= (tlen rtree) sizer)
         (=> (= var_u1520 (+ _lbv0 1)) (= (tlen v) var_u1520))))))
(assert (not (forall ((var_u1521 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), _lbv0 ), ltree ), _lbv9 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), s0 ), ltree ), sizer ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), s0 ), ltree ), sizer ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), s0 ), ltree ), sizer ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument s0 :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument sizer :: {v:Ty_int | true} | true
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((s0) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T2595)
(declare-fun |0| () Int)
(declare-fun tlen (T2595) Int)
(declare-fun v () T2595)
(declare-fun s0 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2595)
(declare-fun sizel () Int)
(declare-fun ltree () T2595)
(declare-fun _lbv0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2595)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1527 Int)
         (var_u1526 Int)
         (var_u1525 Int)
         (var_u1524 Int)
         (var_u1523 Int)
         (var_u1522 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1524 (+ s0 1)) (= (tlen v) var_u1524))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1527 (+ s0 1)) (= (tlen v) var_u1527))))))
(assert (not (forall ((var_u1528 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), s0 ), ltree ), sizer ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), s0 ), ltree ), sizel ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), s0 ), ltree ), sizel ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), s0 ), ltree ), sizel ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument s0 :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument sizel :: {v:Ty_int | true} | true
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((s0) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T2601)
(declare-fun |0| () Int)
(declare-fun tlen (T2601) Int)
(declare-fun v () T2601)
(declare-fun s0 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2601)
(declare-fun sizel () Int)
(declare-fun ltree () T2601)
(declare-fun _lbv0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2601)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1534 Int)
         (var_u1533 Int)
         (var_u1532 Int)
         (var_u1531 Int)
         (var_u1530 Int)
         (var_u1529 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1531 (+ s0 1)) (= (tlen v) var_u1531))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1534 (+ s0 1)) (= (tlen v) var_u1534))))))
(assert (not (forall ((var_u1535 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), s0 ), ltree ), sizel ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), s0 ), ltree ), root ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), s0 ), ltree ), root ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), s0 ), ltree ), root ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument s0 :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument root :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  root > 0
 	,   root = 0>d 
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((s0) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                                          
# of Final Z3 expressions 20
 Final solver 
 (declare-sort T2607)
(declare-fun |0| () Int)
(declare-fun tlen (T2607) Int)
(declare-fun v () T2607)
(declare-fun s0 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2607)
(declare-fun root () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T2607)
(declare-fun _lbv0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2607)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1541 Int)
         (var_u1540 Int)
         (var_u1539 Int)
         (var_u1538 Int)
         (var_u1537 Int)
         (var_u1536 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1538 (+ s0 1)) (= (tlen v) var_u1538))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (or (> root |0|) (= root |0|))
         (= (tlen rtree) sizer)
         (=> (= var_u1541 (+ s0 1)) (= (tlen v) var_u1541))))))
(assert (not (forall ((var_u1542 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), s0 ), ltree ), root ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), s0 ), ltree ), s01 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), s0 ), ltree ), s01 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), s0 ), ltree ), s01 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument s0 :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument s01 :: {v:Ty_int | 
 	 Conj <c true
 	 , s0 > v >c } | 
 	 Conj <c true
 	 , s0 > s01 >c 
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((s0) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                                    
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T2613)
(declare-fun |0| () Int)
(declare-fun tlen (T2613) Int)
(declare-fun v () T2613)
(declare-fun s0 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2613)
(declare-fun s01 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T2613)
(declare-fun _lbv0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2613)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1548 Int)
         (var_u1547 Int)
         (var_u1546 Int)
         (var_u1545 Int)
         (var_u1544 Int)
         (var_u1543 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1545 (+ s0 1)) (= (tlen v) var_u1545))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (> s0 s01)
         (= (tlen rtree) sizer)
         (=> (= var_u1548 (+ s0 1)) (= (tlen v) var_u1548))))))
(assert (not (forall ((var_u1549 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), s0 ), ltree ), s01 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), s0 ), ltree ), n ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), s0 ), ltree ), n ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), s0 ), ltree ), n ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument s0 :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument n :: {v:Ty_int | true} | true
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((s0) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T2619)
(declare-fun |0| () Int)
(declare-fun tlen (T2619) Int)
(declare-fun v () T2619)
(declare-fun s0 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2619)
(declare-fun sizel () Int)
(declare-fun ltree () T2619)
(declare-fun _lbv0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2619)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1555 Int)
         (var_u1554 Int)
         (var_u1553 Int)
         (var_u1552 Int)
         (var_u1551 Int)
         (var_u1550 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1552 (+ s0 1)) (= (tlen v) var_u1552))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1555 (+ s0 1)) (= (tlen v) var_u1555))))))
(assert (not (forall ((var_u1556 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), s0 ), ltree ), n ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), s0 ), ltree ), _lbv10 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), s0 ), ltree ), apply subs  (, sizel ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), s0 ), ltree ), _lbv10 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument s0 :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv10 :: {v:Ty_int | (v) ==((sizel) -- (1))} | (_lbv10) ==((sizel) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((s0) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T2625)
(declare-fun |0| () Int)
(declare-fun tlen (T2625) Int)
(declare-fun v () T2625)
(declare-fun s0 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2625)
(declare-fun sizel () Int)
(declare-fun _lbv10 () Int)
(declare-fun ltree () T2625)
(declare-fun _lbv0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2625)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1562 Int)
         (var_u1561 Int)
         (var_u1560 Int)
         (var_u1559 Int)
         (var_u1558 Int)
         (var_u1557 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1559 (+ s0 1)) (= (tlen v) var_u1559))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= _lbv10 (- sizel 1))
         (= (tlen rtree) sizer)
         (=> (= var_u1562 (+ s0 1)) (= (tlen v) var_u1562))))))
(assert (not (forall ((var_u1563 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), s0 ), ltree ), _lbv10 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), s0 ), ltree ), _lbv9 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), s0 ), ltree ), apply subs  (, sizer ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), s0 ), ltree ), _lbv9 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument s0 :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv9 :: {v:Ty_int | (v) ==((sizer) -- (1))} | (_lbv9) ==((sizer) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((s0) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T2631)
(declare-fun |0| () Int)
(declare-fun tlen (T2631) Int)
(declare-fun v () T2631)
(declare-fun s0 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2631)
(declare-fun _lbv9 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T2631)
(declare-fun _lbv0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2631)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1569 Int)
         (var_u1568 Int)
         (var_u1567 Int)
         (var_u1566 Int)
         (var_u1565 Int)
         (var_u1564 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1566 (+ s0 1)) (= (tlen v) var_u1566))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= _lbv9 (- sizer 1))
         (= (tlen rtree) sizer)
         (=> (= var_u1569 (+ s0 1)) (= (tlen v) var_u1569))))))
(assert (not (forall ((var_u1570 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), s0 ), ltree ), _lbv9 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), s0 ), ltree ), _lbv8 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), s0 ), ltree ), apply subs  (, s ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), s0 ), ltree ), _lbv8 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument s0 :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv8 :: {v:Ty_int | (v) ==((s) -- (1))} | (_lbv8) ==((s) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((s0) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T2637)
(declare-fun |0| () Int)
(declare-fun tlen (T2637) Int)
(declare-fun v () T2637)
(declare-fun s0 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2637)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T2637)
(declare-fun _lbv0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2637)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1576 Int)
         (var_u1575 Int)
         (var_u1574 Int)
         (var_u1573 Int)
         (var_u1572 Int)
         (var_u1571 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1573 (+ s0 1)) (= (tlen v) var_u1573))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= _lbv8 (- s 1))
         (= (tlen rtree) sizer)
         (=> (= var_u1576 (+ s0 1)) (= (tlen v) var_u1576))))))
(assert (not (forall ((var_u1577 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), s0 ), ltree ), _lbv8 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), s0 ), ltree ), _lbv7 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), s0 ), ltree ), apply subs  (, s01 ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), s0 ), ltree ), _lbv7 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument s0 :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv7 :: {v:Ty_int | (v) ==((s01) -- (1))} | (_lbv7) ==((s01) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((s0) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T2643)
(declare-fun |0| () Int)
(declare-fun tlen (T2643) Int)
(declare-fun v () T2643)
(declare-fun s0 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2643)
(declare-fun s01 () Int)
(declare-fun _lbv7 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T2643)
(declare-fun _lbv0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2643)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1583 Int)
         (var_u1582 Int)
         (var_u1581 Int)
         (var_u1580 Int)
         (var_u1579 Int)
         (var_u1578 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1580 (+ s0 1)) (= (tlen v) var_u1580))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= _lbv7 (- s01 1))
         (= (tlen rtree) sizer)
         (=> (= var_u1583 (+ s0 1)) (= (tlen v) var_u1583))))))
(assert (not (forall ((var_u1584 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), s0 ), ltree ), _lbv7 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), s0 ), ltree ), _lbv6 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), s0 ), ltree ), apply subs  (, root ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), s0 ), ltree ), _lbv6 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument s0 :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv6 :: {v:Ty_int | (v) ==((root) -- (1))} | (_lbv6) ==((root) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((s0) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T2649)
(declare-fun |0| () Int)
(declare-fun tlen (T2649) Int)
(declare-fun v () T2649)
(declare-fun s0 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2649)
(declare-fun root () Int)
(declare-fun _lbv6 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T2649)
(declare-fun _lbv0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2649)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1590 Int)
         (var_u1589 Int)
         (var_u1588 Int)
         (var_u1587 Int)
         (var_u1586 Int)
         (var_u1585 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1587 (+ s0 1)) (= (tlen v) var_u1587))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= _lbv6 (- root 1))
         (= (tlen rtree) sizer)
         (=> (= var_u1590 (+ s0 1)) (= (tlen v) var_u1590))))))
(assert (not (forall ((var_u1591 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), s0 ), ltree ), _lbv6 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), s0 ), ltree ), s ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), s0 ), ltree ), s ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), s0 ), ltree ), s ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument s0 :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument s :: {var_v0:Ty_int | true} | true
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((s0) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T2655)
(declare-fun |0| () Int)
(declare-fun tlen (T2655) Int)
(declare-fun v () T2655)
(declare-fun s0 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2655)
(declare-fun sizel () Int)
(declare-fun ltree () T2655)
(declare-fun _lbv0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2655)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1597 Int)
         (var_u1596 Int)
         (var_u1595 Int)
         (var_u1594 Int)
         (var_u1593 Int)
         (var_u1592 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1594 (+ s0 1)) (= (tlen v) var_u1594))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1597 (+ s0 1)) (= (tlen v) var_u1597))))))
(assert (not (forall ((var_u1598 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), s0 ), ltree ), s ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), s0 ), ltree ), _lbv2 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), s0 ), ltree ), apply subs  (, apply int_gen  (, dummy ) ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), s0 ), ltree ), _lbv2 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument s0 :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv2 :: {v:Ty_int | (v) ==((_lbv0) -- (1))} | (_lbv2) ==((_lbv0) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((s0) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T2661)
(declare-fun |0| () Int)
(declare-fun tlen (T2661) Int)
(declare-fun v () T2661)
(declare-fun s0 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2661)
(declare-fun _lbv0 () Int)
(declare-fun _lbv2 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T2661)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2661)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1604 Int)
         (var_u1603 Int)
         (var_u1602 Int)
         (var_u1601 Int)
         (var_u1600 Int)
         (var_u1599 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1601 (+ s0 1)) (= (tlen v) var_u1601))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= _lbv2 (- _lbv0 1))
         (= (tlen rtree) sizer)
         (=> (= var_u1604 (+ s0 1)) (= (tlen v) var_u1604))))))
(assert (not (forall ((var_u1605 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), s0 ), ltree ), _lbv2 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), s0 ), ltree ), _lbv1 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), s0 ), ltree ), apply subs  (, s0 ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), s0 ), ltree ), _lbv1 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument s0 :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((s0) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T2667)
(declare-fun |0| () Int)
(declare-fun tlen (T2667) Int)
(declare-fun v () T2667)
(declare-fun s0 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2667)
(declare-fun _lbv1 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T2667)
(declare-fun _lbv0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2667)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1611 Int)
         (var_u1610 Int)
         (var_u1609 Int)
         (var_u1608 Int)
         (var_u1607 Int)
         (var_u1606 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1608 (+ s0 1)) (= (tlen v) var_u1608))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= _lbv1 (- s0 1))
         (= (tlen rtree) sizer)
         (=> (= var_u1611 (+ s0 1)) (= (tlen v) var_u1611))))))
(assert (not (forall ((var_u1612 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), s0 ), ltree ), _lbv1 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), s0 ), ltree ), _lbv0 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), s0 ), ltree ), apply int_gen  (, dummy ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), s0 ), ltree ), _lbv0 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument s0 :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((s0) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                                          
# of Final Z3 expressions 20
 Final solver 
 (declare-sort T2673)
(declare-fun |0| () Int)
(declare-fun tlen (T2673) Int)
(declare-fun v () T2673)
(declare-fun s0 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2673)
(declare-fun _lbv0 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T2673)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2673)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1618 Int)
         (var_u1617 Int)
         (var_u1616 Int)
         (var_u1615 Int)
         (var_u1614 Int)
         (var_u1613 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1615 (+ s0 1)) (= (tlen v) var_u1615))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen rtree) sizer)
         (=> (= var_u1618 (+ s0 1)) (= (tlen v) var_u1618))))))
(assert (not (forall ((var_u1619 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), s0 ), ltree ), _lbv0 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), s0 ), ltree ), s0 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), s0 ), ltree ), s0 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), s0 ), ltree ), s0 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument s0 :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument s0 :: {v:Ty_int | true} | true
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((s0) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T2679)
(declare-fun |0| () Int)
(declare-fun tlen (T2679) Int)
(declare-fun v () T2679)
(declare-fun s0 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2679)
(declare-fun sizel () Int)
(declare-fun ltree () T2679)
(declare-fun _lbv0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2679)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1625 Int)
         (var_u1624 Int)
         (var_u1623 Int)
         (var_u1622 Int)
         (var_u1621 Int)
         (var_u1620 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1622 (+ s0 1)) (= (tlen v) var_u1622))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1625 (+ s0 1)) (= (tlen v) var_u1625))))))
(assert (not (forall ((var_u1626 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), s0 ), ltree ), s0 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), s0 ), ltree ), _lbv1 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), s0 ), ltree ), apply subs  (, s0 ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), s0 ), ltree ), _lbv1 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument s0 :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((s0) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T2685)
(declare-fun |0| () Int)
(declare-fun tlen (T2685) Int)
(declare-fun v () T2685)
(declare-fun s0 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2685)
(declare-fun _lbv1 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T2685)
(declare-fun _lbv0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2685)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1632 Int)
         (var_u1631 Int)
         (var_u1630 Int)
         (var_u1629 Int)
         (var_u1628 Int)
         (var_u1627 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1629 (+ s0 1)) (= (tlen v) var_u1629))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= _lbv1 (- s0 1))
         (= (tlen rtree) sizer)
         (=> (= var_u1632 (+ s0 1)) (= (tlen v) var_u1632))))))
(assert (not (forall ((var_u1633 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), s0 ), ltree ), _lbv1 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), s0 ), ltree ), _lbv2 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), s0 ), ltree ), apply subs  (, apply int_gen  (, dummy ) ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), s0 ), ltree ), _lbv2 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument s0 :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv2 :: {v:Ty_int | (v) ==((_lbv0) -- (1))} | (_lbv2) ==((_lbv0) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((s0) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T2691)
(declare-fun |0| () Int)
(declare-fun tlen (T2691) Int)
(declare-fun v () T2691)
(declare-fun s0 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2691)
(declare-fun _lbv0 () Int)
(declare-fun _lbv2 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T2691)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2691)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1639 Int)
         (var_u1638 Int)
         (var_u1637 Int)
         (var_u1636 Int)
         (var_u1635 Int)
         (var_u1634 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1636 (+ s0 1)) (= (tlen v) var_u1636))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= _lbv2 (- _lbv0 1))
         (= (tlen rtree) sizer)
         (=> (= var_u1639 (+ s0 1)) (= (tlen v) var_u1639))))))
(assert (not (forall ((var_u1640 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), s0 ), ltree ), _lbv2 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), s0 ), ltree ), _lbv8 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), s0 ), ltree ), apply subs  (, s ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), s0 ), ltree ), _lbv8 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument s0 :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv8 :: {v:Ty_int | (v) ==((s) -- (1))} | (_lbv8) ==((s) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((s0) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T2697)
(declare-fun |0| () Int)
(declare-fun tlen (T2697) Int)
(declare-fun v () T2697)
(declare-fun s0 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2697)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T2697)
(declare-fun _lbv0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2697)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1646 Int)
         (var_u1645 Int)
         (var_u1644 Int)
         (var_u1643 Int)
         (var_u1642 Int)
         (var_u1641 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1643 (+ s0 1)) (= (tlen v) var_u1643))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= _lbv8 (- s 1))
         (= (tlen rtree) sizer)
         (=> (= var_u1646 (+ s0 1)) (= (tlen v) var_u1646))))))
(assert (not (forall ((var_u1647 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), s0 ), ltree ), _lbv8 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), s0 ), ltree ), _lbv7 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), s0 ), ltree ), apply subs  (, s01 ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), s0 ), ltree ), _lbv7 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument s0 :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv7 :: {v:Ty_int | (v) ==((s01) -- (1))} | (_lbv7) ==((s01) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((s0) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T2703)
(declare-fun |0| () Int)
(declare-fun tlen (T2703) Int)
(declare-fun v () T2703)
(declare-fun s0 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2703)
(declare-fun s01 () Int)
(declare-fun _lbv7 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T2703)
(declare-fun _lbv0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2703)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1653 Int)
         (var_u1652 Int)
         (var_u1651 Int)
         (var_u1650 Int)
         (var_u1649 Int)
         (var_u1648 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1650 (+ s0 1)) (= (tlen v) var_u1650))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= _lbv7 (- s01 1))
         (= (tlen rtree) sizer)
         (=> (= var_u1653 (+ s0 1)) (= (tlen v) var_u1653))))))
(assert (not (forall ((var_u1654 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), s0 ), ltree ), _lbv7 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), s0 ), ltree ), _lbv6 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), s0 ), ltree ), apply subs  (, root ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), s0 ), ltree ), _lbv6 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument s0 :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv6 :: {v:Ty_int | (v) ==((root) -- (1))} | (_lbv6) ==((root) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((s0) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T2709)
(declare-fun |0| () Int)
(declare-fun tlen (T2709) Int)
(declare-fun v () T2709)
(declare-fun s0 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2709)
(declare-fun root () Int)
(declare-fun _lbv6 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T2709)
(declare-fun _lbv0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2709)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1660 Int)
         (var_u1659 Int)
         (var_u1658 Int)
         (var_u1657 Int)
         (var_u1656 Int)
         (var_u1655 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1657 (+ s0 1)) (= (tlen v) var_u1657))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= _lbv6 (- root 1))
         (= (tlen rtree) sizer)
         (=> (= var_u1660 (+ s0 1)) (= (tlen v) var_u1660))))))
(assert (not (forall ((var_u1661 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), s0 ), ltree ), _lbv6 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), s0 ), ltree ), _lbv10 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), s0 ), ltree ), apply subs  (, sizel ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), s0 ), ltree ), _lbv10 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument s0 :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv10 :: {v:Ty_int | (v) ==((sizel) -- (1))} | (_lbv10) ==((sizel) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((s0) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T2715)
(declare-fun |0| () Int)
(declare-fun tlen (T2715) Int)
(declare-fun v () T2715)
(declare-fun s0 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2715)
(declare-fun sizel () Int)
(declare-fun _lbv10 () Int)
(declare-fun ltree () T2715)
(declare-fun _lbv0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2715)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1667 Int)
         (var_u1666 Int)
         (var_u1665 Int)
         (var_u1664 Int)
         (var_u1663 Int)
         (var_u1662 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1664 (+ s0 1)) (= (tlen v) var_u1664))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= _lbv10 (- sizel 1))
         (= (tlen rtree) sizer)
         (=> (= var_u1667 (+ s0 1)) (= (tlen v) var_u1667))))))
(assert (not (forall ((var_u1668 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), s0 ), ltree ), _lbv10 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), s0 ), ltree ), _lbv9 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), s0 ), ltree ), apply subs  (, sizer ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), s0 ), ltree ), _lbv9 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument s0 :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv9 :: {v:Ty_int | (v) ==((sizer) -- (1))} | (_lbv9) ==((sizer) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((s0) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T2721)
(declare-fun |0| () Int)
(declare-fun tlen (T2721) Int)
(declare-fun v () T2721)
(declare-fun s0 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2721)
(declare-fun _lbv9 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T2721)
(declare-fun _lbv0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2721)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1674 Int)
         (var_u1673 Int)
         (var_u1672 Int)
         (var_u1671 Int)
         (var_u1670 Int)
         (var_u1669 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1671 (+ s0 1)) (= (tlen v) var_u1671))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= _lbv9 (- sizer 1))
         (= (tlen rtree) sizer)
         (=> (= var_u1674 (+ s0 1)) (= (tlen v) var_u1674))))))
(assert (not (forall ((var_u1675 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), s0 ), ltree ), _lbv9 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), _lbv0 ), ltree ), sizer ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), apply int_gen  (, dummy ) ), ltree ), sizer ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), _lbv0 ), ltree ), sizer ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument sizer :: {v:Ty_int | true} | true
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((_lbv0) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                                          
# of Final Z3 expressions 20
 Final solver 
 (declare-sort T2727)
(declare-fun |0| () Int)
(declare-fun tlen (T2727) Int)
(declare-fun v () T2727)
(declare-fun _lbv0 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2727)
(declare-fun sizel () Int)
(declare-fun ltree () T2727)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2727)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1681 Int)
         (var_u1680 Int)
         (var_u1679 Int)
         (var_u1678 Int)
         (var_u1677 Int)
         (var_u1676 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1678 (+ _lbv0 1)) (= (tlen v) var_u1678))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1681 (+ _lbv0 1)) (= (tlen v) var_u1681))))))
(assert (not (forall ((var_u1682 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), _lbv0 ), ltree ), sizer ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), _lbv0 ), ltree ), sizel ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), apply int_gen  (, dummy ) ), ltree ), sizel ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), _lbv0 ), ltree ), sizel ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument sizel :: {v:Ty_int | true} | true
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((_lbv0) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                                          
# of Final Z3 expressions 20
 Final solver 
 (declare-sort T2733)
(declare-fun |0| () Int)
(declare-fun tlen (T2733) Int)
(declare-fun v () T2733)
(declare-fun _lbv0 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2733)
(declare-fun sizel () Int)
(declare-fun ltree () T2733)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2733)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1688 Int)
         (var_u1687 Int)
         (var_u1686 Int)
         (var_u1685 Int)
         (var_u1684 Int)
         (var_u1683 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1685 (+ _lbv0 1)) (= (tlen v) var_u1685))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1688 (+ _lbv0 1)) (= (tlen v) var_u1688))))))
(assert (not (forall ((var_u1689 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), _lbv0 ), ltree ), sizel ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), _lbv0 ), ltree ), root ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), apply int_gen  (, dummy ) ), ltree ), root ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), _lbv0 ), ltree ), root ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument root :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  root > 0
 	,   root = 0>d 
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((_lbv0) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                                                     
# of Final Z3 expressions 22
 Final solver 
 (declare-sort T2739)
(declare-fun |0| () Int)
(declare-fun tlen (T2739) Int)
(declare-fun v () T2739)
(declare-fun _lbv0 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2739)
(declare-fun root () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T2739)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2739)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1695 Int)
         (var_u1694 Int)
         (var_u1693 Int)
         (var_u1692 Int)
         (var_u1691 Int)
         (var_u1690 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1692 (+ _lbv0 1)) (= (tlen v) var_u1692))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (or (> root |0|) (= root |0|))
         (= (tlen rtree) sizer)
         (=> (= var_u1695 (+ _lbv0 1)) (= (tlen v) var_u1695))))))
(assert (not (forall ((var_u1696 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), _lbv0 ), ltree ), root ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), _lbv0 ), ltree ), s01 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), apply int_gen  (, dummy ) ), ltree ), s01 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), _lbv0 ), ltree ), s01 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument s01 :: {v:Ty_int | 
 	 Conj <c true
 	 , s0 > v >c } | 
 	 Conj <c true
 	 , s0 > s01 >c 
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((_lbv0) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                                               
# of Final Z3 expressions 20
 Final solver 
 (declare-sort T2745)
(declare-fun |0| () Int)
(declare-fun tlen (T2745) Int)
(declare-fun v () T2745)
(declare-fun _lbv0 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2745)
(declare-fun s01 () Int)
(declare-fun s0 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T2745)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2745)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1702 Int)
         (var_u1701 Int)
         (var_u1700 Int)
         (var_u1699 Int)
         (var_u1698 Int)
         (var_u1697 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1699 (+ _lbv0 1)) (= (tlen v) var_u1699))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (> s0 s01)
         (= (tlen rtree) sizer)
         (=> (= var_u1702 (+ _lbv0 1)) (= (tlen v) var_u1702))))))
(assert (not (forall ((var_u1703 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), _lbv0 ), ltree ), s01 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), _lbv0 ), ltree ), n ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), apply int_gen  (, dummy ) ), ltree ), n ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), _lbv0 ), ltree ), n ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument n :: {v:Ty_int | true} | true
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((_lbv0) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                                          
# of Final Z3 expressions 20
 Final solver 
 (declare-sort T2751)
(declare-fun |0| () Int)
(declare-fun tlen (T2751) Int)
(declare-fun v () T2751)
(declare-fun _lbv0 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2751)
(declare-fun sizel () Int)
(declare-fun ltree () T2751)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2751)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1709 Int)
         (var_u1708 Int)
         (var_u1707 Int)
         (var_u1706 Int)
         (var_u1705 Int)
         (var_u1704 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1706 (+ _lbv0 1)) (= (tlen v) var_u1706))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1709 (+ _lbv0 1)) (= (tlen v) var_u1709))))))
(assert (not (forall ((var_u1710 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), _lbv0 ), ltree ), n ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), _lbv0 ), ltree ), _lbv10 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), apply int_gen  (, dummy ) ), ltree ), apply subs  (, sizel ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), _lbv0 ), ltree ), _lbv10 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv10 :: {v:Ty_int | (v) ==((sizel) -- (1))} | (_lbv10) ==((sizel) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((_lbv0) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                                          
# of Final Z3 expressions 20
 Final solver 
 (declare-sort T2757)
(declare-fun |0| () Int)
(declare-fun tlen (T2757) Int)
(declare-fun v () T2757)
(declare-fun _lbv0 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2757)
(declare-fun sizel () Int)
(declare-fun _lbv10 () Int)
(declare-fun ltree () T2757)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2757)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1716 Int)
         (var_u1715 Int)
         (var_u1714 Int)
         (var_u1713 Int)
         (var_u1712 Int)
         (var_u1711 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1713 (+ _lbv0 1)) (= (tlen v) var_u1713))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= _lbv10 (- sizel 1))
         (= (tlen rtree) sizer)
         (=> (= var_u1716 (+ _lbv0 1)) (= (tlen v) var_u1716))))))
(assert (not (forall ((var_u1717 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), _lbv0 ), ltree ), _lbv10 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), _lbv0 ), ltree ), _lbv9 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), apply int_gen  (, dummy ) ), ltree ), apply subs  (, sizer ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), _lbv0 ), ltree ), _lbv9 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv9 :: {v:Ty_int | (v) ==((sizer) -- (1))} | (_lbv9) ==((sizer) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((_lbv0) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                                          
# of Final Z3 expressions 20
 Final solver 
 (declare-sort T2763)
(declare-fun |0| () Int)
(declare-fun tlen (T2763) Int)
(declare-fun v () T2763)
(declare-fun _lbv0 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2763)
(declare-fun _lbv9 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T2763)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2763)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1723 Int)
         (var_u1722 Int)
         (var_u1721 Int)
         (var_u1720 Int)
         (var_u1719 Int)
         (var_u1718 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1720 (+ _lbv0 1)) (= (tlen v) var_u1720))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= _lbv9 (- sizer 1))
         (= (tlen rtree) sizer)
         (=> (= var_u1723 (+ _lbv0 1)) (= (tlen v) var_u1723))))))
(assert (not (forall ((var_u1724 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), _lbv0 ), ltree ), _lbv9 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), _lbv0 ), ltree ), _lbv8 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), apply int_gen  (, dummy ) ), ltree ), apply subs  (, s ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), _lbv0 ), ltree ), _lbv8 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv8 :: {v:Ty_int | (v) ==((s) -- (1))} | (_lbv8) ==((s) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((_lbv0) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                                          
# of Final Z3 expressions 20
 Final solver 
 (declare-sort T2769)
(declare-fun |0| () Int)
(declare-fun tlen (T2769) Int)
(declare-fun v () T2769)
(declare-fun _lbv0 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2769)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T2769)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2769)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1730 Int)
         (var_u1729 Int)
         (var_u1728 Int)
         (var_u1727 Int)
         (var_u1726 Int)
         (var_u1725 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1727 (+ _lbv0 1)) (= (tlen v) var_u1727))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= _lbv8 (- s 1))
         (= (tlen rtree) sizer)
         (=> (= var_u1730 (+ _lbv0 1)) (= (tlen v) var_u1730))))))
(assert (not (forall ((var_u1731 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), _lbv0 ), ltree ), _lbv8 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), _lbv0 ), ltree ), _lbv7 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), apply int_gen  (, dummy ) ), ltree ), apply subs  (, s01 ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), _lbv0 ), ltree ), _lbv7 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv7 :: {v:Ty_int | (v) ==((s01) -- (1))} | (_lbv7) ==((s01) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((_lbv0) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                                          
# of Final Z3 expressions 20
 Final solver 
 (declare-sort T2775)
(declare-fun |0| () Int)
(declare-fun tlen (T2775) Int)
(declare-fun v () T2775)
(declare-fun _lbv0 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2775)
(declare-fun s01 () Int)
(declare-fun _lbv7 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T2775)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2775)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1737 Int)
         (var_u1736 Int)
         (var_u1735 Int)
         (var_u1734 Int)
         (var_u1733 Int)
         (var_u1732 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1734 (+ _lbv0 1)) (= (tlen v) var_u1734))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= _lbv7 (- s01 1))
         (= (tlen rtree) sizer)
         (=> (= var_u1737 (+ _lbv0 1)) (= (tlen v) var_u1737))))))
(assert (not (forall ((var_u1738 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), _lbv0 ), ltree ), _lbv7 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), _lbv0 ), ltree ), _lbv6 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), apply int_gen  (, dummy ) ), ltree ), apply subs  (, root ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), _lbv0 ), ltree ), _lbv6 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv6 :: {v:Ty_int | (v) ==((root) -- (1))} | (_lbv6) ==((root) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((_lbv0) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                                          
# of Final Z3 expressions 20
 Final solver 
 (declare-sort T2781)
(declare-fun |0| () Int)
(declare-fun tlen (T2781) Int)
(declare-fun v () T2781)
(declare-fun _lbv0 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2781)
(declare-fun root () Int)
(declare-fun _lbv6 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T2781)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2781)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1744 Int)
         (var_u1743 Int)
         (var_u1742 Int)
         (var_u1741 Int)
         (var_u1740 Int)
         (var_u1739 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1741 (+ _lbv0 1)) (= (tlen v) var_u1741))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= _lbv6 (- root 1))
         (= (tlen rtree) sizer)
         (=> (= var_u1744 (+ _lbv0 1)) (= (tlen v) var_u1744))))))
(assert (not (forall ((var_u1745 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), _lbv0 ), ltree ), _lbv6 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), _lbv0 ), ltree ), s ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), apply int_gen  (, dummy ) ), ltree ), s ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), _lbv0 ), ltree ), s ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument s :: {var_v0:Ty_int | true} | true
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((_lbv0) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                                          
# of Final Z3 expressions 20
 Final solver 
 (declare-sort T2787)
(declare-fun |0| () Int)
(declare-fun tlen (T2787) Int)
(declare-fun v () T2787)
(declare-fun _lbv0 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2787)
(declare-fun sizel () Int)
(declare-fun ltree () T2787)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2787)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1751 Int)
         (var_u1750 Int)
         (var_u1749 Int)
         (var_u1748 Int)
         (var_u1747 Int)
         (var_u1746 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1748 (+ _lbv0 1)) (= (tlen v) var_u1748))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1751 (+ _lbv0 1)) (= (tlen v) var_u1751))))))
(assert (not (forall ((var_u1752 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), _lbv0 ), ltree ), s ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), _lbv0 ), ltree ), _lbv2 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), apply int_gen  (, dummy ) ), ltree ), apply subs  (, apply int_gen  (, dummy ) ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), _lbv0 ), ltree ), _lbv2 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv2 :: {v:Ty_int | (v) ==((_lbv0) -- (1))} | (_lbv2) ==((_lbv0) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((_lbv0) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                                          
# of Final Z3 expressions 20
 Final solver 
 (declare-sort T2793)
(declare-fun |0| () Int)
(declare-fun tlen (T2793) Int)
(declare-fun v () T2793)
(declare-fun _lbv0 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2793)
(declare-fun _lbv2 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T2793)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2793)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1758 Int)
         (var_u1757 Int)
         (var_u1756 Int)
         (var_u1755 Int)
         (var_u1754 Int)
         (var_u1753 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1755 (+ _lbv0 1)) (= (tlen v) var_u1755))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= _lbv2 (- _lbv0 1))
         (= (tlen rtree) sizer)
         (=> (= var_u1758 (+ _lbv0 1)) (= (tlen v) var_u1758))))))
(assert (not (forall ((var_u1759 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), _lbv0 ), ltree ), _lbv2 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), _lbv0 ), ltree ), _lbv1 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), apply int_gen  (, dummy ) ), ltree ), apply subs  (, s0 ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), _lbv0 ), ltree ), _lbv1 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((_lbv0) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                                          
# of Final Z3 expressions 20
 Final solver 
 (declare-sort T2799)
(declare-fun |0| () Int)
(declare-fun tlen (T2799) Int)
(declare-fun v () T2799)
(declare-fun _lbv0 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2799)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T2799)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2799)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1765 Int)
         (var_u1764 Int)
         (var_u1763 Int)
         (var_u1762 Int)
         (var_u1761 Int)
         (var_u1760 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1762 (+ _lbv0 1)) (= (tlen v) var_u1762))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= _lbv1 (- s0 1))
         (= (tlen rtree) sizer)
         (=> (= var_u1765 (+ _lbv0 1)) (= (tlen v) var_u1765))))))
(assert (not (forall ((var_u1766 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), _lbv0 ), ltree ), _lbv1 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), _lbv0 ), ltree ), _lbv0 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), apply int_gen  (, dummy ) ), ltree ), apply int_gen  (, dummy ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), _lbv0 ), ltree ), _lbv0 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((_lbv0) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                                                     
# of Final Z3 expressions 22
 Final solver 
 (declare-sort T2805)
(declare-fun |0| () Int)
(declare-fun tlen (T2805) Int)
(declare-fun v () T2805)
(declare-fun _lbv0 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2805)
(declare-fun sizel () Int)
(declare-fun ltree () T2805)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2805)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1772 Int)
         (var_u1771 Int)
         (var_u1770 Int)
         (var_u1769 Int)
         (var_u1768 Int)
         (var_u1767 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1769 (+ _lbv0 1)) (= (tlen v) var_u1769))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen rtree) sizer)
         (=> (= var_u1772 (+ _lbv0 1)) (= (tlen v) var_u1772))))))
(assert (not (forall ((var_u1773 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), _lbv0 ), ltree ), _lbv0 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), _lbv0 ), ltree ), s0 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), apply int_gen  (, dummy ) ), ltree ), s0 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), _lbv0 ), ltree ), s0 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument s0 :: {v:Ty_int | true} | true
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((_lbv0) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                                          
# of Final Z3 expressions 20
 Final solver 
 (declare-sort T2811)
(declare-fun |0| () Int)
(declare-fun tlen (T2811) Int)
(declare-fun v () T2811)
(declare-fun _lbv0 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2811)
(declare-fun sizel () Int)
(declare-fun ltree () T2811)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2811)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1779 Int)
         (var_u1778 Int)
         (var_u1777 Int)
         (var_u1776 Int)
         (var_u1775 Int)
         (var_u1774 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1776 (+ _lbv0 1)) (= (tlen v) var_u1776))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1779 (+ _lbv0 1)) (= (tlen v) var_u1779))))))
(assert (not (forall ((var_u1780 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), _lbv0 ), ltree ), s0 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), _lbv0 ), ltree ), _lbv1 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), apply int_gen  (, dummy ) ), ltree ), apply subs  (, s0 ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), _lbv0 ), ltree ), _lbv1 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((_lbv0) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                                          
# of Final Z3 expressions 20
 Final solver 
 (declare-sort T2817)
(declare-fun |0| () Int)
(declare-fun tlen (T2817) Int)
(declare-fun v () T2817)
(declare-fun _lbv0 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2817)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T2817)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2817)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1786 Int)
         (var_u1785 Int)
         (var_u1784 Int)
         (var_u1783 Int)
         (var_u1782 Int)
         (var_u1781 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1783 (+ _lbv0 1)) (= (tlen v) var_u1783))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= _lbv1 (- s0 1))
         (= (tlen rtree) sizer)
         (=> (= var_u1786 (+ _lbv0 1)) (= (tlen v) var_u1786))))))
(assert (not (forall ((var_u1787 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), _lbv0 ), ltree ), _lbv1 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), _lbv0 ), ltree ), _lbv2 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), apply int_gen  (, dummy ) ), ltree ), apply subs  (, apply int_gen  (, dummy ) ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), _lbv0 ), ltree ), _lbv2 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv2 :: {v:Ty_int | (v) ==((_lbv0) -- (1))} | (_lbv2) ==((_lbv0) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((_lbv0) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                                          
# of Final Z3 expressions 20
 Final solver 
 (declare-sort T2823)
(declare-fun |0| () Int)
(declare-fun tlen (T2823) Int)
(declare-fun v () T2823)
(declare-fun _lbv0 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2823)
(declare-fun _lbv2 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T2823)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2823)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1793 Int)
         (var_u1792 Int)
         (var_u1791 Int)
         (var_u1790 Int)
         (var_u1789 Int)
         (var_u1788 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1790 (+ _lbv0 1)) (= (tlen v) var_u1790))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= _lbv2 (- _lbv0 1))
         (= (tlen rtree) sizer)
         (=> (= var_u1793 (+ _lbv0 1)) (= (tlen v) var_u1793))))))
(assert (not (forall ((var_u1794 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), _lbv0 ), ltree ), _lbv2 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), _lbv0 ), ltree ), _lbv8 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), apply int_gen  (, dummy ) ), ltree ), apply subs  (, s ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), _lbv0 ), ltree ), _lbv8 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv8 :: {v:Ty_int | (v) ==((s) -- (1))} | (_lbv8) ==((s) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((_lbv0) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                                          
# of Final Z3 expressions 20
 Final solver 
 (declare-sort T2829)
(declare-fun |0| () Int)
(declare-fun tlen (T2829) Int)
(declare-fun v () T2829)
(declare-fun _lbv0 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2829)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T2829)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2829)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1800 Int)
         (var_u1799 Int)
         (var_u1798 Int)
         (var_u1797 Int)
         (var_u1796 Int)
         (var_u1795 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1797 (+ _lbv0 1)) (= (tlen v) var_u1797))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= _lbv8 (- s 1))
         (= (tlen rtree) sizer)
         (=> (= var_u1800 (+ _lbv0 1)) (= (tlen v) var_u1800))))))
(assert (not (forall ((var_u1801 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), _lbv0 ), ltree ), _lbv8 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), _lbv0 ), ltree ), _lbv7 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), apply int_gen  (, dummy ) ), ltree ), apply subs  (, s01 ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), _lbv0 ), ltree ), _lbv7 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv7 :: {v:Ty_int | (v) ==((s01) -- (1))} | (_lbv7) ==((s01) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((_lbv0) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                                          
# of Final Z3 expressions 20
 Final solver 
 (declare-sort T2835)
(declare-fun |0| () Int)
(declare-fun tlen (T2835) Int)
(declare-fun v () T2835)
(declare-fun _lbv0 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2835)
(declare-fun s01 () Int)
(declare-fun _lbv7 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T2835)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2835)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1807 Int)
         (var_u1806 Int)
         (var_u1805 Int)
         (var_u1804 Int)
         (var_u1803 Int)
         (var_u1802 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1804 (+ _lbv0 1)) (= (tlen v) var_u1804))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= _lbv7 (- s01 1))
         (= (tlen rtree) sizer)
         (=> (= var_u1807 (+ _lbv0 1)) (= (tlen v) var_u1807))))))
(assert (not (forall ((var_u1808 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), _lbv0 ), ltree ), _lbv7 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), _lbv0 ), ltree ), _lbv6 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), apply int_gen  (, dummy ) ), ltree ), apply subs  (, root ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), _lbv0 ), ltree ), _lbv6 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv6 :: {v:Ty_int | (v) ==((root) -- (1))} | (_lbv6) ==((root) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((_lbv0) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                                          
# of Final Z3 expressions 20
 Final solver 
 (declare-sort T2841)
(declare-fun |0| () Int)
(declare-fun tlen (T2841) Int)
(declare-fun v () T2841)
(declare-fun _lbv0 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2841)
(declare-fun root () Int)
(declare-fun _lbv6 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T2841)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2841)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1814 Int)
         (var_u1813 Int)
         (var_u1812 Int)
         (var_u1811 Int)
         (var_u1810 Int)
         (var_u1809 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1811 (+ _lbv0 1)) (= (tlen v) var_u1811))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= _lbv6 (- root 1))
         (= (tlen rtree) sizer)
         (=> (= var_u1814 (+ _lbv0 1)) (= (tlen v) var_u1814))))))
(assert (not (forall ((var_u1815 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), _lbv0 ), ltree ), _lbv6 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), _lbv0 ), ltree ), _lbv10 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), apply int_gen  (, dummy ) ), ltree ), apply subs  (, sizel ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), _lbv0 ), ltree ), _lbv10 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv10 :: {v:Ty_int | (v) ==((sizel) -- (1))} | (_lbv10) ==((sizel) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((_lbv0) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                                          
# of Final Z3 expressions 20
 Final solver 
 (declare-sort T2847)
(declare-fun |0| () Int)
(declare-fun tlen (T2847) Int)
(declare-fun v () T2847)
(declare-fun _lbv0 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2847)
(declare-fun sizel () Int)
(declare-fun _lbv10 () Int)
(declare-fun ltree () T2847)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2847)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1821 Int)
         (var_u1820 Int)
         (var_u1819 Int)
         (var_u1818 Int)
         (var_u1817 Int)
         (var_u1816 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1818 (+ _lbv0 1)) (= (tlen v) var_u1818))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= _lbv10 (- sizel 1))
         (= (tlen rtree) sizer)
         (=> (= var_u1821 (+ _lbv0 1)) (= (tlen v) var_u1821))))))
(assert (not (forall ((var_u1822 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), _lbv0 ), ltree ), _lbv10 ), rtree )
 Finding Already seen tree for apply node  (, _lbv0 ), _lbv0 ), ltree ), _lbv9 ), rtree )
 Typechecking apply node  (, apply int_gen  (, dummy ) ), apply int_gen  (, dummy ) ), ltree ), apply subs  (, sizer ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv0 ), _lbv0 ), ltree ), _lbv9 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv9 :: {v:Ty_int | (v) ==((sizer) -- (1))} | (_lbv9) ==((sizer) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((_lbv0) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                                          
# of Final Z3 expressions 20
 Final solver 
 (declare-sort T2853)
(declare-fun |0| () Int)
(declare-fun tlen (T2853) Int)
(declare-fun v () T2853)
(declare-fun _lbv0 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2853)
(declare-fun _lbv9 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T2853)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2853)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1828 Int)
         (var_u1827 Int)
         (var_u1826 Int)
         (var_u1825 Int)
         (var_u1824 Int)
         (var_u1823 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1825 (+ _lbv0 1)) (= (tlen v) var_u1825))
         (= var_v3 false)
         a!4
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= _lbv9 (- sizer 1))
         (= (tlen rtree) sizer)
         (=> (= var_u1828 (+ _lbv0 1)) (= (tlen v) var_u1828))))))
(assert (not (forall ((var_u1829 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv0 ), _lbv0 ), ltree ), _lbv9 ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), root ), ltree ), sizer ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), root ), ltree ), sizer ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), root ), ltree ), sizer ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument root :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  root > 0
 	,   root = 0>d 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument sizer :: {v:Ty_int | true} | true
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((_lbv1) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T2859)
(declare-fun |0| () Int)
(declare-fun tlen (T2859) Int)
(declare-fun v () T2859)
(declare-fun _lbv1 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2859)
(declare-fun sizel () Int)
(declare-fun ltree () T2859)
(declare-fun root () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T2859)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1835 Int)
         (var_u1834 Int)
         (var_u1833 Int)
         (var_u1832 Int)
         (var_u1831 Int)
         (var_u1830 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1832 (+ _lbv1 1)) (= (tlen v) var_u1832))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1835 (+ _lbv1 1)) (= (tlen v) var_u1835))))))
(assert (not (forall ((var_u1836 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), root ), ltree ), sizer ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), root ), ltree ), sizel ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), root ), ltree ), sizel ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), root ), ltree ), sizel ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument root :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  root > 0
 	,   root = 0>d 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument sizel :: {v:Ty_int | true} | true
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((_lbv1) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T2865)
(declare-fun |0| () Int)
(declare-fun tlen (T2865) Int)
(declare-fun v () T2865)
(declare-fun _lbv1 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2865)
(declare-fun sizel () Int)
(declare-fun ltree () T2865)
(declare-fun root () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T2865)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1842 Int)
         (var_u1841 Int)
         (var_u1840 Int)
         (var_u1839 Int)
         (var_u1838 Int)
         (var_u1837 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1839 (+ _lbv1 1)) (= (tlen v) var_u1839))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1842 (+ _lbv1 1)) (= (tlen v) var_u1842))))))
(assert (not (forall ((var_u1843 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), root ), ltree ), sizel ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), root ), ltree ), root ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), root ), ltree ), root ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), root ), ltree ), root ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument root :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  root > 0
 	,   root = 0>d 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument root :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  root > 0
 	,   root = 0>d 
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((_lbv1) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                                          
# of Final Z3 expressions 20
 Final solver 
 (declare-sort T2871)
(declare-fun |0| () Int)
(declare-fun tlen (T2871) Int)
(declare-fun v () T2871)
(declare-fun _lbv1 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2871)
(declare-fun root () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T2871)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T2871)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1849 Int)
         (var_u1848 Int)
         (var_u1847 Int)
         (var_u1846 Int)
         (var_u1845 Int)
         (var_u1844 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1846 (+ _lbv1 1)) (= (tlen v) var_u1846))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (or (> root |0|) (= root |0|))
         (= (tlen rtree) sizer)
         (=> (= var_u1849 (+ _lbv1 1)) (= (tlen v) var_u1849))))))
(assert (not (forall ((var_u1850 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), root ), ltree ), root ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), root ), ltree ), s01 ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), root ), ltree ), s01 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), root ), ltree ), s01 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument root :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  root > 0
 	,   root = 0>d 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument s01 :: {v:Ty_int | 
 	 Conj <c true
 	 , s0 > v >c } | 
 	 Conj <c true
 	 , s0 > s01 >c 
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((_lbv1) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                                    
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T2877)
(declare-fun |0| () Int)
(declare-fun tlen (T2877) Int)
(declare-fun v () T2877)
(declare-fun _lbv1 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2877)
(declare-fun s01 () Int)
(declare-fun s0 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T2877)
(declare-fun root () Int)
(declare-fun var_v3 () Bool)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T2877)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1856 Int)
         (var_u1855 Int)
         (var_u1854 Int)
         (var_u1853 Int)
         (var_u1852 Int)
         (var_u1851 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1853 (+ _lbv1 1)) (= (tlen v) var_u1853))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (> s0 s01)
         (= (tlen rtree) sizer)
         (=> (= var_u1856 (+ _lbv1 1)) (= (tlen v) var_u1856))))))
(assert (not (forall ((var_u1857 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), root ), ltree ), s01 ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), root ), ltree ), n ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), root ), ltree ), n ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), root ), ltree ), n ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument root :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  root > 0
 	,   root = 0>d 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument n :: {v:Ty_int | true} | true
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((_lbv1) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T2883)
(declare-fun |0| () Int)
(declare-fun tlen (T2883) Int)
(declare-fun v () T2883)
(declare-fun _lbv1 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2883)
(declare-fun sizel () Int)
(declare-fun ltree () T2883)
(declare-fun root () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T2883)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1863 Int)
         (var_u1862 Int)
         (var_u1861 Int)
         (var_u1860 Int)
         (var_u1859 Int)
         (var_u1858 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1860 (+ _lbv1 1)) (= (tlen v) var_u1860))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1863 (+ _lbv1 1)) (= (tlen v) var_u1863))))))
(assert (not (forall ((var_u1864 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), root ), ltree ), n ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), root ), ltree ), _lbv10 ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), root ), ltree ), apply subs  (, sizel ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), root ), ltree ), _lbv10 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument root :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  root > 0
 	,   root = 0>d 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv10 :: {v:Ty_int | (v) ==((sizel) -- (1))} | (_lbv10) ==((sizel) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((_lbv1) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T2889)
(declare-fun |0| () Int)
(declare-fun tlen (T2889) Int)
(declare-fun v () T2889)
(declare-fun _lbv1 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2889)
(declare-fun sizel () Int)
(declare-fun _lbv10 () Int)
(declare-fun ltree () T2889)
(declare-fun root () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T2889)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1870 Int)
         (var_u1869 Int)
         (var_u1868 Int)
         (var_u1867 Int)
         (var_u1866 Int)
         (var_u1865 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1867 (+ _lbv1 1)) (= (tlen v) var_u1867))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= _lbv10 (- sizel 1))
         (= (tlen rtree) sizer)
         (=> (= var_u1870 (+ _lbv1 1)) (= (tlen v) var_u1870))))))
(assert (not (forall ((var_u1871 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), root ), ltree ), _lbv10 ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), root ), ltree ), _lbv9 ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), root ), ltree ), apply subs  (, sizer ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), root ), ltree ), _lbv9 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument root :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  root > 0
 	,   root = 0>d 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv9 :: {v:Ty_int | (v) ==((sizer) -- (1))} | (_lbv9) ==((sizer) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((_lbv1) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T2895)
(declare-fun |0| () Int)
(declare-fun tlen (T2895) Int)
(declare-fun v () T2895)
(declare-fun _lbv1 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2895)
(declare-fun _lbv9 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T2895)
(declare-fun root () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T2895)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1877 Int)
         (var_u1876 Int)
         (var_u1875 Int)
         (var_u1874 Int)
         (var_u1873 Int)
         (var_u1872 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1874 (+ _lbv1 1)) (= (tlen v) var_u1874))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= _lbv9 (- sizer 1))
         (= (tlen rtree) sizer)
         (=> (= var_u1877 (+ _lbv1 1)) (= (tlen v) var_u1877))))))
(assert (not (forall ((var_u1878 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), root ), ltree ), _lbv9 ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), root ), ltree ), _lbv8 ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), root ), ltree ), apply subs  (, s ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), root ), ltree ), _lbv8 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument root :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  root > 0
 	,   root = 0>d 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv8 :: {v:Ty_int | (v) ==((s) -- (1))} | (_lbv8) ==((s) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((_lbv1) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T2901)
(declare-fun |0| () Int)
(declare-fun tlen (T2901) Int)
(declare-fun v () T2901)
(declare-fun _lbv1 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2901)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T2901)
(declare-fun root () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T2901)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1884 Int)
         (var_u1883 Int)
         (var_u1882 Int)
         (var_u1881 Int)
         (var_u1880 Int)
         (var_u1879 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1881 (+ _lbv1 1)) (= (tlen v) var_u1881))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= _lbv8 (- s 1))
         (= (tlen rtree) sizer)
         (=> (= var_u1884 (+ _lbv1 1)) (= (tlen v) var_u1884))))))
(assert (not (forall ((var_u1885 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), root ), ltree ), _lbv8 ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), root ), ltree ), _lbv7 ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), root ), ltree ), apply subs  (, s01 ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), root ), ltree ), _lbv7 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument root :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  root > 0
 	,   root = 0>d 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv7 :: {v:Ty_int | (v) ==((s01) -- (1))} | (_lbv7) ==((s01) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((_lbv1) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T2907)
(declare-fun |0| () Int)
(declare-fun tlen (T2907) Int)
(declare-fun v () T2907)
(declare-fun _lbv1 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2907)
(declare-fun s01 () Int)
(declare-fun _lbv7 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T2907)
(declare-fun root () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T2907)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1891 Int)
         (var_u1890 Int)
         (var_u1889 Int)
         (var_u1888 Int)
         (var_u1887 Int)
         (var_u1886 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1888 (+ _lbv1 1)) (= (tlen v) var_u1888))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= _lbv7 (- s01 1))
         (= (tlen rtree) sizer)
         (=> (= var_u1891 (+ _lbv1 1)) (= (tlen v) var_u1891))))))
(assert (not (forall ((var_u1892 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), root ), ltree ), _lbv7 ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), root ), ltree ), _lbv6 ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), root ), ltree ), apply subs  (, root ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), root ), ltree ), _lbv6 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument root :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  root > 0
 	,   root = 0>d 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv6 :: {v:Ty_int | (v) ==((root) -- (1))} | (_lbv6) ==((root) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((_lbv1) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T2913)
(declare-fun |0| () Int)
(declare-fun tlen (T2913) Int)
(declare-fun v () T2913)
(declare-fun _lbv1 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2913)
(declare-fun root () Int)
(declare-fun _lbv6 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T2913)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T2913)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1898 Int)
         (var_u1897 Int)
         (var_u1896 Int)
         (var_u1895 Int)
         (var_u1894 Int)
         (var_u1893 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1895 (+ _lbv1 1)) (= (tlen v) var_u1895))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= _lbv6 (- root 1))
         (= (tlen rtree) sizer)
         (=> (= var_u1898 (+ _lbv1 1)) (= (tlen v) var_u1898))))))
(assert (not (forall ((var_u1899 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), root ), ltree ), _lbv6 ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), root ), ltree ), s ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), root ), ltree ), s ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), root ), ltree ), s ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument root :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  root > 0
 	,   root = 0>d 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument s :: {var_v0:Ty_int | true} | true
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((_lbv1) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T2919)
(declare-fun |0| () Int)
(declare-fun tlen (T2919) Int)
(declare-fun v () T2919)
(declare-fun _lbv1 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2919)
(declare-fun sizel () Int)
(declare-fun ltree () T2919)
(declare-fun root () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T2919)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1905 Int)
         (var_u1904 Int)
         (var_u1903 Int)
         (var_u1902 Int)
         (var_u1901 Int)
         (var_u1900 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1902 (+ _lbv1 1)) (= (tlen v) var_u1902))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1905 (+ _lbv1 1)) (= (tlen v) var_u1905))))))
(assert (not (forall ((var_u1906 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), root ), ltree ), s ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), root ), ltree ), _lbv2 ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), root ), ltree ), apply subs  (, apply int_gen  (, dummy ) ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), root ), ltree ), _lbv2 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument root :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  root > 0
 	,   root = 0>d 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv2 :: {v:Ty_int | (v) ==((_lbv0) -- (1))} | (_lbv2) ==((_lbv0) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((_lbv1) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T2925)
(declare-fun |0| () Int)
(declare-fun tlen (T2925) Int)
(declare-fun v () T2925)
(declare-fun _lbv1 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2925)
(declare-fun _lbv0 () Int)
(declare-fun _lbv2 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T2925)
(declare-fun root () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2925)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1912 Int)
         (var_u1911 Int)
         (var_u1910 Int)
         (var_u1909 Int)
         (var_u1908 Int)
         (var_u1907 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1909 (+ _lbv1 1)) (= (tlen v) var_u1909))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= _lbv2 (- _lbv0 1))
         (= (tlen rtree) sizer)
         (=> (= var_u1912 (+ _lbv1 1)) (= (tlen v) var_u1912))))))
(assert (not (forall ((var_u1913 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), root ), ltree ), _lbv2 ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), root ), ltree ), _lbv1 ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), root ), ltree ), apply subs  (, s0 ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), root ), ltree ), _lbv1 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument root :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  root > 0
 	,   root = 0>d 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((_lbv1) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T2931)
(declare-fun |0| () Int)
(declare-fun tlen (T2931) Int)
(declare-fun v () T2931)
(declare-fun _lbv1 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2931)
(declare-fun s0 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T2931)
(declare-fun root () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T2931)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1919 Int)
         (var_u1918 Int)
         (var_u1917 Int)
         (var_u1916 Int)
         (var_u1915 Int)
         (var_u1914 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1916 (+ _lbv1 1)) (= (tlen v) var_u1916))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= _lbv1 (- s0 1))
         (= (tlen rtree) sizer)
         (=> (= var_u1919 (+ _lbv1 1)) (= (tlen v) var_u1919))))))
(assert (not (forall ((var_u1920 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), root ), ltree ), _lbv1 ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), root ), ltree ), _lbv0 ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), root ), ltree ), apply int_gen  (, dummy ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), root ), ltree ), _lbv0 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument root :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  root > 0
 	,   root = 0>d 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((_lbv1) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                                          
# of Final Z3 expressions 20
 Final solver 
 (declare-sort T2937)
(declare-fun |0| () Int)
(declare-fun tlen (T2937) Int)
(declare-fun v () T2937)
(declare-fun _lbv1 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2937)
(declare-fun _lbv0 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T2937)
(declare-fun root () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2937)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1926 Int)
         (var_u1925 Int)
         (var_u1924 Int)
         (var_u1923 Int)
         (var_u1922 Int)
         (var_u1921 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1923 (+ _lbv1 1)) (= (tlen v) var_u1923))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen rtree) sizer)
         (=> (= var_u1926 (+ _lbv1 1)) (= (tlen v) var_u1926))))))
(assert (not (forall ((var_u1927 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), root ), ltree ), _lbv0 ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), root ), ltree ), s0 ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), root ), ltree ), s0 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), root ), ltree ), s0 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument root :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  root > 0
 	,   root = 0>d 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument s0 :: {v:Ty_int | true} | true
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((_lbv1) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T2943)
(declare-fun |0| () Int)
(declare-fun tlen (T2943) Int)
(declare-fun v () T2943)
(declare-fun _lbv1 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2943)
(declare-fun sizel () Int)
(declare-fun ltree () T2943)
(declare-fun root () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T2943)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1933 Int)
         (var_u1932 Int)
         (var_u1931 Int)
         (var_u1930 Int)
         (var_u1929 Int)
         (var_u1928 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1930 (+ _lbv1 1)) (= (tlen v) var_u1930))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1933 (+ _lbv1 1)) (= (tlen v) var_u1933))))))
(assert (not (forall ((var_u1934 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), root ), ltree ), s0 ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), root ), ltree ), _lbv1 ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), root ), ltree ), apply subs  (, s0 ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), root ), ltree ), _lbv1 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument root :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  root > 0
 	,   root = 0>d 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((_lbv1) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T2949)
(declare-fun |0| () Int)
(declare-fun tlen (T2949) Int)
(declare-fun v () T2949)
(declare-fun _lbv1 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2949)
(declare-fun s0 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T2949)
(declare-fun root () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T2949)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1940 Int)
         (var_u1939 Int)
         (var_u1938 Int)
         (var_u1937 Int)
         (var_u1936 Int)
         (var_u1935 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1937 (+ _lbv1 1)) (= (tlen v) var_u1937))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= _lbv1 (- s0 1))
         (= (tlen rtree) sizer)
         (=> (= var_u1940 (+ _lbv1 1)) (= (tlen v) var_u1940))))))
(assert (not (forall ((var_u1941 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), root ), ltree ), _lbv1 ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), root ), ltree ), _lbv2 ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), root ), ltree ), apply subs  (, apply int_gen  (, dummy ) ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), root ), ltree ), _lbv2 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument root :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  root > 0
 	,   root = 0>d 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv2 :: {v:Ty_int | (v) ==((_lbv0) -- (1))} | (_lbv2) ==((_lbv0) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((_lbv1) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T2955)
(declare-fun |0| () Int)
(declare-fun tlen (T2955) Int)
(declare-fun v () T2955)
(declare-fun _lbv1 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2955)
(declare-fun _lbv0 () Int)
(declare-fun _lbv2 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T2955)
(declare-fun root () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T2955)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1947 Int)
         (var_u1946 Int)
         (var_u1945 Int)
         (var_u1944 Int)
         (var_u1943 Int)
         (var_u1942 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1944 (+ _lbv1 1)) (= (tlen v) var_u1944))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= _lbv2 (- _lbv0 1))
         (= (tlen rtree) sizer)
         (=> (= var_u1947 (+ _lbv1 1)) (= (tlen v) var_u1947))))))
(assert (not (forall ((var_u1948 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), root ), ltree ), _lbv2 ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), root ), ltree ), _lbv8 ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), root ), ltree ), apply subs  (, s ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), root ), ltree ), _lbv8 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument root :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  root > 0
 	,   root = 0>d 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv8 :: {v:Ty_int | (v) ==((s) -- (1))} | (_lbv8) ==((s) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((_lbv1) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T2961)
(declare-fun |0| () Int)
(declare-fun tlen (T2961) Int)
(declare-fun v () T2961)
(declare-fun _lbv1 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2961)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T2961)
(declare-fun root () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T2961)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1954 Int)
         (var_u1953 Int)
         (var_u1952 Int)
         (var_u1951 Int)
         (var_u1950 Int)
         (var_u1949 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1951 (+ _lbv1 1)) (= (tlen v) var_u1951))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= _lbv8 (- s 1))
         (= (tlen rtree) sizer)
         (=> (= var_u1954 (+ _lbv1 1)) (= (tlen v) var_u1954))))))
(assert (not (forall ((var_u1955 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), root ), ltree ), _lbv8 ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), root ), ltree ), _lbv7 ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), root ), ltree ), apply subs  (, s01 ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), root ), ltree ), _lbv7 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument root :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  root > 0
 	,   root = 0>d 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv7 :: {v:Ty_int | (v) ==((s01) -- (1))} | (_lbv7) ==((s01) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((_lbv1) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T2967)
(declare-fun |0| () Int)
(declare-fun tlen (T2967) Int)
(declare-fun v () T2967)
(declare-fun _lbv1 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2967)
(declare-fun s01 () Int)
(declare-fun _lbv7 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T2967)
(declare-fun root () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T2967)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1961 Int)
         (var_u1960 Int)
         (var_u1959 Int)
         (var_u1958 Int)
         (var_u1957 Int)
         (var_u1956 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1958 (+ _lbv1 1)) (= (tlen v) var_u1958))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= _lbv7 (- s01 1))
         (= (tlen rtree) sizer)
         (=> (= var_u1961 (+ _lbv1 1)) (= (tlen v) var_u1961))))))
(assert (not (forall ((var_u1962 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), root ), ltree ), _lbv7 ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), root ), ltree ), _lbv6 ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), root ), ltree ), apply subs  (, root ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), root ), ltree ), _lbv6 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument root :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  root > 0
 	,   root = 0>d 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv6 :: {v:Ty_int | (v) ==((root) -- (1))} | (_lbv6) ==((root) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((_lbv1) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T2973)
(declare-fun |0| () Int)
(declare-fun tlen (T2973) Int)
(declare-fun v () T2973)
(declare-fun _lbv1 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2973)
(declare-fun root () Int)
(declare-fun _lbv6 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T2973)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T2973)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1968 Int)
         (var_u1967 Int)
         (var_u1966 Int)
         (var_u1965 Int)
         (var_u1964 Int)
         (var_u1963 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1965 (+ _lbv1 1)) (= (tlen v) var_u1965))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= _lbv6 (- root 1))
         (= (tlen rtree) sizer)
         (=> (= var_u1968 (+ _lbv1 1)) (= (tlen v) var_u1968))))))
(assert (not (forall ((var_u1969 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), root ), ltree ), _lbv6 ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), root ), ltree ), _lbv10 ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), root ), ltree ), apply subs  (, sizel ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), root ), ltree ), _lbv10 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument root :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  root > 0
 	,   root = 0>d 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv10 :: {v:Ty_int | (v) ==((sizel) -- (1))} | (_lbv10) ==((sizel) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((_lbv1) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T2979)
(declare-fun |0| () Int)
(declare-fun tlen (T2979) Int)
(declare-fun v () T2979)
(declare-fun _lbv1 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2979)
(declare-fun sizel () Int)
(declare-fun _lbv10 () Int)
(declare-fun ltree () T2979)
(declare-fun root () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T2979)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1975 Int)
         (var_u1974 Int)
         (var_u1973 Int)
         (var_u1972 Int)
         (var_u1971 Int)
         (var_u1970 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1972 (+ _lbv1 1)) (= (tlen v) var_u1972))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= _lbv10 (- sizel 1))
         (= (tlen rtree) sizer)
         (=> (= var_u1975 (+ _lbv1 1)) (= (tlen v) var_u1975))))))
(assert (not (forall ((var_u1976 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), root ), ltree ), _lbv10 ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), root ), ltree ), _lbv9 ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), root ), ltree ), apply subs  (, sizer ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), root ), ltree ), _lbv9 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument root :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  root > 0
 	,   root = 0>d 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv9 :: {v:Ty_int | (v) ==((sizer) -- (1))} | (_lbv9) ==((sizer) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((_lbv1) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T2985)
(declare-fun |0| () Int)
(declare-fun tlen (T2985) Int)
(declare-fun v () T2985)
(declare-fun _lbv1 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2985)
(declare-fun _lbv9 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T2985)
(declare-fun root () Int)
(declare-fun s0 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T2985)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1982 Int)
         (var_u1981 Int)
         (var_u1980 Int)
         (var_u1979 Int)
         (var_u1978 Int)
         (var_u1977 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1979 (+ _lbv1 1)) (= (tlen v) var_u1979))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= _lbv9 (- sizer 1))
         (= (tlen rtree) sizer)
         (=> (= var_u1982 (+ _lbv1 1)) (= (tlen v) var_u1982))))))
(assert (not (forall ((var_u1983 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), root ), ltree ), _lbv9 ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), n ), ltree ), sizer ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), n ), ltree ), sizer ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), n ), ltree ), sizer ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument n :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument sizer :: {v:Ty_int | true} | true
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((n) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                    
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T2991)
(declare-fun |0| () Int)
(declare-fun tlen (T2991) Int)
(declare-fun v () T2991)
(declare-fun n () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2991)
(declare-fun sizel () Int)
(declare-fun ltree () T2991)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T2991)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1989 Int)
         (var_u1988 Int)
         (var_u1987 Int)
         (var_u1986 Int)
         (var_u1985 Int)
         (var_u1984 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1986 (+ n 1)) (= (tlen v) var_u1986))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1989 (+ n 1)) (= (tlen v) var_u1989))))))
(assert (not (forall ((var_u1990 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), n ), ltree ), sizer ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), n ), ltree ), sizel ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), n ), ltree ), sizel ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), n ), ltree ), sizel ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument n :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument sizel :: {v:Ty_int | true} | true
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((n) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                    
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T2997)
(declare-fun |0| () Int)
(declare-fun tlen (T2997) Int)
(declare-fun v () T2997)
(declare-fun n () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T2997)
(declare-fun sizel () Int)
(declare-fun ltree () T2997)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T2997)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u1996 Int)
         (var_u1995 Int)
         (var_u1994 Int)
         (var_u1993 Int)
         (var_u1992 Int)
         (var_u1991 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1993 (+ n 1)) (= (tlen v) var_u1993))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u1996 (+ n 1)) (= (tlen v) var_u1996))))))
(assert (not (forall ((var_u1997 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), n ), ltree ), sizel ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), n ), ltree ), root ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), n ), ltree ), root ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), n ), ltree ), root ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument n :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument root :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  root > 0
 	,   root = 0>d 
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((n) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T3003)
(declare-fun |0| () Int)
(declare-fun tlen (T3003) Int)
(declare-fun v () T3003)
(declare-fun n () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T3003)
(declare-fun root () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T3003)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T3003)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2003 Int)
         (var_u2002 Int)
         (var_u2001 Int)
         (var_u2000 Int)
         (var_u1999 Int)
         (var_u1998 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2000 (+ n 1)) (= (tlen v) var_u2000))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (= (tlen ltree) sizel)
         (or (> root |0|) (= root |0|))
         (= (tlen rtree) sizer)
         (=> (= var_u2003 (+ n 1)) (= (tlen v) var_u2003))))))
(assert (not (forall ((var_u2004 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), n ), ltree ), root ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), n ), ltree ), s01 ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), n ), ltree ), s01 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), n ), ltree ), s01 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument n :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument s01 :: {v:Ty_int | 
 	 Conj <c true
 	 , s0 > v >c } | 
 	 Conj <c true
 	 , s0 > s01 >c 
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((n) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                         
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T3009)
(declare-fun |0| () Int)
(declare-fun tlen (T3009) Int)
(declare-fun v () T3009)
(declare-fun n () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T3009)
(declare-fun s01 () Int)
(declare-fun s0 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T3009)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T3009)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2010 Int)
         (var_u2009 Int)
         (var_u2008 Int)
         (var_u2007 Int)
         (var_u2006 Int)
         (var_u2005 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2007 (+ n 1)) (= (tlen v) var_u2007))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (= (tlen ltree) sizel)
         (> s0 s01)
         (= (tlen rtree) sizer)
         (=> (= var_u2010 (+ n 1)) (= (tlen v) var_u2010))))))
(assert (not (forall ((var_u2011 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), n ), ltree ), s01 ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), n ), ltree ), n ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), n ), ltree ), n ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), n ), ltree ), n ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument n :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument n :: {v:Ty_int | true} | true
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((n) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                    
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T3015)
(declare-fun |0| () Int)
(declare-fun tlen (T3015) Int)
(declare-fun v () T3015)
(declare-fun n () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T3015)
(declare-fun sizel () Int)
(declare-fun ltree () T3015)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T3015)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2017 Int)
         (var_u2016 Int)
         (var_u2015 Int)
         (var_u2014 Int)
         (var_u2013 Int)
         (var_u2012 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2014 (+ n 1)) (= (tlen v) var_u2014))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2017 (+ n 1)) (= (tlen v) var_u2017))))))
(assert (not (forall ((var_u2018 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), n ), ltree ), n ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), n ), ltree ), _lbv10 ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), n ), ltree ), apply subs  (, sizel ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), n ), ltree ), _lbv10 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument n :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv10 :: {v:Ty_int | (v) ==((sizel) -- (1))} | (_lbv10) ==((sizel) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((n) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                    
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T3021)
(declare-fun |0| () Int)
(declare-fun tlen (T3021) Int)
(declare-fun v () T3021)
(declare-fun n () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T3021)
(declare-fun sizel () Int)
(declare-fun _lbv10 () Int)
(declare-fun ltree () T3021)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T3021)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2024 Int)
         (var_u2023 Int)
         (var_u2022 Int)
         (var_u2021 Int)
         (var_u2020 Int)
         (var_u2019 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2021 (+ n 1)) (= (tlen v) var_u2021))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (= (tlen ltree) sizel)
         (= _lbv10 (- sizel 1))
         (= (tlen rtree) sizer)
         (=> (= var_u2024 (+ n 1)) (= (tlen v) var_u2024))))))
(assert (not (forall ((var_u2025 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), n ), ltree ), _lbv10 ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), n ), ltree ), _lbv9 ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), n ), ltree ), apply subs  (, sizer ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), n ), ltree ), _lbv9 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument n :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv9 :: {v:Ty_int | (v) ==((sizer) -- (1))} | (_lbv9) ==((sizer) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((n) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                    
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T3027)
(declare-fun |0| () Int)
(declare-fun tlen (T3027) Int)
(declare-fun v () T3027)
(declare-fun n () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T3027)
(declare-fun _lbv9 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T3027)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T3027)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2031 Int)
         (var_u2030 Int)
         (var_u2029 Int)
         (var_u2028 Int)
         (var_u2027 Int)
         (var_u2026 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2028 (+ n 1)) (= (tlen v) var_u2028))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (= (tlen ltree) sizel)
         (= _lbv9 (- sizer 1))
         (= (tlen rtree) sizer)
         (=> (= var_u2031 (+ n 1)) (= (tlen v) var_u2031))))))
(assert (not (forall ((var_u2032 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), n ), ltree ), _lbv9 ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), n ), ltree ), _lbv8 ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), n ), ltree ), apply subs  (, s ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), n ), ltree ), _lbv8 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument n :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv8 :: {v:Ty_int | (v) ==((s) -- (1))} | (_lbv8) ==((s) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((n) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                    
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T3033)
(declare-fun |0| () Int)
(declare-fun tlen (T3033) Int)
(declare-fun v () T3033)
(declare-fun n () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T3033)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T3033)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T3033)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2038 Int)
         (var_u2037 Int)
         (var_u2036 Int)
         (var_u2035 Int)
         (var_u2034 Int)
         (var_u2033 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2035 (+ n 1)) (= (tlen v) var_u2035))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (= (tlen ltree) sizel)
         (= _lbv8 (- s 1))
         (= (tlen rtree) sizer)
         (=> (= var_u2038 (+ n 1)) (= (tlen v) var_u2038))))))
(assert (not (forall ((var_u2039 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), n ), ltree ), _lbv8 ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), n ), ltree ), _lbv7 ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), n ), ltree ), apply subs  (, s01 ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), n ), ltree ), _lbv7 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument n :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv7 :: {v:Ty_int | (v) ==((s01) -- (1))} | (_lbv7) ==((s01) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((n) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                    
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T3039)
(declare-fun |0| () Int)
(declare-fun tlen (T3039) Int)
(declare-fun v () T3039)
(declare-fun n () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T3039)
(declare-fun s01 () Int)
(declare-fun _lbv7 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T3039)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T3039)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2045 Int)
         (var_u2044 Int)
         (var_u2043 Int)
         (var_u2042 Int)
         (var_u2041 Int)
         (var_u2040 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2042 (+ n 1)) (= (tlen v) var_u2042))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (= (tlen ltree) sizel)
         (= _lbv7 (- s01 1))
         (= (tlen rtree) sizer)
         (=> (= var_u2045 (+ n 1)) (= (tlen v) var_u2045))))))
(assert (not (forall ((var_u2046 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), n ), ltree ), _lbv7 ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), n ), ltree ), _lbv6 ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), n ), ltree ), apply subs  (, root ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), n ), ltree ), _lbv6 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument n :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv6 :: {v:Ty_int | (v) ==((root) -- (1))} | (_lbv6) ==((root) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((n) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                    
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T3045)
(declare-fun |0| () Int)
(declare-fun tlen (T3045) Int)
(declare-fun v () T3045)
(declare-fun n () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T3045)
(declare-fun root () Int)
(declare-fun _lbv6 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T3045)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T3045)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2052 Int)
         (var_u2051 Int)
         (var_u2050 Int)
         (var_u2049 Int)
         (var_u2048 Int)
         (var_u2047 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2049 (+ n 1)) (= (tlen v) var_u2049))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (= (tlen ltree) sizel)
         (= _lbv6 (- root 1))
         (= (tlen rtree) sizer)
         (=> (= var_u2052 (+ n 1)) (= (tlen v) var_u2052))))))
(assert (not (forall ((var_u2053 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), n ), ltree ), _lbv6 ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), n ), ltree ), s ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), n ), ltree ), s ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), n ), ltree ), s ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument n :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument s :: {var_v0:Ty_int | true} | true
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((n) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                    
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T3051)
(declare-fun |0| () Int)
(declare-fun tlen (T3051) Int)
(declare-fun v () T3051)
(declare-fun n () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T3051)
(declare-fun sizel () Int)
(declare-fun ltree () T3051)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T3051)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2059 Int)
         (var_u2058 Int)
         (var_u2057 Int)
         (var_u2056 Int)
         (var_u2055 Int)
         (var_u2054 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2056 (+ n 1)) (= (tlen v) var_u2056))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2059 (+ n 1)) (= (tlen v) var_u2059))))))
(assert (not (forall ((var_u2060 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), n ), ltree ), s ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), n ), ltree ), _lbv2 ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), n ), ltree ), apply subs  (, apply int_gen  (, dummy ) ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), n ), ltree ), _lbv2 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument n :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv2 :: {v:Ty_int | (v) ==((_lbv0) -- (1))} | (_lbv2) ==((_lbv0) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((n) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                    
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T3057)
(declare-fun |0| () Int)
(declare-fun tlen (T3057) Int)
(declare-fun v () T3057)
(declare-fun n () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T3057)
(declare-fun _lbv0 () Int)
(declare-fun _lbv2 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T3057)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T3057)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2066 Int)
         (var_u2065 Int)
         (var_u2064 Int)
         (var_u2063 Int)
         (var_u2062 Int)
         (var_u2061 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2063 (+ n 1)) (= (tlen v) var_u2063))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (= (tlen ltree) sizel)
         (= _lbv2 (- _lbv0 1))
         (= (tlen rtree) sizer)
         (=> (= var_u2066 (+ n 1)) (= (tlen v) var_u2066))))))
(assert (not (forall ((var_u2067 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), n ), ltree ), _lbv2 ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), n ), ltree ), _lbv1 ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), n ), ltree ), apply subs  (, s0 ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), n ), ltree ), _lbv1 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument n :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((n) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                    
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T3063)
(declare-fun |0| () Int)
(declare-fun tlen (T3063) Int)
(declare-fun v () T3063)
(declare-fun n () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T3063)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T3063)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T3063)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2073 Int)
         (var_u2072 Int)
         (var_u2071 Int)
         (var_u2070 Int)
         (var_u2069 Int)
         (var_u2068 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2070 (+ n 1)) (= (tlen v) var_u2070))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (= (tlen ltree) sizel)
         (= _lbv1 (- s0 1))
         (= (tlen rtree) sizer)
         (=> (= var_u2073 (+ n 1)) (= (tlen v) var_u2073))))))
(assert (not (forall ((var_u2074 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), n ), ltree ), _lbv1 ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), n ), ltree ), _lbv0 ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), n ), ltree ), apply int_gen  (, dummy ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), n ), ltree ), _lbv0 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument n :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((n) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T3069)
(declare-fun |0| () Int)
(declare-fun tlen (T3069) Int)
(declare-fun v () T3069)
(declare-fun n () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T3069)
(declare-fun _lbv0 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T3069)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T3069)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2080 Int)
         (var_u2079 Int)
         (var_u2078 Int)
         (var_u2077 Int)
         (var_u2076 Int)
         (var_u2075 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2077 (+ n 1)) (= (tlen v) var_u2077))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (= (tlen ltree) sizel)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen rtree) sizer)
         (=> (= var_u2080 (+ n 1)) (= (tlen v) var_u2080))))))
(assert (not (forall ((var_u2081 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), n ), ltree ), _lbv0 ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), n ), ltree ), s0 ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), n ), ltree ), s0 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), n ), ltree ), s0 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument n :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument s0 :: {v:Ty_int | true} | true
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((n) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                    
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T3075)
(declare-fun |0| () Int)
(declare-fun tlen (T3075) Int)
(declare-fun v () T3075)
(declare-fun n () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T3075)
(declare-fun sizel () Int)
(declare-fun ltree () T3075)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T3075)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2087 Int)
         (var_u2086 Int)
         (var_u2085 Int)
         (var_u2084 Int)
         (var_u2083 Int)
         (var_u2082 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2084 (+ n 1)) (= (tlen v) var_u2084))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2087 (+ n 1)) (= (tlen v) var_u2087))))))
(assert (not (forall ((var_u2088 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), n ), ltree ), s0 ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), n ), ltree ), _lbv1 ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), n ), ltree ), apply subs  (, s0 ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), n ), ltree ), _lbv1 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument n :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((n) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                    
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T3081)
(declare-fun |0| () Int)
(declare-fun tlen (T3081) Int)
(declare-fun v () T3081)
(declare-fun n () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T3081)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T3081)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T3081)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2094 Int)
         (var_u2093 Int)
         (var_u2092 Int)
         (var_u2091 Int)
         (var_u2090 Int)
         (var_u2089 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2091 (+ n 1)) (= (tlen v) var_u2091))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (= (tlen ltree) sizel)
         (= _lbv1 (- s0 1))
         (= (tlen rtree) sizer)
         (=> (= var_u2094 (+ n 1)) (= (tlen v) var_u2094))))))
(assert (not (forall ((var_u2095 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), n ), ltree ), _lbv1 ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), n ), ltree ), _lbv2 ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), n ), ltree ), apply subs  (, apply int_gen  (, dummy ) ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), n ), ltree ), _lbv2 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument n :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv2 :: {v:Ty_int | (v) ==((_lbv0) -- (1))} | (_lbv2) ==((_lbv0) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((n) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                    
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T3087)
(declare-fun |0| () Int)
(declare-fun tlen (T3087) Int)
(declare-fun v () T3087)
(declare-fun n () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T3087)
(declare-fun _lbv0 () Int)
(declare-fun _lbv2 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T3087)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T3087)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2101 Int)
         (var_u2100 Int)
         (var_u2099 Int)
         (var_u2098 Int)
         (var_u2097 Int)
         (var_u2096 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2098 (+ n 1)) (= (tlen v) var_u2098))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (= (tlen ltree) sizel)
         (= _lbv2 (- _lbv0 1))
         (= (tlen rtree) sizer)
         (=> (= var_u2101 (+ n 1)) (= (tlen v) var_u2101))))))
(assert (not (forall ((var_u2102 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), n ), ltree ), _lbv2 ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), n ), ltree ), _lbv8 ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), n ), ltree ), apply subs  (, s ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), n ), ltree ), _lbv8 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument n :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv8 :: {v:Ty_int | (v) ==((s) -- (1))} | (_lbv8) ==((s) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((n) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                    
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T3093)
(declare-fun |0| () Int)
(declare-fun tlen (T3093) Int)
(declare-fun v () T3093)
(declare-fun n () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T3093)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T3093)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T3093)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2108 Int)
         (var_u2107 Int)
         (var_u2106 Int)
         (var_u2105 Int)
         (var_u2104 Int)
         (var_u2103 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2105 (+ n 1)) (= (tlen v) var_u2105))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (= (tlen ltree) sizel)
         (= _lbv8 (- s 1))
         (= (tlen rtree) sizer)
         (=> (= var_u2108 (+ n 1)) (= (tlen v) var_u2108))))))
(assert (not (forall ((var_u2109 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), n ), ltree ), _lbv8 ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), n ), ltree ), _lbv7 ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), n ), ltree ), apply subs  (, s01 ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), n ), ltree ), _lbv7 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument n :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv7 :: {v:Ty_int | (v) ==((s01) -- (1))} | (_lbv7) ==((s01) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((n) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                    
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T3099)
(declare-fun |0| () Int)
(declare-fun tlen (T3099) Int)
(declare-fun v () T3099)
(declare-fun n () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T3099)
(declare-fun s01 () Int)
(declare-fun _lbv7 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T3099)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T3099)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2115 Int)
         (var_u2114 Int)
         (var_u2113 Int)
         (var_u2112 Int)
         (var_u2111 Int)
         (var_u2110 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2112 (+ n 1)) (= (tlen v) var_u2112))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (= (tlen ltree) sizel)
         (= _lbv7 (- s01 1))
         (= (tlen rtree) sizer)
         (=> (= var_u2115 (+ n 1)) (= (tlen v) var_u2115))))))
(assert (not (forall ((var_u2116 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), n ), ltree ), _lbv7 ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), n ), ltree ), _lbv6 ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), n ), ltree ), apply subs  (, root ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), n ), ltree ), _lbv6 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument n :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv6 :: {v:Ty_int | (v) ==((root) -- (1))} | (_lbv6) ==((root) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((n) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                    
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T3105)
(declare-fun |0| () Int)
(declare-fun tlen (T3105) Int)
(declare-fun v () T3105)
(declare-fun n () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T3105)
(declare-fun root () Int)
(declare-fun _lbv6 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T3105)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T3105)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2122 Int)
         (var_u2121 Int)
         (var_u2120 Int)
         (var_u2119 Int)
         (var_u2118 Int)
         (var_u2117 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2119 (+ n 1)) (= (tlen v) var_u2119))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (= (tlen ltree) sizel)
         (= _lbv6 (- root 1))
         (= (tlen rtree) sizer)
         (=> (= var_u2122 (+ n 1)) (= (tlen v) var_u2122))))))
(assert (not (forall ((var_u2123 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), n ), ltree ), _lbv6 ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), n ), ltree ), _lbv10 ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), n ), ltree ), apply subs  (, sizel ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), n ), ltree ), _lbv10 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument n :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv10 :: {v:Ty_int | (v) ==((sizel) -- (1))} | (_lbv10) ==((sizel) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((n) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                    
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T3111)
(declare-fun |0| () Int)
(declare-fun tlen (T3111) Int)
(declare-fun v () T3111)
(declare-fun n () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T3111)
(declare-fun sizel () Int)
(declare-fun _lbv10 () Int)
(declare-fun ltree () T3111)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T3111)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2129 Int)
         (var_u2128 Int)
         (var_u2127 Int)
         (var_u2126 Int)
         (var_u2125 Int)
         (var_u2124 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2126 (+ n 1)) (= (tlen v) var_u2126))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (= (tlen ltree) sizel)
         (= _lbv10 (- sizel 1))
         (= (tlen rtree) sizer)
         (=> (= var_u2129 (+ n 1)) (= (tlen v) var_u2129))))))
(assert (not (forall ((var_u2130 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), n ), ltree ), _lbv10 ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), n ), ltree ), _lbv9 ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), n ), ltree ), apply subs  (, sizer ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), n ), ltree ), _lbv9 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument n :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv9 :: {v:Ty_int | (v) ==((sizer) -- (1))} | (_lbv9) ==((sizer) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((n) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                    
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T3117)
(declare-fun |0| () Int)
(declare-fun tlen (T3117) Int)
(declare-fun v () T3117)
(declare-fun n () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T3117)
(declare-fun _lbv9 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T3117)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T3117)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2136 Int)
         (var_u2135 Int)
         (var_u2134 Int)
         (var_u2133 Int)
         (var_u2132 Int)
         (var_u2131 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2133 (+ n 1)) (= (tlen v) var_u2133))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (= (tlen ltree) sizel)
         (= _lbv9 (- sizer 1))
         (= (tlen rtree) sizer)
         (=> (= var_u2136 (+ n 1)) (= (tlen v) var_u2136))))))
(assert (not (forall ((var_u2137 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), n ), ltree ), _lbv9 ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), s01 ), ltree ), sizer ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), s01 ), ltree ), sizer ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), s01 ), ltree ), sizer ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument s01 :: {v:Ty_int | 
 	 Conj <c true
 	 , s0 > v >c } | 
 	 Conj <c true
 	 , s0 > s01 >c 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument sizer :: {v:Ty_int | true} | true
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((s01) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                         
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T3123)
(declare-fun |0| () Int)
(declare-fun tlen (T3123) Int)
(declare-fun v () T3123)
(declare-fun s01 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T3123)
(declare-fun sizel () Int)
(declare-fun ltree () T3123)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T3123)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2143 Int)
         (var_u2142 Int)
         (var_u2141 Int)
         (var_u2140 Int)
         (var_u2139 Int)
         (var_u2138 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2140 (+ s01 1)) (= (tlen v) var_u2140))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (> s0 s01)
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2143 (+ s01 1)) (= (tlen v) var_u2143))))))
(assert (not (forall ((var_u2144 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), s01 ), ltree ), sizer ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), s01 ), ltree ), sizel ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), s01 ), ltree ), sizel ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), s01 ), ltree ), sizel ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument s01 :: {v:Ty_int | 
 	 Conj <c true
 	 , s0 > v >c } | 
 	 Conj <c true
 	 , s0 > s01 >c 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument sizel :: {v:Ty_int | true} | true
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((s01) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                         
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T3129)
(declare-fun |0| () Int)
(declare-fun tlen (T3129) Int)
(declare-fun v () T3129)
(declare-fun s01 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T3129)
(declare-fun sizel () Int)
(declare-fun ltree () T3129)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T3129)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2150 Int)
         (var_u2149 Int)
         (var_u2148 Int)
         (var_u2147 Int)
         (var_u2146 Int)
         (var_u2145 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2147 (+ s01 1)) (= (tlen v) var_u2147))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (> s0 s01)
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2150 (+ s01 1)) (= (tlen v) var_u2150))))))
(assert (not (forall ((var_u2151 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), s01 ), ltree ), sizel ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), s01 ), ltree ), root ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), s01 ), ltree ), root ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), s01 ), ltree ), root ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument s01 :: {v:Ty_int | 
 	 Conj <c true
 	 , s0 > v >c } | 
 	 Conj <c true
 	 , s0 > s01 >c 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument root :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  root > 0
 	,   root = 0>d 
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((s01) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                                    
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T3135)
(declare-fun |0| () Int)
(declare-fun tlen (T3135) Int)
(declare-fun v () T3135)
(declare-fun s01 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T3135)
(declare-fun root () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T3135)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T3135)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2157 Int)
         (var_u2156 Int)
         (var_u2155 Int)
         (var_u2154 Int)
         (var_u2153 Int)
         (var_u2152 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2154 (+ s01 1)) (= (tlen v) var_u2154))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (> s0 s01)
         (= (tlen ltree) sizel)
         (or (> root |0|) (= root |0|))
         (= (tlen rtree) sizer)
         (=> (= var_u2157 (+ s01 1)) (= (tlen v) var_u2157))))))
(assert (not (forall ((var_u2158 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), s01 ), ltree ), root ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), s01 ), ltree ), s01 ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), s01 ), ltree ), s01 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), s01 ), ltree ), s01 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument s01 :: {v:Ty_int | 
 	 Conj <c true
 	 , s0 > v >c } | 
 	 Conj <c true
 	 , s0 > s01 >c 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument s01 :: {v:Ty_int | 
 	 Conj <c true
 	 , s0 > v >c } | 
 	 Conj <c true
 	 , s0 > s01 >c 
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((s01) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                              
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T3141)
(declare-fun |0| () Int)
(declare-fun tlen (T3141) Int)
(declare-fun v () T3141)
(declare-fun s01 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T3141)
(declare-fun s0 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T3141)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T3141)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2164 Int)
         (var_u2163 Int)
         (var_u2162 Int)
         (var_u2161 Int)
         (var_u2160 Int)
         (var_u2159 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2161 (+ s01 1)) (= (tlen v) var_u2161))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (> s0 s01)
         (= (tlen ltree) sizel)
         (> s0 s01)
         (= (tlen rtree) sizer)
         (=> (= var_u2164 (+ s01 1)) (= (tlen v) var_u2164))))))
(assert (not (forall ((var_u2165 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), s01 ), ltree ), s01 ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), s01 ), ltree ), n ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), s01 ), ltree ), n ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), s01 ), ltree ), n ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument s01 :: {v:Ty_int | 
 	 Conj <c true
 	 , s0 > v >c } | 
 	 Conj <c true
 	 , s0 > s01 >c 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument n :: {v:Ty_int | true} | true
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((s01) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                         
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T3147)
(declare-fun |0| () Int)
(declare-fun tlen (T3147) Int)
(declare-fun v () T3147)
(declare-fun s01 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T3147)
(declare-fun sizel () Int)
(declare-fun ltree () T3147)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T3147)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2171 Int)
         (var_u2170 Int)
         (var_u2169 Int)
         (var_u2168 Int)
         (var_u2167 Int)
         (var_u2166 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2168 (+ s01 1)) (= (tlen v) var_u2168))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (> s0 s01)
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2171 (+ s01 1)) (= (tlen v) var_u2171))))))
(assert (not (forall ((var_u2172 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), s01 ), ltree ), n ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), s01 ), ltree ), _lbv10 ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), s01 ), ltree ), apply subs  (, sizel ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), s01 ), ltree ), _lbv10 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument s01 :: {v:Ty_int | 
 	 Conj <c true
 	 , s0 > v >c } | 
 	 Conj <c true
 	 , s0 > s01 >c 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv10 :: {v:Ty_int | (v) ==((sizel) -- (1))} | (_lbv10) ==((sizel) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((s01) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                         
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T3153)
(declare-fun |0| () Int)
(declare-fun tlen (T3153) Int)
(declare-fun v () T3153)
(declare-fun s01 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T3153)
(declare-fun sizel () Int)
(declare-fun _lbv10 () Int)
(declare-fun ltree () T3153)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T3153)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2178 Int)
         (var_u2177 Int)
         (var_u2176 Int)
         (var_u2175 Int)
         (var_u2174 Int)
         (var_u2173 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2175 (+ s01 1)) (= (tlen v) var_u2175))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (> s0 s01)
         (= (tlen ltree) sizel)
         (= _lbv10 (- sizel 1))
         (= (tlen rtree) sizer)
         (=> (= var_u2178 (+ s01 1)) (= (tlen v) var_u2178))))))
(assert (not (forall ((var_u2179 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), s01 ), ltree ), _lbv10 ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), s01 ), ltree ), _lbv9 ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), s01 ), ltree ), apply subs  (, sizer ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), s01 ), ltree ), _lbv9 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument s01 :: {v:Ty_int | 
 	 Conj <c true
 	 , s0 > v >c } | 
 	 Conj <c true
 	 , s0 > s01 >c 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv9 :: {v:Ty_int | (v) ==((sizer) -- (1))} | (_lbv9) ==((sizer) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((s01) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                         
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T3159)
(declare-fun |0| () Int)
(declare-fun tlen (T3159) Int)
(declare-fun v () T3159)
(declare-fun s01 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T3159)
(declare-fun _lbv9 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T3159)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun _lbv10 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T3159)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2185 Int)
         (var_u2184 Int)
         (var_u2183 Int)
         (var_u2182 Int)
         (var_u2181 Int)
         (var_u2180 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2182 (+ s01 1)) (= (tlen v) var_u2182))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (> s0 s01)
         (= (tlen ltree) sizel)
         (= _lbv9 (- sizer 1))
         (= (tlen rtree) sizer)
         (=> (= var_u2185 (+ s01 1)) (= (tlen v) var_u2185))))))
(assert (not (forall ((var_u2186 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), s01 ), ltree ), _lbv9 ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), s01 ), ltree ), _lbv8 ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), s01 ), ltree ), apply subs  (, s ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), s01 ), ltree ), _lbv8 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument s01 :: {v:Ty_int | 
 	 Conj <c true
 	 , s0 > v >c } | 
 	 Conj <c true
 	 , s0 > s01 >c 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv8 :: {v:Ty_int | (v) ==((s) -- (1))} | (_lbv8) ==((s) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((s01) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                         
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T3165)
(declare-fun |0| () Int)
(declare-fun tlen (T3165) Int)
(declare-fun v () T3165)
(declare-fun s01 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T3165)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T3165)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T3165)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2192 Int)
         (var_u2191 Int)
         (var_u2190 Int)
         (var_u2189 Int)
         (var_u2188 Int)
         (var_u2187 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2189 (+ s01 1)) (= (tlen v) var_u2189))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (> s0 s01)
         (= (tlen ltree) sizel)
         (= _lbv8 (- s 1))
         (= (tlen rtree) sizer)
         (=> (= var_u2192 (+ s01 1)) (= (tlen v) var_u2192))))))
(assert (not (forall ((var_u2193 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), s01 ), ltree ), _lbv8 ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), s01 ), ltree ), _lbv7 ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), s01 ), ltree ), apply subs  (, s01 ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), s01 ), ltree ), _lbv7 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument s01 :: {v:Ty_int | 
 	 Conj <c true
 	 , s0 > v >c } | 
 	 Conj <c true
 	 , s0 > s01 >c 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv7 :: {v:Ty_int | (v) ==((s01) -- (1))} | (_lbv7) ==((s01) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((s01) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                         
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T3171)
(declare-fun |0| () Int)
(declare-fun tlen (T3171) Int)
(declare-fun v () T3171)
(declare-fun s01 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T3171)
(declare-fun _lbv7 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T3171)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T3171)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2199 Int)
         (var_u2198 Int)
         (var_u2197 Int)
         (var_u2196 Int)
         (var_u2195 Int)
         (var_u2194 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2196 (+ s01 1)) (= (tlen v) var_u2196))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (> s0 s01)
         (= (tlen ltree) sizel)
         (= _lbv7 (- s01 1))
         (= (tlen rtree) sizer)
         (=> (= var_u2199 (+ s01 1)) (= (tlen v) var_u2199))))))
(assert (not (forall ((var_u2200 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), s01 ), ltree ), _lbv7 ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), s01 ), ltree ), _lbv6 ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), s01 ), ltree ), apply subs  (, root ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), s01 ), ltree ), _lbv6 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument s01 :: {v:Ty_int | 
 	 Conj <c true
 	 , s0 > v >c } | 
 	 Conj <c true
 	 , s0 > s01 >c 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv6 :: {v:Ty_int | (v) ==((root) -- (1))} | (_lbv6) ==((root) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((s01) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                         
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T3177)
(declare-fun |0| () Int)
(declare-fun tlen (T3177) Int)
(declare-fun v () T3177)
(declare-fun s01 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T3177)
(declare-fun root () Int)
(declare-fun _lbv6 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T3177)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T3177)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2206 Int)
         (var_u2205 Int)
         (var_u2204 Int)
         (var_u2203 Int)
         (var_u2202 Int)
         (var_u2201 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2203 (+ s01 1)) (= (tlen v) var_u2203))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (> s0 s01)
         (= (tlen ltree) sizel)
         (= _lbv6 (- root 1))
         (= (tlen rtree) sizer)
         (=> (= var_u2206 (+ s01 1)) (= (tlen v) var_u2206))))))
(assert (not (forall ((var_u2207 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), s01 ), ltree ), _lbv6 ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), s01 ), ltree ), s ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), s01 ), ltree ), s ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), s01 ), ltree ), s ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument s01 :: {v:Ty_int | 
 	 Conj <c true
 	 , s0 > v >c } | 
 	 Conj <c true
 	 , s0 > s01 >c 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument s :: {var_v0:Ty_int | true} | true
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((s01) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                         
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T3183)
(declare-fun |0| () Int)
(declare-fun tlen (T3183) Int)
(declare-fun v () T3183)
(declare-fun s01 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T3183)
(declare-fun sizel () Int)
(declare-fun ltree () T3183)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T3183)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2213 Int)
         (var_u2212 Int)
         (var_u2211 Int)
         (var_u2210 Int)
         (var_u2209 Int)
         (var_u2208 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2210 (+ s01 1)) (= (tlen v) var_u2210))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (> s0 s01)
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2213 (+ s01 1)) (= (tlen v) var_u2213))))))
(assert (not (forall ((var_u2214 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), s01 ), ltree ), s ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), s01 ), ltree ), _lbv2 ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), s01 ), ltree ), apply subs  (, apply int_gen  (, dummy ) ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), s01 ), ltree ), _lbv2 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument s01 :: {v:Ty_int | 
 	 Conj <c true
 	 , s0 > v >c } | 
 	 Conj <c true
 	 , s0 > s01 >c 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv2 :: {v:Ty_int | (v) ==((_lbv0) -- (1))} | (_lbv2) ==((_lbv0) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((s01) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                         
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T3189)
(declare-fun |0| () Int)
(declare-fun tlen (T3189) Int)
(declare-fun v () T3189)
(declare-fun s01 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T3189)
(declare-fun _lbv0 () Int)
(declare-fun _lbv2 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T3189)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T3189)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2220 Int)
         (var_u2219 Int)
         (var_u2218 Int)
         (var_u2217 Int)
         (var_u2216 Int)
         (var_u2215 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2217 (+ s01 1)) (= (tlen v) var_u2217))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (> s0 s01)
         (= (tlen ltree) sizel)
         (= _lbv2 (- _lbv0 1))
         (= (tlen rtree) sizer)
         (=> (= var_u2220 (+ s01 1)) (= (tlen v) var_u2220))))))
(assert (not (forall ((var_u2221 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), s01 ), ltree ), _lbv2 ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), s01 ), ltree ), _lbv1 ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), s01 ), ltree ), apply subs  (, s0 ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), s01 ), ltree ), _lbv1 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument s01 :: {v:Ty_int | 
 	 Conj <c true
 	 , s0 > v >c } | 
 	 Conj <c true
 	 , s0 > s01 >c 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((s01) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                         
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T3195)
(declare-fun |0| () Int)
(declare-fun tlen (T3195) Int)
(declare-fun v () T3195)
(declare-fun s01 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T3195)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T3195)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T3195)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2227 Int)
         (var_u2226 Int)
         (var_u2225 Int)
         (var_u2224 Int)
         (var_u2223 Int)
         (var_u2222 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2224 (+ s01 1)) (= (tlen v) var_u2224))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (> s0 s01)
         (= (tlen ltree) sizel)
         (= _lbv1 (- s0 1))
         (= (tlen rtree) sizer)
         (=> (= var_u2227 (+ s01 1)) (= (tlen v) var_u2227))))))
(assert (not (forall ((var_u2228 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), s01 ), ltree ), _lbv1 ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), s01 ), ltree ), _lbv0 ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), s01 ), ltree ), apply int_gen  (, dummy ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), s01 ), ltree ), _lbv0 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument s01 :: {v:Ty_int | 
 	 Conj <c true
 	 , s0 > v >c } | 
 	 Conj <c true
 	 , s0 > s01 >c 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((s01) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                                    
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T3201)
(declare-fun |0| () Int)
(declare-fun tlen (T3201) Int)
(declare-fun v () T3201)
(declare-fun s01 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T3201)
(declare-fun _lbv0 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T3201)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T3201)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2234 Int)
         (var_u2233 Int)
         (var_u2232 Int)
         (var_u2231 Int)
         (var_u2230 Int)
         (var_u2229 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2231 (+ s01 1)) (= (tlen v) var_u2231))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (> s0 s01)
         (= (tlen ltree) sizel)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen rtree) sizer)
         (=> (= var_u2234 (+ s01 1)) (= (tlen v) var_u2234))))))
(assert (not (forall ((var_u2235 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), s01 ), ltree ), _lbv0 ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), s01 ), ltree ), s0 ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), s01 ), ltree ), s0 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), s01 ), ltree ), s0 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument s01 :: {v:Ty_int | 
 	 Conj <c true
 	 , s0 > v >c } | 
 	 Conj <c true
 	 , s0 > s01 >c 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument s0 :: {v:Ty_int | true} | true
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((s01) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                         
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T3207)
(declare-fun |0| () Int)
(declare-fun tlen (T3207) Int)
(declare-fun v () T3207)
(declare-fun s01 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T3207)
(declare-fun sizel () Int)
(declare-fun ltree () T3207)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T3207)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2241 Int)
         (var_u2240 Int)
         (var_u2239 Int)
         (var_u2238 Int)
         (var_u2237 Int)
         (var_u2236 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2238 (+ s01 1)) (= (tlen v) var_u2238))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (> s0 s01)
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2241 (+ s01 1)) (= (tlen v) var_u2241))))))
(assert (not (forall ((var_u2242 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), s01 ), ltree ), s0 ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), s01 ), ltree ), _lbv1 ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), s01 ), ltree ), apply subs  (, s0 ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), s01 ), ltree ), _lbv1 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument s01 :: {v:Ty_int | 
 	 Conj <c true
 	 , s0 > v >c } | 
 	 Conj <c true
 	 , s0 > s01 >c 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((s01) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                         
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T3213)
(declare-fun |0| () Int)
(declare-fun tlen (T3213) Int)
(declare-fun v () T3213)
(declare-fun s01 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T3213)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T3213)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T3213)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2248 Int)
         (var_u2247 Int)
         (var_u2246 Int)
         (var_u2245 Int)
         (var_u2244 Int)
         (var_u2243 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2245 (+ s01 1)) (= (tlen v) var_u2245))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (> s0 s01)
         (= (tlen ltree) sizel)
         (= _lbv1 (- s0 1))
         (= (tlen rtree) sizer)
         (=> (= var_u2248 (+ s01 1)) (= (tlen v) var_u2248))))))
(assert (not (forall ((var_u2249 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), s01 ), ltree ), _lbv1 ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), s01 ), ltree ), _lbv2 ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), s01 ), ltree ), apply subs  (, apply int_gen  (, dummy ) ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), s01 ), ltree ), _lbv2 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument s01 :: {v:Ty_int | 
 	 Conj <c true
 	 , s0 > v >c } | 
 	 Conj <c true
 	 , s0 > s01 >c 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv2 :: {v:Ty_int | (v) ==((_lbv0) -- (1))} | (_lbv2) ==((_lbv0) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((s01) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                         
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T3219)
(declare-fun |0| () Int)
(declare-fun tlen (T3219) Int)
(declare-fun v () T3219)
(declare-fun s01 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T3219)
(declare-fun _lbv0 () Int)
(declare-fun _lbv2 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T3219)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T3219)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2255 Int)
         (var_u2254 Int)
         (var_u2253 Int)
         (var_u2252 Int)
         (var_u2251 Int)
         (var_u2250 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2252 (+ s01 1)) (= (tlen v) var_u2252))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (> s0 s01)
         (= (tlen ltree) sizel)
         (= _lbv2 (- _lbv0 1))
         (= (tlen rtree) sizer)
         (=> (= var_u2255 (+ s01 1)) (= (tlen v) var_u2255))))))
(assert (not (forall ((var_u2256 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), s01 ), ltree ), _lbv2 ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), s01 ), ltree ), _lbv8 ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), s01 ), ltree ), apply subs  (, s ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), s01 ), ltree ), _lbv8 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument s01 :: {v:Ty_int | 
 	 Conj <c true
 	 , s0 > v >c } | 
 	 Conj <c true
 	 , s0 > s01 >c 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv8 :: {v:Ty_int | (v) ==((s) -- (1))} | (_lbv8) ==((s) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((s01) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                         
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T3225)
(declare-fun |0| () Int)
(declare-fun tlen (T3225) Int)
(declare-fun v () T3225)
(declare-fun s01 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T3225)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T3225)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T3225)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2262 Int)
         (var_u2261 Int)
         (var_u2260 Int)
         (var_u2259 Int)
         (var_u2258 Int)
         (var_u2257 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2259 (+ s01 1)) (= (tlen v) var_u2259))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (> s0 s01)
         (= (tlen ltree) sizel)
         (= _lbv8 (- s 1))
         (= (tlen rtree) sizer)
         (=> (= var_u2262 (+ s01 1)) (= (tlen v) var_u2262))))))
(assert (not (forall ((var_u2263 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), s01 ), ltree ), _lbv8 ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), s01 ), ltree ), _lbv7 ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), s01 ), ltree ), apply subs  (, s01 ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), s01 ), ltree ), _lbv7 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument s01 :: {v:Ty_int | 
 	 Conj <c true
 	 , s0 > v >c } | 
 	 Conj <c true
 	 , s0 > s01 >c 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv7 :: {v:Ty_int | (v) ==((s01) -- (1))} | (_lbv7) ==((s01) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((s01) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                         
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T3231)
(declare-fun |0| () Int)
(declare-fun tlen (T3231) Int)
(declare-fun v () T3231)
(declare-fun s01 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T3231)
(declare-fun _lbv7 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T3231)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T3231)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2269 Int)
         (var_u2268 Int)
         (var_u2267 Int)
         (var_u2266 Int)
         (var_u2265 Int)
         (var_u2264 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2266 (+ s01 1)) (= (tlen v) var_u2266))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (> s0 s01)
         (= (tlen ltree) sizel)
         (= _lbv7 (- s01 1))
         (= (tlen rtree) sizer)
         (=> (= var_u2269 (+ s01 1)) (= (tlen v) var_u2269))))))
(assert (not (forall ((var_u2270 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), s01 ), ltree ), _lbv7 ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), s01 ), ltree ), _lbv6 ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), s01 ), ltree ), apply subs  (, root ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), s01 ), ltree ), _lbv6 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument s01 :: {v:Ty_int | 
 	 Conj <c true
 	 , s0 > v >c } | 
 	 Conj <c true
 	 , s0 > s01 >c 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv6 :: {v:Ty_int | (v) ==((root) -- (1))} | (_lbv6) ==((root) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((s01) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                         
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T3237)
(declare-fun |0| () Int)
(declare-fun tlen (T3237) Int)
(declare-fun v () T3237)
(declare-fun s01 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T3237)
(declare-fun root () Int)
(declare-fun _lbv6 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T3237)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T3237)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2276 Int)
         (var_u2275 Int)
         (var_u2274 Int)
         (var_u2273 Int)
         (var_u2272 Int)
         (var_u2271 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2273 (+ s01 1)) (= (tlen v) var_u2273))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (> s0 s01)
         (= (tlen ltree) sizel)
         (= _lbv6 (- root 1))
         (= (tlen rtree) sizer)
         (=> (= var_u2276 (+ s01 1)) (= (tlen v) var_u2276))))))
(assert (not (forall ((var_u2277 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), s01 ), ltree ), _lbv6 ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), s01 ), ltree ), _lbv10 ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), s01 ), ltree ), apply subs  (, sizel ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), s01 ), ltree ), _lbv10 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument s01 :: {v:Ty_int | 
 	 Conj <c true
 	 , s0 > v >c } | 
 	 Conj <c true
 	 , s0 > s01 >c 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv10 :: {v:Ty_int | (v) ==((sizel) -- (1))} | (_lbv10) ==((sizel) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((s01) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                         
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T3243)
(declare-fun |0| () Int)
(declare-fun tlen (T3243) Int)
(declare-fun v () T3243)
(declare-fun s01 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T3243)
(declare-fun sizel () Int)
(declare-fun _lbv10 () Int)
(declare-fun ltree () T3243)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T3243)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2283 Int)
         (var_u2282 Int)
         (var_u2281 Int)
         (var_u2280 Int)
         (var_u2279 Int)
         (var_u2278 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2280 (+ s01 1)) (= (tlen v) var_u2280))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (> s0 s01)
         (= (tlen ltree) sizel)
         (= _lbv10 (- sizel 1))
         (= (tlen rtree) sizer)
         (=> (= var_u2283 (+ s01 1)) (= (tlen v) var_u2283))))))
(assert (not (forall ((var_u2284 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), s01 ), ltree ), _lbv10 ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), s01 ), ltree ), _lbv9 ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), s01 ), ltree ), apply subs  (, sizer ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), s01 ), ltree ), _lbv9 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument s01 :: {v:Ty_int | 
 	 Conj <c true
 	 , s0 > v >c } | 
 	 Conj <c true
 	 , s0 > s01 >c 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv9 :: {v:Ty_int | (v) ==((sizer) -- (1))} | (_lbv9) ==((sizer) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((s01) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                         
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T3249)
(declare-fun |0| () Int)
(declare-fun tlen (T3249) Int)
(declare-fun v () T3249)
(declare-fun s01 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T3249)
(declare-fun _lbv9 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T3249)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun _lbv10 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T3249)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2290 Int)
         (var_u2289 Int)
         (var_u2288 Int)
         (var_u2287 Int)
         (var_u2286 Int)
         (var_u2285 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2287 (+ s01 1)) (= (tlen v) var_u2287))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (> s0 s01)
         (= (tlen ltree) sizel)
         (= _lbv9 (- sizer 1))
         (= (tlen rtree) sizer)
         (=> (= var_u2290 (+ s01 1)) (= (tlen v) var_u2290))))))
(assert (not (forall ((var_u2291 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), s01 ), ltree ), _lbv9 ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), sizer ), ltree ), sizer ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), sizer ), ltree ), sizer ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), sizer ), ltree ), sizer ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument sizer :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument sizer :: {v:Ty_int | true} | true
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((sizer) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                    
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T3255)
(declare-fun |0| () Int)
(declare-fun tlen (T3255) Int)
(declare-fun v () T3255)
(declare-fun sizer () Int)
(declare-fun rtree () T3255)
(declare-fun sizel () Int)
(declare-fun ltree () T3255)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T3255)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2297 Int)
         (var_u2296 Int)
         (var_u2295 Int)
         (var_u2294 Int)
         (var_u2293 Int)
         (var_u2292 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2294 (+ sizer 1)) (= (tlen v) var_u2294))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2297 (+ sizer 1)) (= (tlen v) var_u2297))))))
(assert (not (forall ((var_u2298 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), sizer ), ltree ), sizer ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), sizer ), ltree ), sizel ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), sizer ), ltree ), sizel ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), sizer ), ltree ), sizel ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument sizer :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument sizel :: {v:Ty_int | true} | true
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((sizer) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                    
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T3261)
(declare-fun |0| () Int)
(declare-fun tlen (T3261) Int)
(declare-fun v () T3261)
(declare-fun sizer () Int)
(declare-fun rtree () T3261)
(declare-fun sizel () Int)
(declare-fun ltree () T3261)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T3261)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2304 Int)
         (var_u2303 Int)
         (var_u2302 Int)
         (var_u2301 Int)
         (var_u2300 Int)
         (var_u2299 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2301 (+ sizer 1)) (= (tlen v) var_u2301))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2304 (+ sizer 1)) (= (tlen v) var_u2304))))))
(assert (not (forall ((var_u2305 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), sizer ), ltree ), sizel ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), sizer ), ltree ), root ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), sizer ), ltree ), root ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), sizer ), ltree ), root ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument sizer :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument root :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  root > 0
 	,   root = 0>d 
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((sizer) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T3267)
(declare-fun |0| () Int)
(declare-fun tlen (T3267) Int)
(declare-fun v () T3267)
(declare-fun sizer () Int)
(declare-fun rtree () T3267)
(declare-fun root () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T3267)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T3267)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2311 Int)
         (var_u2310 Int)
         (var_u2309 Int)
         (var_u2308 Int)
         (var_u2307 Int)
         (var_u2306 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2308 (+ sizer 1)) (= (tlen v) var_u2308))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (= (tlen ltree) sizel)
         (or (> root |0|) (= root |0|))
         (= (tlen rtree) sizer)
         (=> (= var_u2311 (+ sizer 1)) (= (tlen v) var_u2311))))))
(assert (not (forall ((var_u2312 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), sizer ), ltree ), root ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), sizer ), ltree ), s01 ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), sizer ), ltree ), s01 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), sizer ), ltree ), s01 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument sizer :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument s01 :: {v:Ty_int | 
 	 Conj <c true
 	 , s0 > v >c } | 
 	 Conj <c true
 	 , s0 > s01 >c 
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((sizer) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                         
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T3273)
(declare-fun |0| () Int)
(declare-fun tlen (T3273) Int)
(declare-fun v () T3273)
(declare-fun sizer () Int)
(declare-fun rtree () T3273)
(declare-fun s01 () Int)
(declare-fun s0 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T3273)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T3273)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2318 Int)
         (var_u2317 Int)
         (var_u2316 Int)
         (var_u2315 Int)
         (var_u2314 Int)
         (var_u2313 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2315 (+ sizer 1)) (= (tlen v) var_u2315))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (= (tlen ltree) sizel)
         (> s0 s01)
         (= (tlen rtree) sizer)
         (=> (= var_u2318 (+ sizer 1)) (= (tlen v) var_u2318))))))
(assert (not (forall ((var_u2319 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), sizer ), ltree ), s01 ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), sizer ), ltree ), n ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), sizer ), ltree ), n ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), sizer ), ltree ), n ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument sizer :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument n :: {v:Ty_int | true} | true
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((sizer) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                    
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T3279)
(declare-fun |0| () Int)
(declare-fun tlen (T3279) Int)
(declare-fun v () T3279)
(declare-fun sizer () Int)
(declare-fun rtree () T3279)
(declare-fun sizel () Int)
(declare-fun ltree () T3279)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T3279)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2325 Int)
         (var_u2324 Int)
         (var_u2323 Int)
         (var_u2322 Int)
         (var_u2321 Int)
         (var_u2320 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2322 (+ sizer 1)) (= (tlen v) var_u2322))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2325 (+ sizer 1)) (= (tlen v) var_u2325))))))
(assert (not (forall ((var_u2326 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), sizer ), ltree ), n ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), sizer ), ltree ), _lbv10 ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), sizer ), ltree ), apply subs  (, sizel ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), sizer ), ltree ), _lbv10 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument sizer :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv10 :: {v:Ty_int | (v) ==((sizel) -- (1))} | (_lbv10) ==((sizel) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((sizer) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                    
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T3285)
(declare-fun |0| () Int)
(declare-fun tlen (T3285) Int)
(declare-fun v () T3285)
(declare-fun sizer () Int)
(declare-fun rtree () T3285)
(declare-fun sizel () Int)
(declare-fun _lbv10 () Int)
(declare-fun ltree () T3285)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T3285)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2332 Int)
         (var_u2331 Int)
         (var_u2330 Int)
         (var_u2329 Int)
         (var_u2328 Int)
         (var_u2327 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2329 (+ sizer 1)) (= (tlen v) var_u2329))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (= (tlen ltree) sizel)
         (= _lbv10 (- sizel 1))
         (= (tlen rtree) sizer)
         (=> (= var_u2332 (+ sizer 1)) (= (tlen v) var_u2332))))))
(assert (not (forall ((var_u2333 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), sizer ), ltree ), _lbv10 ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), sizer ), ltree ), _lbv9 ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), sizer ), ltree ), apply subs  (, sizer ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), sizer ), ltree ), _lbv9 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument sizer :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv9 :: {v:Ty_int | (v) ==((sizer) -- (1))} | (_lbv9) ==((sizer) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((sizer) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                    
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T3291)
(declare-fun |0| () Int)
(declare-fun tlen (T3291) Int)
(declare-fun v () T3291)
(declare-fun sizer () Int)
(declare-fun rtree () T3291)
(declare-fun _lbv9 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T3291)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T3291)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2339 Int)
         (var_u2338 Int)
         (var_u2337 Int)
         (var_u2336 Int)
         (var_u2335 Int)
         (var_u2334 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2336 (+ sizer 1)) (= (tlen v) var_u2336))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (= (tlen ltree) sizel)
         (= _lbv9 (- sizer 1))
         (= (tlen rtree) sizer)
         (=> (= var_u2339 (+ sizer 1)) (= (tlen v) var_u2339))))))
(assert (not (forall ((var_u2340 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), sizer ), ltree ), _lbv9 ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), sizer ), ltree ), _lbv8 ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), sizer ), ltree ), apply subs  (, s ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), sizer ), ltree ), _lbv8 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument sizer :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv8 :: {v:Ty_int | (v) ==((s) -- (1))} | (_lbv8) ==((s) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((sizer) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                    
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T3297)
(declare-fun |0| () Int)
(declare-fun tlen (T3297) Int)
(declare-fun v () T3297)
(declare-fun sizer () Int)
(declare-fun rtree () T3297)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T3297)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T3297)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2346 Int)
         (var_u2345 Int)
         (var_u2344 Int)
         (var_u2343 Int)
         (var_u2342 Int)
         (var_u2341 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2343 (+ sizer 1)) (= (tlen v) var_u2343))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (= (tlen ltree) sizel)
         (= _lbv8 (- s 1))
         (= (tlen rtree) sizer)
         (=> (= var_u2346 (+ sizer 1)) (= (tlen v) var_u2346))))))
(assert (not (forall ((var_u2347 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), sizer ), ltree ), _lbv8 ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), sizer ), ltree ), _lbv7 ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), sizer ), ltree ), apply subs  (, s01 ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), sizer ), ltree ), _lbv7 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument sizer :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv7 :: {v:Ty_int | (v) ==((s01) -- (1))} | (_lbv7) ==((s01) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((sizer) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                    
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T3303)
(declare-fun |0| () Int)
(declare-fun tlen (T3303) Int)
(declare-fun v () T3303)
(declare-fun sizer () Int)
(declare-fun rtree () T3303)
(declare-fun s01 () Int)
(declare-fun _lbv7 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T3303)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T3303)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2353 Int)
         (var_u2352 Int)
         (var_u2351 Int)
         (var_u2350 Int)
         (var_u2349 Int)
         (var_u2348 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2350 (+ sizer 1)) (= (tlen v) var_u2350))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (= (tlen ltree) sizel)
         (= _lbv7 (- s01 1))
         (= (tlen rtree) sizer)
         (=> (= var_u2353 (+ sizer 1)) (= (tlen v) var_u2353))))))
(assert (not (forall ((var_u2354 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), sizer ), ltree ), _lbv7 ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), sizer ), ltree ), _lbv6 ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), sizer ), ltree ), apply subs  (, root ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), sizer ), ltree ), _lbv6 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument sizer :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv6 :: {v:Ty_int | (v) ==((root) -- (1))} | (_lbv6) ==((root) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((sizer) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                    
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T3309)
(declare-fun |0| () Int)
(declare-fun tlen (T3309) Int)
(declare-fun v () T3309)
(declare-fun sizer () Int)
(declare-fun rtree () T3309)
(declare-fun root () Int)
(declare-fun _lbv6 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T3309)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T3309)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2360 Int)
         (var_u2359 Int)
         (var_u2358 Int)
         (var_u2357 Int)
         (var_u2356 Int)
         (var_u2355 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2357 (+ sizer 1)) (= (tlen v) var_u2357))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (= (tlen ltree) sizel)
         (= _lbv6 (- root 1))
         (= (tlen rtree) sizer)
         (=> (= var_u2360 (+ sizer 1)) (= (tlen v) var_u2360))))))
(assert (not (forall ((var_u2361 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), sizer ), ltree ), _lbv6 ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), sizer ), ltree ), s ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), sizer ), ltree ), s ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), sizer ), ltree ), s ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument sizer :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument s :: {var_v0:Ty_int | true} | true
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((sizer) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                    
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T3315)
(declare-fun |0| () Int)
(declare-fun tlen (T3315) Int)
(declare-fun v () T3315)
(declare-fun sizer () Int)
(declare-fun rtree () T3315)
(declare-fun sizel () Int)
(declare-fun ltree () T3315)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T3315)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2367 Int)
         (var_u2366 Int)
         (var_u2365 Int)
         (var_u2364 Int)
         (var_u2363 Int)
         (var_u2362 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2364 (+ sizer 1)) (= (tlen v) var_u2364))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2367 (+ sizer 1)) (= (tlen v) var_u2367))))))
(assert (not (forall ((var_u2368 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), sizer ), ltree ), s ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), sizer ), ltree ), _lbv2 ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), sizer ), ltree ), apply subs  (, apply int_gen  (, dummy ) ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), sizer ), ltree ), _lbv2 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument sizer :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv2 :: {v:Ty_int | (v) ==((_lbv0) -- (1))} | (_lbv2) ==((_lbv0) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((sizer) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                    
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T3321)
(declare-fun |0| () Int)
(declare-fun tlen (T3321) Int)
(declare-fun v () T3321)
(declare-fun sizer () Int)
(declare-fun rtree () T3321)
(declare-fun _lbv0 () Int)
(declare-fun _lbv2 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T3321)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T3321)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2374 Int)
         (var_u2373 Int)
         (var_u2372 Int)
         (var_u2371 Int)
         (var_u2370 Int)
         (var_u2369 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2371 (+ sizer 1)) (= (tlen v) var_u2371))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (= (tlen ltree) sizel)
         (= _lbv2 (- _lbv0 1))
         (= (tlen rtree) sizer)
         (=> (= var_u2374 (+ sizer 1)) (= (tlen v) var_u2374))))))
(assert (not (forall ((var_u2375 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), sizer ), ltree ), _lbv2 ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), sizer ), ltree ), _lbv1 ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), sizer ), ltree ), apply subs  (, s0 ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), sizer ), ltree ), _lbv1 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument sizer :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((sizer) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                    
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T3327)
(declare-fun |0| () Int)
(declare-fun tlen (T3327) Int)
(declare-fun v () T3327)
(declare-fun sizer () Int)
(declare-fun rtree () T3327)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T3327)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T3327)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2381 Int)
         (var_u2380 Int)
         (var_u2379 Int)
         (var_u2378 Int)
         (var_u2377 Int)
         (var_u2376 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2378 (+ sizer 1)) (= (tlen v) var_u2378))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (= (tlen ltree) sizel)
         (= _lbv1 (- s0 1))
         (= (tlen rtree) sizer)
         (=> (= var_u2381 (+ sizer 1)) (= (tlen v) var_u2381))))))
(assert (not (forall ((var_u2382 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), sizer ), ltree ), _lbv1 ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), sizer ), ltree ), _lbv0 ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), sizer ), ltree ), apply int_gen  (, dummy ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), sizer ), ltree ), _lbv0 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument sizer :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((sizer) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T3333)
(declare-fun |0| () Int)
(declare-fun tlen (T3333) Int)
(declare-fun v () T3333)
(declare-fun sizer () Int)
(declare-fun rtree () T3333)
(declare-fun _lbv0 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T3333)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T3333)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2388 Int)
         (var_u2387 Int)
         (var_u2386 Int)
         (var_u2385 Int)
         (var_u2384 Int)
         (var_u2383 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2385 (+ sizer 1)) (= (tlen v) var_u2385))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (= (tlen ltree) sizel)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen rtree) sizer)
         (=> (= var_u2388 (+ sizer 1)) (= (tlen v) var_u2388))))))
(assert (not (forall ((var_u2389 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), sizer ), ltree ), _lbv0 ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), sizer ), ltree ), s0 ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), sizer ), ltree ), s0 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), sizer ), ltree ), s0 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument sizer :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument s0 :: {v:Ty_int | true} | true
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((sizer) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                    
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T3339)
(declare-fun |0| () Int)
(declare-fun tlen (T3339) Int)
(declare-fun v () T3339)
(declare-fun sizer () Int)
(declare-fun rtree () T3339)
(declare-fun sizel () Int)
(declare-fun ltree () T3339)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T3339)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2395 Int)
         (var_u2394 Int)
         (var_u2393 Int)
         (var_u2392 Int)
         (var_u2391 Int)
         (var_u2390 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2392 (+ sizer 1)) (= (tlen v) var_u2392))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2395 (+ sizer 1)) (= (tlen v) var_u2395))))))
(assert (not (forall ((var_u2396 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), sizer ), ltree ), s0 ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), sizer ), ltree ), _lbv1 ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), sizer ), ltree ), apply subs  (, s0 ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), sizer ), ltree ), _lbv1 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument sizer :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((sizer) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                    
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T3345)
(declare-fun |0| () Int)
(declare-fun tlen (T3345) Int)
(declare-fun v () T3345)
(declare-fun sizer () Int)
(declare-fun rtree () T3345)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T3345)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T3345)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2402 Int)
         (var_u2401 Int)
         (var_u2400 Int)
         (var_u2399 Int)
         (var_u2398 Int)
         (var_u2397 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2399 (+ sizer 1)) (= (tlen v) var_u2399))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (= (tlen ltree) sizel)
         (= _lbv1 (- s0 1))
         (= (tlen rtree) sizer)
         (=> (= var_u2402 (+ sizer 1)) (= (tlen v) var_u2402))))))
(assert (not (forall ((var_u2403 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), sizer ), ltree ), _lbv1 ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), sizer ), ltree ), _lbv2 ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), sizer ), ltree ), apply subs  (, apply int_gen  (, dummy ) ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), sizer ), ltree ), _lbv2 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument sizer :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv2 :: {v:Ty_int | (v) ==((_lbv0) -- (1))} | (_lbv2) ==((_lbv0) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((sizer) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                    
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T3351)
(declare-fun |0| () Int)
(declare-fun tlen (T3351) Int)
(declare-fun v () T3351)
(declare-fun sizer () Int)
(declare-fun rtree () T3351)
(declare-fun _lbv0 () Int)
(declare-fun _lbv2 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T3351)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T3351)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2409 Int)
         (var_u2408 Int)
         (var_u2407 Int)
         (var_u2406 Int)
         (var_u2405 Int)
         (var_u2404 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2406 (+ sizer 1)) (= (tlen v) var_u2406))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (= (tlen ltree) sizel)
         (= _lbv2 (- _lbv0 1))
         (= (tlen rtree) sizer)
         (=> (= var_u2409 (+ sizer 1)) (= (tlen v) var_u2409))))))
(assert (not (forall ((var_u2410 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), sizer ), ltree ), _lbv2 ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), sizer ), ltree ), _lbv8 ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), sizer ), ltree ), apply subs  (, s ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), sizer ), ltree ), _lbv8 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument sizer :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv8 :: {v:Ty_int | (v) ==((s) -- (1))} | (_lbv8) ==((s) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((sizer) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                    
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T3357)
(declare-fun |0| () Int)
(declare-fun tlen (T3357) Int)
(declare-fun v () T3357)
(declare-fun sizer () Int)
(declare-fun rtree () T3357)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T3357)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T3357)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2416 Int)
         (var_u2415 Int)
         (var_u2414 Int)
         (var_u2413 Int)
         (var_u2412 Int)
         (var_u2411 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2413 (+ sizer 1)) (= (tlen v) var_u2413))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (= (tlen ltree) sizel)
         (= _lbv8 (- s 1))
         (= (tlen rtree) sizer)
         (=> (= var_u2416 (+ sizer 1)) (= (tlen v) var_u2416))))))
(assert (not (forall ((var_u2417 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), sizer ), ltree ), _lbv8 ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), sizer ), ltree ), _lbv7 ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), sizer ), ltree ), apply subs  (, s01 ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), sizer ), ltree ), _lbv7 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument sizer :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv7 :: {v:Ty_int | (v) ==((s01) -- (1))} | (_lbv7) ==((s01) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((sizer) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                    
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T3363)
(declare-fun |0| () Int)
(declare-fun tlen (T3363) Int)
(declare-fun v () T3363)
(declare-fun sizer () Int)
(declare-fun rtree () T3363)
(declare-fun s01 () Int)
(declare-fun _lbv7 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T3363)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T3363)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2423 Int)
         (var_u2422 Int)
         (var_u2421 Int)
         (var_u2420 Int)
         (var_u2419 Int)
         (var_u2418 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2420 (+ sizer 1)) (= (tlen v) var_u2420))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (= (tlen ltree) sizel)
         (= _lbv7 (- s01 1))
         (= (tlen rtree) sizer)
         (=> (= var_u2423 (+ sizer 1)) (= (tlen v) var_u2423))))))
(assert (not (forall ((var_u2424 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), sizer ), ltree ), _lbv7 ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), sizer ), ltree ), _lbv6 ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), sizer ), ltree ), apply subs  (, root ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), sizer ), ltree ), _lbv6 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument sizer :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv6 :: {v:Ty_int | (v) ==((root) -- (1))} | (_lbv6) ==((root) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((sizer) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                    
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T3369)
(declare-fun |0| () Int)
(declare-fun tlen (T3369) Int)
(declare-fun v () T3369)
(declare-fun sizer () Int)
(declare-fun rtree () T3369)
(declare-fun root () Int)
(declare-fun _lbv6 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T3369)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T3369)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2430 Int)
         (var_u2429 Int)
         (var_u2428 Int)
         (var_u2427 Int)
         (var_u2426 Int)
         (var_u2425 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2427 (+ sizer 1)) (= (tlen v) var_u2427))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (= (tlen ltree) sizel)
         (= _lbv6 (- root 1))
         (= (tlen rtree) sizer)
         (=> (= var_u2430 (+ sizer 1)) (= (tlen v) var_u2430))))))
(assert (not (forall ((var_u2431 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), sizer ), ltree ), _lbv6 ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), sizer ), ltree ), _lbv10 ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), sizer ), ltree ), apply subs  (, sizel ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), sizer ), ltree ), _lbv10 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument sizer :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv10 :: {v:Ty_int | (v) ==((sizel) -- (1))} | (_lbv10) ==((sizel) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((sizer) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                    
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T3375)
(declare-fun |0| () Int)
(declare-fun tlen (T3375) Int)
(declare-fun v () T3375)
(declare-fun sizer () Int)
(declare-fun rtree () T3375)
(declare-fun sizel () Int)
(declare-fun _lbv10 () Int)
(declare-fun ltree () T3375)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T3375)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2437 Int)
         (var_u2436 Int)
         (var_u2435 Int)
         (var_u2434 Int)
         (var_u2433 Int)
         (var_u2432 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2434 (+ sizer 1)) (= (tlen v) var_u2434))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (= (tlen ltree) sizel)
         (= _lbv10 (- sizel 1))
         (= (tlen rtree) sizer)
         (=> (= var_u2437 (+ sizer 1)) (= (tlen v) var_u2437))))))
(assert (not (forall ((var_u2438 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), sizer ), ltree ), _lbv10 ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), sizer ), ltree ), _lbv9 ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), sizer ), ltree ), apply subs  (, sizer ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), sizer ), ltree ), _lbv9 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument sizer :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv9 :: {v:Ty_int | (v) ==((sizer) -- (1))} | (_lbv9) ==((sizer) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((sizer) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                    
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T3381)
(declare-fun |0| () Int)
(declare-fun tlen (T3381) Int)
(declare-fun v () T3381)
(declare-fun sizer () Int)
(declare-fun rtree () T3381)
(declare-fun _lbv9 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T3381)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T3381)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2444 Int)
         (var_u2443 Int)
         (var_u2442 Int)
         (var_u2441 Int)
         (var_u2440 Int)
         (var_u2439 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2441 (+ sizer 1)) (= (tlen v) var_u2441))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (= (tlen ltree) sizel)
         (= _lbv9 (- sizer 1))
         (= (tlen rtree) sizer)
         (=> (= var_u2444 (+ sizer 1)) (= (tlen v) var_u2444))))))
(assert (not (forall ((var_u2445 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), sizer ), ltree ), _lbv9 ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), sizel ), ltree ), sizer ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), sizel ), ltree ), sizer ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), sizel ), ltree ), sizer ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument sizel :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument sizer :: {v:Ty_int | true} | true
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((sizel) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                    
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T3387)
(declare-fun |0| () Int)
(declare-fun tlen (T3387) Int)
(declare-fun v () T3387)
(declare-fun sizel () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T3387)
(declare-fun ltree () T3387)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T3387)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2451 Int)
         (var_u2450 Int)
         (var_u2449 Int)
         (var_u2448 Int)
         (var_u2447 Int)
         (var_u2446 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2448 (+ sizel 1)) (= (tlen v) var_u2448))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2451 (+ sizel 1)) (= (tlen v) var_u2451))))))
(assert (not (forall ((var_u2452 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), sizel ), ltree ), sizer ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), sizel ), ltree ), sizel ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), sizel ), ltree ), sizel ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), sizel ), ltree ), sizel ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument sizel :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument sizel :: {v:Ty_int | true} | true
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((sizel) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                    
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T3393)
(declare-fun |0| () Int)
(declare-fun tlen (T3393) Int)
(declare-fun v () T3393)
(declare-fun sizel () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T3393)
(declare-fun ltree () T3393)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T3393)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2458 Int)
         (var_u2457 Int)
         (var_u2456 Int)
         (var_u2455 Int)
         (var_u2454 Int)
         (var_u2453 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2455 (+ sizel 1)) (= (tlen v) var_u2455))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2458 (+ sizel 1)) (= (tlen v) var_u2458))))))
(assert (not (forall ((var_u2459 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), sizel ), ltree ), sizel ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), sizel ), ltree ), root ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), sizel ), ltree ), root ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), sizel ), ltree ), root ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument sizel :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument root :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  root > 0
 	,   root = 0>d 
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((sizel) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T3399)
(declare-fun |0| () Int)
(declare-fun tlen (T3399) Int)
(declare-fun v () T3399)
(declare-fun sizel () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T3399)
(declare-fun root () Int)
(declare-fun ltree () T3399)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T3399)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2465 Int)
         (var_u2464 Int)
         (var_u2463 Int)
         (var_u2462 Int)
         (var_u2461 Int)
         (var_u2460 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2462 (+ sizel 1)) (= (tlen v) var_u2462))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (= (tlen ltree) sizel)
         (or (> root |0|) (= root |0|))
         (= (tlen rtree) sizer)
         (=> (= var_u2465 (+ sizel 1)) (= (tlen v) var_u2465))))))
(assert (not (forall ((var_u2466 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), sizel ), ltree ), root ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), sizel ), ltree ), s01 ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), sizel ), ltree ), s01 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), sizel ), ltree ), s01 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument sizel :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument s01 :: {v:Ty_int | 
 	 Conj <c true
 	 , s0 > v >c } | 
 	 Conj <c true
 	 , s0 > s01 >c 
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((sizel) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                         
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T3405)
(declare-fun |0| () Int)
(declare-fun tlen (T3405) Int)
(declare-fun v () T3405)
(declare-fun sizel () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T3405)
(declare-fun s01 () Int)
(declare-fun s0 () Int)
(declare-fun ltree () T3405)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T3405)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2472 Int)
         (var_u2471 Int)
         (var_u2470 Int)
         (var_u2469 Int)
         (var_u2468 Int)
         (var_u2467 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2469 (+ sizel 1)) (= (tlen v) var_u2469))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (= (tlen ltree) sizel)
         (> s0 s01)
         (= (tlen rtree) sizer)
         (=> (= var_u2472 (+ sizel 1)) (= (tlen v) var_u2472))))))
(assert (not (forall ((var_u2473 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), sizel ), ltree ), s01 ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), sizel ), ltree ), n ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), sizel ), ltree ), n ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), sizel ), ltree ), n ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument sizel :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument n :: {v:Ty_int | true} | true
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((sizel) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                    
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T3411)
(declare-fun |0| () Int)
(declare-fun tlen (T3411) Int)
(declare-fun v () T3411)
(declare-fun sizel () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T3411)
(declare-fun ltree () T3411)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T3411)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2479 Int)
         (var_u2478 Int)
         (var_u2477 Int)
         (var_u2476 Int)
         (var_u2475 Int)
         (var_u2474 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2476 (+ sizel 1)) (= (tlen v) var_u2476))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2479 (+ sizel 1)) (= (tlen v) var_u2479))))))
(assert (not (forall ((var_u2480 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), sizel ), ltree ), n ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), sizel ), ltree ), _lbv10 ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), sizel ), ltree ), apply subs  (, sizel ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), sizel ), ltree ), _lbv10 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument sizel :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv10 :: {v:Ty_int | (v) ==((sizel) -- (1))} | (_lbv10) ==((sizel) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((sizel) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                    
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T3417)
(declare-fun |0| () Int)
(declare-fun tlen (T3417) Int)
(declare-fun v () T3417)
(declare-fun sizel () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T3417)
(declare-fun _lbv10 () Int)
(declare-fun ltree () T3417)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T3417)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2486 Int)
         (var_u2485 Int)
         (var_u2484 Int)
         (var_u2483 Int)
         (var_u2482 Int)
         (var_u2481 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2483 (+ sizel 1)) (= (tlen v) var_u2483))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (= (tlen ltree) sizel)
         (= _lbv10 (- sizel 1))
         (= (tlen rtree) sizer)
         (=> (= var_u2486 (+ sizel 1)) (= (tlen v) var_u2486))))))
(assert (not (forall ((var_u2487 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), sizel ), ltree ), _lbv10 ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), sizel ), ltree ), _lbv9 ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), sizel ), ltree ), apply subs  (, sizer ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), sizel ), ltree ), _lbv9 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument sizel :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv9 :: {v:Ty_int | (v) ==((sizer) -- (1))} | (_lbv9) ==((sizer) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((sizel) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                    
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T3423)
(declare-fun |0| () Int)
(declare-fun tlen (T3423) Int)
(declare-fun v () T3423)
(declare-fun sizel () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T3423)
(declare-fun _lbv9 () Int)
(declare-fun ltree () T3423)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T3423)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2493 Int)
         (var_u2492 Int)
         (var_u2491 Int)
         (var_u2490 Int)
         (var_u2489 Int)
         (var_u2488 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2490 (+ sizel 1)) (= (tlen v) var_u2490))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (= (tlen ltree) sizel)
         (= _lbv9 (- sizer 1))
         (= (tlen rtree) sizer)
         (=> (= var_u2493 (+ sizel 1)) (= (tlen v) var_u2493))))))
(assert (not (forall ((var_u2494 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), sizel ), ltree ), _lbv9 ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), sizel ), ltree ), _lbv8 ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), sizel ), ltree ), apply subs  (, s ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), sizel ), ltree ), _lbv8 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument sizel :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv8 :: {v:Ty_int | (v) ==((s) -- (1))} | (_lbv8) ==((s) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((sizel) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                    
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T3429)
(declare-fun |0| () Int)
(declare-fun tlen (T3429) Int)
(declare-fun v () T3429)
(declare-fun sizel () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T3429)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun ltree () T3429)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T3429)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2500 Int)
         (var_u2499 Int)
         (var_u2498 Int)
         (var_u2497 Int)
         (var_u2496 Int)
         (var_u2495 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2497 (+ sizel 1)) (= (tlen v) var_u2497))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (= (tlen ltree) sizel)
         (= _lbv8 (- s 1))
         (= (tlen rtree) sizer)
         (=> (= var_u2500 (+ sizel 1)) (= (tlen v) var_u2500))))))
(assert (not (forall ((var_u2501 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), sizel ), ltree ), _lbv8 ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), sizel ), ltree ), _lbv7 ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), sizel ), ltree ), apply subs  (, s01 ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), sizel ), ltree ), _lbv7 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument sizel :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv7 :: {v:Ty_int | (v) ==((s01) -- (1))} | (_lbv7) ==((s01) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((sizel) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                    
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T3435)
(declare-fun |0| () Int)
(declare-fun tlen (T3435) Int)
(declare-fun v () T3435)
(declare-fun sizel () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T3435)
(declare-fun s01 () Int)
(declare-fun _lbv7 () Int)
(declare-fun ltree () T3435)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T3435)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2507 Int)
         (var_u2506 Int)
         (var_u2505 Int)
         (var_u2504 Int)
         (var_u2503 Int)
         (var_u2502 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2504 (+ sizel 1)) (= (tlen v) var_u2504))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (= (tlen ltree) sizel)
         (= _lbv7 (- s01 1))
         (= (tlen rtree) sizer)
         (=> (= var_u2507 (+ sizel 1)) (= (tlen v) var_u2507))))))
(assert (not (forall ((var_u2508 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), sizel ), ltree ), _lbv7 ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), sizel ), ltree ), _lbv6 ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), sizel ), ltree ), apply subs  (, root ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), sizel ), ltree ), _lbv6 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument sizel :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv6 :: {v:Ty_int | (v) ==((root) -- (1))} | (_lbv6) ==((root) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((sizel) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                    
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T3441)
(declare-fun |0| () Int)
(declare-fun tlen (T3441) Int)
(declare-fun v () T3441)
(declare-fun sizel () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T3441)
(declare-fun root () Int)
(declare-fun _lbv6 () Int)
(declare-fun ltree () T3441)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T3441)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2514 Int)
         (var_u2513 Int)
         (var_u2512 Int)
         (var_u2511 Int)
         (var_u2510 Int)
         (var_u2509 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2511 (+ sizel 1)) (= (tlen v) var_u2511))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (= (tlen ltree) sizel)
         (= _lbv6 (- root 1))
         (= (tlen rtree) sizer)
         (=> (= var_u2514 (+ sizel 1)) (= (tlen v) var_u2514))))))
(assert (not (forall ((var_u2515 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), sizel ), ltree ), _lbv6 ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), sizel ), ltree ), s ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), sizel ), ltree ), s ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), sizel ), ltree ), s ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument sizel :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument s :: {var_v0:Ty_int | true} | true
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((sizel) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                    
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T3447)
(declare-fun |0| () Int)
(declare-fun tlen (T3447) Int)
(declare-fun v () T3447)
(declare-fun sizel () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T3447)
(declare-fun ltree () T3447)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T3447)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2521 Int)
         (var_u2520 Int)
         (var_u2519 Int)
         (var_u2518 Int)
         (var_u2517 Int)
         (var_u2516 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2518 (+ sizel 1)) (= (tlen v) var_u2518))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2521 (+ sizel 1)) (= (tlen v) var_u2521))))))
(assert (not (forall ((var_u2522 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), sizel ), ltree ), s ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), sizel ), ltree ), _lbv2 ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), sizel ), ltree ), apply subs  (, apply int_gen  (, dummy ) ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), sizel ), ltree ), _lbv2 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument sizel :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv2 :: {v:Ty_int | (v) ==((_lbv0) -- (1))} | (_lbv2) ==((_lbv0) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((sizel) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                    
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T3453)
(declare-fun |0| () Int)
(declare-fun tlen (T3453) Int)
(declare-fun v () T3453)
(declare-fun sizel () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T3453)
(declare-fun _lbv0 () Int)
(declare-fun _lbv2 () Int)
(declare-fun ltree () T3453)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T3453)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2528 Int)
         (var_u2527 Int)
         (var_u2526 Int)
         (var_u2525 Int)
         (var_u2524 Int)
         (var_u2523 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2525 (+ sizel 1)) (= (tlen v) var_u2525))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (= (tlen ltree) sizel)
         (= _lbv2 (- _lbv0 1))
         (= (tlen rtree) sizer)
         (=> (= var_u2528 (+ sizel 1)) (= (tlen v) var_u2528))))))
(assert (not (forall ((var_u2529 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), sizel ), ltree ), _lbv2 ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), sizel ), ltree ), _lbv1 ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), sizel ), ltree ), apply subs  (, s0 ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), sizel ), ltree ), _lbv1 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument sizel :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((sizel) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                    
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T3459)
(declare-fun |0| () Int)
(declare-fun tlen (T3459) Int)
(declare-fun v () T3459)
(declare-fun sizel () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T3459)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun ltree () T3459)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T3459)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2535 Int)
         (var_u2534 Int)
         (var_u2533 Int)
         (var_u2532 Int)
         (var_u2531 Int)
         (var_u2530 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2532 (+ sizel 1)) (= (tlen v) var_u2532))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (= (tlen ltree) sizel)
         (= _lbv1 (- s0 1))
         (= (tlen rtree) sizer)
         (=> (= var_u2535 (+ sizel 1)) (= (tlen v) var_u2535))))))
(assert (not (forall ((var_u2536 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), sizel ), ltree ), _lbv1 ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), sizel ), ltree ), _lbv0 ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), sizel ), ltree ), apply int_gen  (, dummy ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), sizel ), ltree ), _lbv0 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument sizel :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((sizel) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T3465)
(declare-fun |0| () Int)
(declare-fun tlen (T3465) Int)
(declare-fun v () T3465)
(declare-fun sizel () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T3465)
(declare-fun _lbv0 () Int)
(declare-fun ltree () T3465)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T3465)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2542 Int)
         (var_u2541 Int)
         (var_u2540 Int)
         (var_u2539 Int)
         (var_u2538 Int)
         (var_u2537 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2539 (+ sizel 1)) (= (tlen v) var_u2539))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (= (tlen ltree) sizel)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen rtree) sizer)
         (=> (= var_u2542 (+ sizel 1)) (= (tlen v) var_u2542))))))
(assert (not (forall ((var_u2543 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), sizel ), ltree ), _lbv0 ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), sizel ), ltree ), s0 ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), sizel ), ltree ), s0 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), sizel ), ltree ), s0 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument sizel :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument s0 :: {v:Ty_int | true} | true
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((sizel) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                    
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T3471)
(declare-fun |0| () Int)
(declare-fun tlen (T3471) Int)
(declare-fun v () T3471)
(declare-fun sizel () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T3471)
(declare-fun ltree () T3471)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T3471)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2549 Int)
         (var_u2548 Int)
         (var_u2547 Int)
         (var_u2546 Int)
         (var_u2545 Int)
         (var_u2544 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2546 (+ sizel 1)) (= (tlen v) var_u2546))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2549 (+ sizel 1)) (= (tlen v) var_u2549))))))
(assert (not (forall ((var_u2550 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), sizel ), ltree ), s0 ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), sizel ), ltree ), _lbv1 ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), sizel ), ltree ), apply subs  (, s0 ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), sizel ), ltree ), _lbv1 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument sizel :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((sizel) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                    
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T3477)
(declare-fun |0| () Int)
(declare-fun tlen (T3477) Int)
(declare-fun v () T3477)
(declare-fun sizel () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T3477)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun ltree () T3477)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T3477)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2556 Int)
         (var_u2555 Int)
         (var_u2554 Int)
         (var_u2553 Int)
         (var_u2552 Int)
         (var_u2551 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2553 (+ sizel 1)) (= (tlen v) var_u2553))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (= (tlen ltree) sizel)
         (= _lbv1 (- s0 1))
         (= (tlen rtree) sizer)
         (=> (= var_u2556 (+ sizel 1)) (= (tlen v) var_u2556))))))
(assert (not (forall ((var_u2557 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), sizel ), ltree ), _lbv1 ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), sizel ), ltree ), _lbv2 ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), sizel ), ltree ), apply subs  (, apply int_gen  (, dummy ) ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), sizel ), ltree ), _lbv2 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument sizel :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv2 :: {v:Ty_int | (v) ==((_lbv0) -- (1))} | (_lbv2) ==((_lbv0) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((sizel) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                    
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T3483)
(declare-fun |0| () Int)
(declare-fun tlen (T3483) Int)
(declare-fun v () T3483)
(declare-fun sizel () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T3483)
(declare-fun _lbv0 () Int)
(declare-fun _lbv2 () Int)
(declare-fun ltree () T3483)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T3483)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2563 Int)
         (var_u2562 Int)
         (var_u2561 Int)
         (var_u2560 Int)
         (var_u2559 Int)
         (var_u2558 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2560 (+ sizel 1)) (= (tlen v) var_u2560))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (= (tlen ltree) sizel)
         (= _lbv2 (- _lbv0 1))
         (= (tlen rtree) sizer)
         (=> (= var_u2563 (+ sizel 1)) (= (tlen v) var_u2563))))))
(assert (not (forall ((var_u2564 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), sizel ), ltree ), _lbv2 ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), sizel ), ltree ), _lbv8 ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), sizel ), ltree ), apply subs  (, s ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), sizel ), ltree ), _lbv8 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument sizel :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv8 :: {v:Ty_int | (v) ==((s) -- (1))} | (_lbv8) ==((s) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((sizel) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                    
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T3489)
(declare-fun |0| () Int)
(declare-fun tlen (T3489) Int)
(declare-fun v () T3489)
(declare-fun sizel () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T3489)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun ltree () T3489)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T3489)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2570 Int)
         (var_u2569 Int)
         (var_u2568 Int)
         (var_u2567 Int)
         (var_u2566 Int)
         (var_u2565 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2567 (+ sizel 1)) (= (tlen v) var_u2567))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (= (tlen ltree) sizel)
         (= _lbv8 (- s 1))
         (= (tlen rtree) sizer)
         (=> (= var_u2570 (+ sizel 1)) (= (tlen v) var_u2570))))))
(assert (not (forall ((var_u2571 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), sizel ), ltree ), _lbv8 ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), sizel ), ltree ), _lbv7 ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), sizel ), ltree ), apply subs  (, s01 ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), sizel ), ltree ), _lbv7 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument sizel :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv7 :: {v:Ty_int | (v) ==((s01) -- (1))} | (_lbv7) ==((s01) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((sizel) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                    
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T3495)
(declare-fun |0| () Int)
(declare-fun tlen (T3495) Int)
(declare-fun v () T3495)
(declare-fun sizel () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T3495)
(declare-fun s01 () Int)
(declare-fun _lbv7 () Int)
(declare-fun ltree () T3495)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T3495)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2577 Int)
         (var_u2576 Int)
         (var_u2575 Int)
         (var_u2574 Int)
         (var_u2573 Int)
         (var_u2572 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2574 (+ sizel 1)) (= (tlen v) var_u2574))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (= (tlen ltree) sizel)
         (= _lbv7 (- s01 1))
         (= (tlen rtree) sizer)
         (=> (= var_u2577 (+ sizel 1)) (= (tlen v) var_u2577))))))
(assert (not (forall ((var_u2578 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), sizel ), ltree ), _lbv7 ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), sizel ), ltree ), _lbv6 ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), sizel ), ltree ), apply subs  (, root ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), sizel ), ltree ), _lbv6 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument sizel :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv6 :: {v:Ty_int | (v) ==((root) -- (1))} | (_lbv6) ==((root) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((sizel) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                    
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T3501)
(declare-fun |0| () Int)
(declare-fun tlen (T3501) Int)
(declare-fun v () T3501)
(declare-fun sizel () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T3501)
(declare-fun root () Int)
(declare-fun _lbv6 () Int)
(declare-fun ltree () T3501)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T3501)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2584 Int)
         (var_u2583 Int)
         (var_u2582 Int)
         (var_u2581 Int)
         (var_u2580 Int)
         (var_u2579 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2581 (+ sizel 1)) (= (tlen v) var_u2581))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (= (tlen ltree) sizel)
         (= _lbv6 (- root 1))
         (= (tlen rtree) sizer)
         (=> (= var_u2584 (+ sizel 1)) (= (tlen v) var_u2584))))))
(assert (not (forall ((var_u2585 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), sizel ), ltree ), _lbv6 ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), sizel ), ltree ), _lbv10 ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), sizel ), ltree ), apply subs  (, sizel ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), sizel ), ltree ), _lbv10 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument sizel :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv10 :: {v:Ty_int | (v) ==((sizel) -- (1))} | (_lbv10) ==((sizel) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((sizel) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                    
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T3507)
(declare-fun |0| () Int)
(declare-fun tlen (T3507) Int)
(declare-fun v () T3507)
(declare-fun sizel () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T3507)
(declare-fun _lbv10 () Int)
(declare-fun ltree () T3507)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T3507)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2591 Int)
         (var_u2590 Int)
         (var_u2589 Int)
         (var_u2588 Int)
         (var_u2587 Int)
         (var_u2586 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2588 (+ sizel 1)) (= (tlen v) var_u2588))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (= (tlen ltree) sizel)
         (= _lbv10 (- sizel 1))
         (= (tlen rtree) sizer)
         (=> (= var_u2591 (+ sizel 1)) (= (tlen v) var_u2591))))))
(assert (not (forall ((var_u2592 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), sizel ), ltree ), _lbv10 ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), sizel ), ltree ), _lbv9 ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), sizel ), ltree ), apply subs  (, sizer ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), sizel ), ltree ), _lbv9 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument sizel :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv9 :: {v:Ty_int | (v) ==((sizer) -- (1))} | (_lbv9) ==((sizer) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((sizel) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                    
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T3513)
(declare-fun |0| () Int)
(declare-fun tlen (T3513) Int)
(declare-fun v () T3513)
(declare-fun sizel () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T3513)
(declare-fun _lbv9 () Int)
(declare-fun ltree () T3513)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T3513)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2598 Int)
         (var_u2597 Int)
         (var_u2596 Int)
         (var_u2595 Int)
         (var_u2594 Int)
         (var_u2593 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2595 (+ sizel 1)) (= (tlen v) var_u2595))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (= (tlen ltree) sizel)
         (= _lbv9 (- sizer 1))
         (= (tlen rtree) sizer)
         (=> (= var_u2598 (+ sizel 1)) (= (tlen v) var_u2598))))))
(assert (not (forall ((var_u2599 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), sizel ), ltree ), _lbv9 ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), s ), ltree ), sizer ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), s ), ltree ), sizer ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), s ), ltree ), sizer ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument s :: {var_v0:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument sizer :: {v:Ty_int | true} | true
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((s) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                    
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T3519)
(declare-fun |0| () Int)
(declare-fun tlen (T3519) Int)
(declare-fun v () T3519)
(declare-fun s () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T3519)
(declare-fun sizel () Int)
(declare-fun ltree () T3519)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T3519)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2605 Int)
         (var_u2604 Int)
         (var_u2603 Int)
         (var_u2602 Int)
         (var_u2601 Int)
         (var_u2600 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2602 (+ s 1)) (= (tlen v) var_u2602))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2605 (+ s 1)) (= (tlen v) var_u2605))))))
(assert (not (forall ((var_u2606 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), s ), ltree ), sizer ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), s ), ltree ), sizel ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), s ), ltree ), sizel ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), s ), ltree ), sizel ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument s :: {var_v0:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument sizel :: {v:Ty_int | true} | true
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((s) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                    
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T3525)
(declare-fun |0| () Int)
(declare-fun tlen (T3525) Int)
(declare-fun v () T3525)
(declare-fun s () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T3525)
(declare-fun sizel () Int)
(declare-fun ltree () T3525)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T3525)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2612 Int)
         (var_u2611 Int)
         (var_u2610 Int)
         (var_u2609 Int)
         (var_u2608 Int)
         (var_u2607 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2609 (+ s 1)) (= (tlen v) var_u2609))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2612 (+ s 1)) (= (tlen v) var_u2612))))))
(assert (not (forall ((var_u2613 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), s ), ltree ), sizel ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), s ), ltree ), root ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), s ), ltree ), root ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), s ), ltree ), root ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument s :: {var_v0:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument root :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  root > 0
 	,   root = 0>d 
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((s) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T3531)
(declare-fun |0| () Int)
(declare-fun tlen (T3531) Int)
(declare-fun v () T3531)
(declare-fun s () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T3531)
(declare-fun root () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T3531)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T3531)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2619 Int)
         (var_u2618 Int)
         (var_u2617 Int)
         (var_u2616 Int)
         (var_u2615 Int)
         (var_u2614 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2616 (+ s 1)) (= (tlen v) var_u2616))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (= (tlen ltree) sizel)
         (or (> root |0|) (= root |0|))
         (= (tlen rtree) sizer)
         (=> (= var_u2619 (+ s 1)) (= (tlen v) var_u2619))))))
(assert (not (forall ((var_u2620 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), s ), ltree ), root ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), s ), ltree ), s01 ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), s ), ltree ), s01 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), s ), ltree ), s01 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument s :: {var_v0:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument s01 :: {v:Ty_int | 
 	 Conj <c true
 	 , s0 > v >c } | 
 	 Conj <c true
 	 , s0 > s01 >c 
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((s) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                         
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T3537)
(declare-fun |0| () Int)
(declare-fun tlen (T3537) Int)
(declare-fun v () T3537)
(declare-fun s () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T3537)
(declare-fun s01 () Int)
(declare-fun s0 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T3537)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T3537)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2626 Int)
         (var_u2625 Int)
         (var_u2624 Int)
         (var_u2623 Int)
         (var_u2622 Int)
         (var_u2621 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2623 (+ s 1)) (= (tlen v) var_u2623))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (= (tlen ltree) sizel)
         (> s0 s01)
         (= (tlen rtree) sizer)
         (=> (= var_u2626 (+ s 1)) (= (tlen v) var_u2626))))))
(assert (not (forall ((var_u2627 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), s ), ltree ), s01 ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), s ), ltree ), n ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), s ), ltree ), n ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), s ), ltree ), n ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument s :: {var_v0:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument n :: {v:Ty_int | true} | true
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((s) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                    
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T3543)
(declare-fun |0| () Int)
(declare-fun tlen (T3543) Int)
(declare-fun v () T3543)
(declare-fun s () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T3543)
(declare-fun sizel () Int)
(declare-fun ltree () T3543)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T3543)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2633 Int)
         (var_u2632 Int)
         (var_u2631 Int)
         (var_u2630 Int)
         (var_u2629 Int)
         (var_u2628 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2630 (+ s 1)) (= (tlen v) var_u2630))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2633 (+ s 1)) (= (tlen v) var_u2633))))))
(assert (not (forall ((var_u2634 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), s ), ltree ), n ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), s ), ltree ), _lbv10 ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), s ), ltree ), apply subs  (, sizel ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), s ), ltree ), _lbv10 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument s :: {var_v0:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv10 :: {v:Ty_int | (v) ==((sizel) -- (1))} | (_lbv10) ==((sizel) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((s) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                    
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T3549)
(declare-fun |0| () Int)
(declare-fun tlen (T3549) Int)
(declare-fun v () T3549)
(declare-fun s () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T3549)
(declare-fun sizel () Int)
(declare-fun _lbv10 () Int)
(declare-fun ltree () T3549)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv9 () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T3549)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2640 Int)
         (var_u2639 Int)
         (var_u2638 Int)
         (var_u2637 Int)
         (var_u2636 Int)
         (var_u2635 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2637 (+ s 1)) (= (tlen v) var_u2637))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (= (tlen ltree) sizel)
         (= _lbv10 (- sizel 1))
         (= (tlen rtree) sizer)
         (=> (= var_u2640 (+ s 1)) (= (tlen v) var_u2640))))))
(assert (not (forall ((var_u2641 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), s ), ltree ), _lbv10 ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), s ), ltree ), _lbv9 ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), s ), ltree ), apply subs  (, sizer ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), s ), ltree ), _lbv9 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument s :: {var_v0:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv9 :: {v:Ty_int | (v) ==((sizer) -- (1))} | (_lbv9) ==((sizer) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((s) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                    
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T3555)
(declare-fun |0| () Int)
(declare-fun tlen (T3555) Int)
(declare-fun v () T3555)
(declare-fun s () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T3555)
(declare-fun _lbv9 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T3555)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T3555)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2647 Int)
         (var_u2646 Int)
         (var_u2645 Int)
         (var_u2644 Int)
         (var_u2643 Int)
         (var_u2642 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2644 (+ s 1)) (= (tlen v) var_u2644))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (= (tlen ltree) sizel)
         (= _lbv9 (- sizer 1))
         (= (tlen rtree) sizer)
         (=> (= var_u2647 (+ s 1)) (= (tlen v) var_u2647))))))
(assert (not (forall ((var_u2648 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), s ), ltree ), _lbv9 ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), s ), ltree ), _lbv8 ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), s ), ltree ), apply subs  (, s ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), s ), ltree ), _lbv8 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument s :: {var_v0:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv8 :: {v:Ty_int | (v) ==((s) -- (1))} | (_lbv8) ==((s) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((s) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                    
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T3561)
(declare-fun |0| () Int)
(declare-fun tlen (T3561) Int)
(declare-fun v () T3561)
(declare-fun s () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T3561)
(declare-fun _lbv8 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T3561)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T3561)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2654 Int)
         (var_u2653 Int)
         (var_u2652 Int)
         (var_u2651 Int)
         (var_u2650 Int)
         (var_u2649 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2651 (+ s 1)) (= (tlen v) var_u2651))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (= (tlen ltree) sizel)
         (= _lbv8 (- s 1))
         (= (tlen rtree) sizer)
         (=> (= var_u2654 (+ s 1)) (= (tlen v) var_u2654))))))
(assert (not (forall ((var_u2655 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), s ), ltree ), _lbv8 ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), s ), ltree ), _lbv7 ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), s ), ltree ), apply subs  (, s01 ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), s ), ltree ), _lbv7 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument s :: {var_v0:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv7 :: {v:Ty_int | (v) ==((s01) -- (1))} | (_lbv7) ==((s01) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((s) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                    
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T3567)
(declare-fun |0| () Int)
(declare-fun tlen (T3567) Int)
(declare-fun v () T3567)
(declare-fun s () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T3567)
(declare-fun s01 () Int)
(declare-fun _lbv7 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T3567)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T3567)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2661 Int)
         (var_u2660 Int)
         (var_u2659 Int)
         (var_u2658 Int)
         (var_u2657 Int)
         (var_u2656 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2658 (+ s 1)) (= (tlen v) var_u2658))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (= (tlen ltree) sizel)
         (= _lbv7 (- s01 1))
         (= (tlen rtree) sizer)
         (=> (= var_u2661 (+ s 1)) (= (tlen v) var_u2661))))))
(assert (not (forall ((var_u2662 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), s ), ltree ), _lbv7 ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), s ), ltree ), _lbv6 ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), s ), ltree ), apply subs  (, root ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), s ), ltree ), _lbv6 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument s :: {var_v0:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv6 :: {v:Ty_int | (v) ==((root) -- (1))} | (_lbv6) ==((root) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((s) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                    
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T3573)
(declare-fun |0| () Int)
(declare-fun tlen (T3573) Int)
(declare-fun v () T3573)
(declare-fun s () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T3573)
(declare-fun root () Int)
(declare-fun _lbv6 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T3573)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T3573)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2668 Int)
         (var_u2667 Int)
         (var_u2666 Int)
         (var_u2665 Int)
         (var_u2664 Int)
         (var_u2663 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2665 (+ s 1)) (= (tlen v) var_u2665))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (= (tlen ltree) sizel)
         (= _lbv6 (- root 1))
         (= (tlen rtree) sizer)
         (=> (= var_u2668 (+ s 1)) (= (tlen v) var_u2668))))))
(assert (not (forall ((var_u2669 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), s ), ltree ), _lbv6 ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), s ), ltree ), s ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), s ), ltree ), s ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), s ), ltree ), s ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument s :: {var_v0:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument s :: {var_v0:Ty_int | true} | true
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((s) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                    
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T3579)
(declare-fun |0| () Int)
(declare-fun tlen (T3579) Int)
(declare-fun v () T3579)
(declare-fun s () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T3579)
(declare-fun sizel () Int)
(declare-fun ltree () T3579)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T3579)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2675 Int)
         (var_u2674 Int)
         (var_u2673 Int)
         (var_u2672 Int)
         (var_u2671 Int)
         (var_u2670 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2672 (+ s 1)) (= (tlen v) var_u2672))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2675 (+ s 1)) (= (tlen v) var_u2675))))))
(assert (not (forall ((var_u2676 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), s ), ltree ), s ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), s ), ltree ), _lbv2 ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), s ), ltree ), apply subs  (, apply int_gen  (, dummy ) ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), s ), ltree ), _lbv2 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument s :: {var_v0:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv2 :: {v:Ty_int | (v) ==((_lbv0) -- (1))} | (_lbv2) ==((_lbv0) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((s) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                    
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T3585)
(declare-fun |0| () Int)
(declare-fun tlen (T3585) Int)
(declare-fun v () T3585)
(declare-fun s () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T3585)
(declare-fun _lbv0 () Int)
(declare-fun _lbv2 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T3585)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T3585)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2682 Int)
         (var_u2681 Int)
         (var_u2680 Int)
         (var_u2679 Int)
         (var_u2678 Int)
         (var_u2677 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2679 (+ s 1)) (= (tlen v) var_u2679))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (= (tlen ltree) sizel)
         (= _lbv2 (- _lbv0 1))
         (= (tlen rtree) sizer)
         (=> (= var_u2682 (+ s 1)) (= (tlen v) var_u2682))))))
(assert (not (forall ((var_u2683 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), s ), ltree ), _lbv2 ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), s ), ltree ), _lbv1 ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), s ), ltree ), apply subs  (, s0 ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), s ), ltree ), _lbv1 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument s :: {var_v0:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((s) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                    
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T3591)
(declare-fun |0| () Int)
(declare-fun tlen (T3591) Int)
(declare-fun v () T3591)
(declare-fun s () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T3591)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T3591)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T3591)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2689 Int)
         (var_u2688 Int)
         (var_u2687 Int)
         (var_u2686 Int)
         (var_u2685 Int)
         (var_u2684 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2686 (+ s 1)) (= (tlen v) var_u2686))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (= (tlen ltree) sizel)
         (= _lbv1 (- s0 1))
         (= (tlen rtree) sizer)
         (=> (= var_u2689 (+ s 1)) (= (tlen v) var_u2689))))))
(assert (not (forall ((var_u2690 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), s ), ltree ), _lbv1 ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), s ), ltree ), _lbv0 ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), s ), ltree ), apply int_gen  (, dummy ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), s ), ltree ), _lbv0 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument s :: {var_v0:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((s) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T3597)
(declare-fun |0| () Int)
(declare-fun tlen (T3597) Int)
(declare-fun v () T3597)
(declare-fun s () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T3597)
(declare-fun _lbv0 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T3597)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T3597)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2696 Int)
         (var_u2695 Int)
         (var_u2694 Int)
         (var_u2693 Int)
         (var_u2692 Int)
         (var_u2691 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2693 (+ s 1)) (= (tlen v) var_u2693))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (= (tlen ltree) sizel)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen rtree) sizer)
         (=> (= var_u2696 (+ s 1)) (= (tlen v) var_u2696))))))
(assert (not (forall ((var_u2697 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), s ), ltree ), _lbv0 ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), s ), ltree ), s0 ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), s ), ltree ), s0 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), s ), ltree ), s0 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument s :: {var_v0:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument s0 :: {v:Ty_int | true} | true
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((s) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                    
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T3603)
(declare-fun |0| () Int)
(declare-fun tlen (T3603) Int)
(declare-fun v () T3603)
(declare-fun s () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T3603)
(declare-fun sizel () Int)
(declare-fun ltree () T3603)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T3603)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2703 Int)
         (var_u2702 Int)
         (var_u2701 Int)
         (var_u2700 Int)
         (var_u2699 Int)
         (var_u2698 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2700 (+ s 1)) (= (tlen v) var_u2700))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2703 (+ s 1)) (= (tlen v) var_u2703))))))
(assert (not (forall ((var_u2704 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), s ), ltree ), s0 ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), s ), ltree ), _lbv1 ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), s ), ltree ), apply subs  (, s0 ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), s ), ltree ), _lbv1 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument s :: {var_v0:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((s) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                    
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T3609)
(declare-fun |0| () Int)
(declare-fun tlen (T3609) Int)
(declare-fun v () T3609)
(declare-fun s () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T3609)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T3609)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T3609)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2710 Int)
         (var_u2709 Int)
         (var_u2708 Int)
         (var_u2707 Int)
         (var_u2706 Int)
         (var_u2705 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2707 (+ s 1)) (= (tlen v) var_u2707))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (= (tlen ltree) sizel)
         (= _lbv1 (- s0 1))
         (= (tlen rtree) sizer)
         (=> (= var_u2710 (+ s 1)) (= (tlen v) var_u2710))))))
(assert (not (forall ((var_u2711 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), s ), ltree ), _lbv1 ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), s ), ltree ), _lbv2 ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), s ), ltree ), apply subs  (, apply int_gen  (, dummy ) ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), s ), ltree ), _lbv2 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument s :: {var_v0:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv2 :: {v:Ty_int | (v) ==((_lbv0) -- (1))} | (_lbv2) ==((_lbv0) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((s) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                    
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T3615)
(declare-fun |0| () Int)
(declare-fun tlen (T3615) Int)
(declare-fun v () T3615)
(declare-fun s () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T3615)
(declare-fun _lbv0 () Int)
(declare-fun _lbv2 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T3615)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T3615)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2717 Int)
         (var_u2716 Int)
         (var_u2715 Int)
         (var_u2714 Int)
         (var_u2713 Int)
         (var_u2712 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2714 (+ s 1)) (= (tlen v) var_u2714))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (= (tlen ltree) sizel)
         (= _lbv2 (- _lbv0 1))
         (= (tlen rtree) sizer)
         (=> (= var_u2717 (+ s 1)) (= (tlen v) var_u2717))))))
(assert (not (forall ((var_u2718 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), s ), ltree ), _lbv2 ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), s ), ltree ), _lbv8 ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), s ), ltree ), apply subs  (, s ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), s ), ltree ), _lbv8 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument s :: {var_v0:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv8 :: {v:Ty_int | (v) ==((s) -- (1))} | (_lbv8) ==((s) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((s) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                    
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T3621)
(declare-fun |0| () Int)
(declare-fun tlen (T3621) Int)
(declare-fun v () T3621)
(declare-fun s () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T3621)
(declare-fun _lbv8 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T3621)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T3621)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2724 Int)
         (var_u2723 Int)
         (var_u2722 Int)
         (var_u2721 Int)
         (var_u2720 Int)
         (var_u2719 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2721 (+ s 1)) (= (tlen v) var_u2721))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (= (tlen ltree) sizel)
         (= _lbv8 (- s 1))
         (= (tlen rtree) sizer)
         (=> (= var_u2724 (+ s 1)) (= (tlen v) var_u2724))))))
(assert (not (forall ((var_u2725 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), s ), ltree ), _lbv8 ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), s ), ltree ), _lbv7 ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), s ), ltree ), apply subs  (, s01 ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), s ), ltree ), _lbv7 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument s :: {var_v0:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv7 :: {v:Ty_int | (v) ==((s01) -- (1))} | (_lbv7) ==((s01) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((s) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                    
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T3627)
(declare-fun |0| () Int)
(declare-fun tlen (T3627) Int)
(declare-fun v () T3627)
(declare-fun s () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T3627)
(declare-fun s01 () Int)
(declare-fun _lbv7 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T3627)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T3627)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2731 Int)
         (var_u2730 Int)
         (var_u2729 Int)
         (var_u2728 Int)
         (var_u2727 Int)
         (var_u2726 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2728 (+ s 1)) (= (tlen v) var_u2728))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (= (tlen ltree) sizel)
         (= _lbv7 (- s01 1))
         (= (tlen rtree) sizer)
         (=> (= var_u2731 (+ s 1)) (= (tlen v) var_u2731))))))
(assert (not (forall ((var_u2732 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), s ), ltree ), _lbv7 ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), s ), ltree ), _lbv6 ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), s ), ltree ), apply subs  (, root ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), s ), ltree ), _lbv6 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument s :: {var_v0:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv6 :: {v:Ty_int | (v) ==((root) -- (1))} | (_lbv6) ==((root) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((s) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                    
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T3633)
(declare-fun |0| () Int)
(declare-fun tlen (T3633) Int)
(declare-fun v () T3633)
(declare-fun s () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T3633)
(declare-fun root () Int)
(declare-fun _lbv6 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T3633)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T3633)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2738 Int)
         (var_u2737 Int)
         (var_u2736 Int)
         (var_u2735 Int)
         (var_u2734 Int)
         (var_u2733 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2735 (+ s 1)) (= (tlen v) var_u2735))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (= (tlen ltree) sizel)
         (= _lbv6 (- root 1))
         (= (tlen rtree) sizer)
         (=> (= var_u2738 (+ s 1)) (= (tlen v) var_u2738))))))
(assert (not (forall ((var_u2739 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), s ), ltree ), _lbv6 ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), s ), ltree ), _lbv10 ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), s ), ltree ), apply subs  (, sizel ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), s ), ltree ), _lbv10 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument s :: {var_v0:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv10 :: {v:Ty_int | (v) ==((sizel) -- (1))} | (_lbv10) ==((sizel) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((s) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                    
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T3639)
(declare-fun |0| () Int)
(declare-fun tlen (T3639) Int)
(declare-fun v () T3639)
(declare-fun s () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T3639)
(declare-fun sizel () Int)
(declare-fun _lbv10 () Int)
(declare-fun ltree () T3639)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv9 () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T3639)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2745 Int)
         (var_u2744 Int)
         (var_u2743 Int)
         (var_u2742 Int)
         (var_u2741 Int)
         (var_u2740 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2742 (+ s 1)) (= (tlen v) var_u2742))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (= (tlen ltree) sizel)
         (= _lbv10 (- sizel 1))
         (= (tlen rtree) sizer)
         (=> (= var_u2745 (+ s 1)) (= (tlen v) var_u2745))))))
(assert (not (forall ((var_u2746 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), s ), ltree ), _lbv10 ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), s ), ltree ), _lbv9 ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), s ), ltree ), apply subs  (, sizer ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), s ), ltree ), _lbv9 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument s :: {var_v0:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv9 :: {v:Ty_int | (v) ==((sizer) -- (1))} | (_lbv9) ==((sizer) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((s) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                    
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T3645)
(declare-fun |0| () Int)
(declare-fun tlen (T3645) Int)
(declare-fun v () T3645)
(declare-fun s () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T3645)
(declare-fun _lbv9 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T3645)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T3645)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2752 Int)
         (var_u2751 Int)
         (var_u2750 Int)
         (var_u2749 Int)
         (var_u2748 Int)
         (var_u2747 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2749 (+ s 1)) (= (tlen v) var_u2749))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (= (tlen ltree) sizel)
         (= _lbv9 (- sizer 1))
         (= (tlen rtree) sizer)
         (=> (= var_u2752 (+ s 1)) (= (tlen v) var_u2752))))))
(assert (not (forall ((var_u2753 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), s ), ltree ), _lbv9 ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), _lbv0 ), ltree ), sizer ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), apply int_gen  (, dummy ) ), ltree ), sizer ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), _lbv0 ), ltree ), sizer ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument sizer :: {v:Ty_int | true} | true
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((_lbv0) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T3651)
(declare-fun |0| () Int)
(declare-fun tlen (T3651) Int)
(declare-fun v () T3651)
(declare-fun _lbv0 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T3651)
(declare-fun sizel () Int)
(declare-fun ltree () T3651)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T3651)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2759 Int)
         (var_u2758 Int)
         (var_u2757 Int)
         (var_u2756 Int)
         (var_u2755 Int)
         (var_u2754 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2756 (+ _lbv0 1)) (= (tlen v) var_u2756))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2759 (+ _lbv0 1)) (= (tlen v) var_u2759))))))
(assert (not (forall ((var_u2760 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), _lbv0 ), ltree ), sizer ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), _lbv0 ), ltree ), sizel ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), apply int_gen  (, dummy ) ), ltree ), sizel ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), _lbv0 ), ltree ), sizel ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument sizel :: {v:Ty_int | true} | true
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((_lbv0) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T3657)
(declare-fun |0| () Int)
(declare-fun tlen (T3657) Int)
(declare-fun v () T3657)
(declare-fun _lbv0 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T3657)
(declare-fun sizel () Int)
(declare-fun ltree () T3657)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T3657)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2766 Int)
         (var_u2765 Int)
         (var_u2764 Int)
         (var_u2763 Int)
         (var_u2762 Int)
         (var_u2761 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2763 (+ _lbv0 1)) (= (tlen v) var_u2763))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2766 (+ _lbv0 1)) (= (tlen v) var_u2766))))))
(assert (not (forall ((var_u2767 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), _lbv0 ), ltree ), sizel ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), _lbv0 ), ltree ), root ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), apply int_gen  (, dummy ) ), ltree ), root ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), _lbv0 ), ltree ), root ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument root :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  root > 0
 	,   root = 0>d 
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((_lbv0) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                                          
# of Final Z3 expressions 20
 Final solver 
 (declare-sort T3663)
(declare-fun |0| () Int)
(declare-fun tlen (T3663) Int)
(declare-fun v () T3663)
(declare-fun _lbv0 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T3663)
(declare-fun root () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T3663)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T3663)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2773 Int)
         (var_u2772 Int)
         (var_u2771 Int)
         (var_u2770 Int)
         (var_u2769 Int)
         (var_u2768 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2770 (+ _lbv0 1)) (= (tlen v) var_u2770))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (or (> root |0|) (= root |0|))
         (= (tlen rtree) sizer)
         (=> (= var_u2773 (+ _lbv0 1)) (= (tlen v) var_u2773))))))
(assert (not (forall ((var_u2774 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), _lbv0 ), ltree ), root ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), _lbv0 ), ltree ), s01 ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), apply int_gen  (, dummy ) ), ltree ), s01 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), _lbv0 ), ltree ), s01 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument s01 :: {v:Ty_int | 
 	 Conj <c true
 	 , s0 > v >c } | 
 	 Conj <c true
 	 , s0 > s01 >c 
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((_lbv0) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                                    
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T3669)
(declare-fun |0| () Int)
(declare-fun tlen (T3669) Int)
(declare-fun v () T3669)
(declare-fun _lbv0 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T3669)
(declare-fun s01 () Int)
(declare-fun s0 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T3669)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T3669)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2780 Int)
         (var_u2779 Int)
         (var_u2778 Int)
         (var_u2777 Int)
         (var_u2776 Int)
         (var_u2775 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2777 (+ _lbv0 1)) (= (tlen v) var_u2777))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (> s0 s01)
         (= (tlen rtree) sizer)
         (=> (= var_u2780 (+ _lbv0 1)) (= (tlen v) var_u2780))))))
(assert (not (forall ((var_u2781 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), _lbv0 ), ltree ), s01 ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), _lbv0 ), ltree ), n ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), apply int_gen  (, dummy ) ), ltree ), n ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), _lbv0 ), ltree ), n ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument n :: {v:Ty_int | true} | true
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((_lbv0) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T3675)
(declare-fun |0| () Int)
(declare-fun tlen (T3675) Int)
(declare-fun v () T3675)
(declare-fun _lbv0 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T3675)
(declare-fun sizel () Int)
(declare-fun ltree () T3675)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T3675)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2787 Int)
         (var_u2786 Int)
         (var_u2785 Int)
         (var_u2784 Int)
         (var_u2783 Int)
         (var_u2782 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2784 (+ _lbv0 1)) (= (tlen v) var_u2784))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2787 (+ _lbv0 1)) (= (tlen v) var_u2787))))))
(assert (not (forall ((var_u2788 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), _lbv0 ), ltree ), n ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), _lbv0 ), ltree ), _lbv10 ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), apply int_gen  (, dummy ) ), ltree ), apply subs  (, sizel ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), _lbv0 ), ltree ), _lbv10 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv10 :: {v:Ty_int | (v) ==((sizel) -- (1))} | (_lbv10) ==((sizel) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((_lbv0) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T3681)
(declare-fun |0| () Int)
(declare-fun tlen (T3681) Int)
(declare-fun v () T3681)
(declare-fun _lbv0 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T3681)
(declare-fun sizel () Int)
(declare-fun _lbv10 () Int)
(declare-fun ltree () T3681)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T3681)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2794 Int)
         (var_u2793 Int)
         (var_u2792 Int)
         (var_u2791 Int)
         (var_u2790 Int)
         (var_u2789 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2791 (+ _lbv0 1)) (= (tlen v) var_u2791))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= _lbv10 (- sizel 1))
         (= (tlen rtree) sizer)
         (=> (= var_u2794 (+ _lbv0 1)) (= (tlen v) var_u2794))))))
(assert (not (forall ((var_u2795 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), _lbv0 ), ltree ), _lbv10 ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), _lbv0 ), ltree ), _lbv9 ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), apply int_gen  (, dummy ) ), ltree ), apply subs  (, sizer ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), _lbv0 ), ltree ), _lbv9 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv9 :: {v:Ty_int | (v) ==((sizer) -- (1))} | (_lbv9) ==((sizer) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((_lbv0) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T3687)
(declare-fun |0| () Int)
(declare-fun tlen (T3687) Int)
(declare-fun v () T3687)
(declare-fun _lbv0 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T3687)
(declare-fun _lbv9 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T3687)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T3687)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2801 Int)
         (var_u2800 Int)
         (var_u2799 Int)
         (var_u2798 Int)
         (var_u2797 Int)
         (var_u2796 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2798 (+ _lbv0 1)) (= (tlen v) var_u2798))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= _lbv9 (- sizer 1))
         (= (tlen rtree) sizer)
         (=> (= var_u2801 (+ _lbv0 1)) (= (tlen v) var_u2801))))))
(assert (not (forall ((var_u2802 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), _lbv0 ), ltree ), _lbv9 ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), _lbv0 ), ltree ), _lbv8 ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), apply int_gen  (, dummy ) ), ltree ), apply subs  (, s ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), _lbv0 ), ltree ), _lbv8 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv8 :: {v:Ty_int | (v) ==((s) -- (1))} | (_lbv8) ==((s) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((_lbv0) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T3693)
(declare-fun |0| () Int)
(declare-fun tlen (T3693) Int)
(declare-fun v () T3693)
(declare-fun _lbv0 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T3693)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T3693)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T3693)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2808 Int)
         (var_u2807 Int)
         (var_u2806 Int)
         (var_u2805 Int)
         (var_u2804 Int)
         (var_u2803 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2805 (+ _lbv0 1)) (= (tlen v) var_u2805))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= _lbv8 (- s 1))
         (= (tlen rtree) sizer)
         (=> (= var_u2808 (+ _lbv0 1)) (= (tlen v) var_u2808))))))
(assert (not (forall ((var_u2809 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), _lbv0 ), ltree ), _lbv8 ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), _lbv0 ), ltree ), _lbv7 ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), apply int_gen  (, dummy ) ), ltree ), apply subs  (, s01 ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), _lbv0 ), ltree ), _lbv7 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv7 :: {v:Ty_int | (v) ==((s01) -- (1))} | (_lbv7) ==((s01) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((_lbv0) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T3699)
(declare-fun |0| () Int)
(declare-fun tlen (T3699) Int)
(declare-fun v () T3699)
(declare-fun _lbv0 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T3699)
(declare-fun s01 () Int)
(declare-fun _lbv7 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T3699)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T3699)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2815 Int)
         (var_u2814 Int)
         (var_u2813 Int)
         (var_u2812 Int)
         (var_u2811 Int)
         (var_u2810 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2812 (+ _lbv0 1)) (= (tlen v) var_u2812))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= _lbv7 (- s01 1))
         (= (tlen rtree) sizer)
         (=> (= var_u2815 (+ _lbv0 1)) (= (tlen v) var_u2815))))))
(assert (not (forall ((var_u2816 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), _lbv0 ), ltree ), _lbv7 ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), _lbv0 ), ltree ), _lbv6 ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), apply int_gen  (, dummy ) ), ltree ), apply subs  (, root ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), _lbv0 ), ltree ), _lbv6 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv6 :: {v:Ty_int | (v) ==((root) -- (1))} | (_lbv6) ==((root) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((_lbv0) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T3705)
(declare-fun |0| () Int)
(declare-fun tlen (T3705) Int)
(declare-fun v () T3705)
(declare-fun _lbv0 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T3705)
(declare-fun root () Int)
(declare-fun _lbv6 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T3705)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T3705)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2822 Int)
         (var_u2821 Int)
         (var_u2820 Int)
         (var_u2819 Int)
         (var_u2818 Int)
         (var_u2817 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2819 (+ _lbv0 1)) (= (tlen v) var_u2819))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= _lbv6 (- root 1))
         (= (tlen rtree) sizer)
         (=> (= var_u2822 (+ _lbv0 1)) (= (tlen v) var_u2822))))))
(assert (not (forall ((var_u2823 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), _lbv0 ), ltree ), _lbv6 ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), _lbv0 ), ltree ), s ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), apply int_gen  (, dummy ) ), ltree ), s ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), _lbv0 ), ltree ), s ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument s :: {var_v0:Ty_int | true} | true
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((_lbv0) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T3711)
(declare-fun |0| () Int)
(declare-fun tlen (T3711) Int)
(declare-fun v () T3711)
(declare-fun _lbv0 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T3711)
(declare-fun sizel () Int)
(declare-fun ltree () T3711)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T3711)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2829 Int)
         (var_u2828 Int)
         (var_u2827 Int)
         (var_u2826 Int)
         (var_u2825 Int)
         (var_u2824 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2826 (+ _lbv0 1)) (= (tlen v) var_u2826))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2829 (+ _lbv0 1)) (= (tlen v) var_u2829))))))
(assert (not (forall ((var_u2830 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), _lbv0 ), ltree ), s ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), _lbv0 ), ltree ), _lbv2 ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), apply int_gen  (, dummy ) ), ltree ), apply subs  (, apply int_gen  (, dummy ) ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), _lbv0 ), ltree ), _lbv2 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv2 :: {v:Ty_int | (v) ==((_lbv0) -- (1))} | (_lbv2) ==((_lbv0) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((_lbv0) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T3717)
(declare-fun |0| () Int)
(declare-fun tlen (T3717) Int)
(declare-fun v () T3717)
(declare-fun _lbv0 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T3717)
(declare-fun _lbv2 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T3717)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T3717)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2836 Int)
         (var_u2835 Int)
         (var_u2834 Int)
         (var_u2833 Int)
         (var_u2832 Int)
         (var_u2831 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2833 (+ _lbv0 1)) (= (tlen v) var_u2833))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= _lbv2 (- _lbv0 1))
         (= (tlen rtree) sizer)
         (=> (= var_u2836 (+ _lbv0 1)) (= (tlen v) var_u2836))))))
(assert (not (forall ((var_u2837 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), _lbv0 ), ltree ), _lbv2 ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), _lbv0 ), ltree ), _lbv1 ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), apply int_gen  (, dummy ) ), ltree ), apply subs  (, s0 ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), _lbv0 ), ltree ), _lbv1 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((_lbv0) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T3723)
(declare-fun |0| () Int)
(declare-fun tlen (T3723) Int)
(declare-fun v () T3723)
(declare-fun _lbv0 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T3723)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T3723)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T3723)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2843 Int)
         (var_u2842 Int)
         (var_u2841 Int)
         (var_u2840 Int)
         (var_u2839 Int)
         (var_u2838 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2840 (+ _lbv0 1)) (= (tlen v) var_u2840))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= _lbv1 (- s0 1))
         (= (tlen rtree) sizer)
         (=> (= var_u2843 (+ _lbv0 1)) (= (tlen v) var_u2843))))))
(assert (not (forall ((var_u2844 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), _lbv0 ), ltree ), _lbv1 ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), _lbv0 ), ltree ), _lbv0 ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), apply int_gen  (, dummy ) ), ltree ), apply int_gen  (, dummy ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), _lbv0 ), ltree ), _lbv0 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((_lbv0) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                                          
# of Final Z3 expressions 20
 Final solver 
 (declare-sort T3729)
(declare-fun |0| () Int)
(declare-fun tlen (T3729) Int)
(declare-fun v () T3729)
(declare-fun _lbv0 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T3729)
(declare-fun sizel () Int)
(declare-fun ltree () T3729)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T3729)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2850 Int)
         (var_u2849 Int)
         (var_u2848 Int)
         (var_u2847 Int)
         (var_u2846 Int)
         (var_u2845 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2847 (+ _lbv0 1)) (= (tlen v) var_u2847))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen rtree) sizer)
         (=> (= var_u2850 (+ _lbv0 1)) (= (tlen v) var_u2850))))))
(assert (not (forall ((var_u2851 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), _lbv0 ), ltree ), _lbv0 ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), _lbv0 ), ltree ), s0 ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), apply int_gen  (, dummy ) ), ltree ), s0 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), _lbv0 ), ltree ), s0 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument s0 :: {v:Ty_int | true} | true
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((_lbv0) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T3735)
(declare-fun |0| () Int)
(declare-fun tlen (T3735) Int)
(declare-fun v () T3735)
(declare-fun _lbv0 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T3735)
(declare-fun sizel () Int)
(declare-fun ltree () T3735)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T3735)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2857 Int)
         (var_u2856 Int)
         (var_u2855 Int)
         (var_u2854 Int)
         (var_u2853 Int)
         (var_u2852 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2854 (+ _lbv0 1)) (= (tlen v) var_u2854))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2857 (+ _lbv0 1)) (= (tlen v) var_u2857))))))
(assert (not (forall ((var_u2858 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), _lbv0 ), ltree ), s0 ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), _lbv0 ), ltree ), _lbv1 ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), apply int_gen  (, dummy ) ), ltree ), apply subs  (, s0 ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), _lbv0 ), ltree ), _lbv1 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((_lbv0) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T3741)
(declare-fun |0| () Int)
(declare-fun tlen (T3741) Int)
(declare-fun v () T3741)
(declare-fun _lbv0 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T3741)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T3741)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T3741)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2864 Int)
         (var_u2863 Int)
         (var_u2862 Int)
         (var_u2861 Int)
         (var_u2860 Int)
         (var_u2859 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2861 (+ _lbv0 1)) (= (tlen v) var_u2861))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= _lbv1 (- s0 1))
         (= (tlen rtree) sizer)
         (=> (= var_u2864 (+ _lbv0 1)) (= (tlen v) var_u2864))))))
(assert (not (forall ((var_u2865 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), _lbv0 ), ltree ), _lbv1 ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), _lbv0 ), ltree ), _lbv2 ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), apply int_gen  (, dummy ) ), ltree ), apply subs  (, apply int_gen  (, dummy ) ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), _lbv0 ), ltree ), _lbv2 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv2 :: {v:Ty_int | (v) ==((_lbv0) -- (1))} | (_lbv2) ==((_lbv0) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((_lbv0) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T3747)
(declare-fun |0| () Int)
(declare-fun tlen (T3747) Int)
(declare-fun v () T3747)
(declare-fun _lbv0 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T3747)
(declare-fun _lbv2 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T3747)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T3747)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2871 Int)
         (var_u2870 Int)
         (var_u2869 Int)
         (var_u2868 Int)
         (var_u2867 Int)
         (var_u2866 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2868 (+ _lbv0 1)) (= (tlen v) var_u2868))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= _lbv2 (- _lbv0 1))
         (= (tlen rtree) sizer)
         (=> (= var_u2871 (+ _lbv0 1)) (= (tlen v) var_u2871))))))
(assert (not (forall ((var_u2872 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), _lbv0 ), ltree ), _lbv2 ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), _lbv0 ), ltree ), _lbv8 ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), apply int_gen  (, dummy ) ), ltree ), apply subs  (, s ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), _lbv0 ), ltree ), _lbv8 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv8 :: {v:Ty_int | (v) ==((s) -- (1))} | (_lbv8) ==((s) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((_lbv0) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T3753)
(declare-fun |0| () Int)
(declare-fun tlen (T3753) Int)
(declare-fun v () T3753)
(declare-fun _lbv0 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T3753)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T3753)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T3753)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2878 Int)
         (var_u2877 Int)
         (var_u2876 Int)
         (var_u2875 Int)
         (var_u2874 Int)
         (var_u2873 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2875 (+ _lbv0 1)) (= (tlen v) var_u2875))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= _lbv8 (- s 1))
         (= (tlen rtree) sizer)
         (=> (= var_u2878 (+ _lbv0 1)) (= (tlen v) var_u2878))))))
(assert (not (forall ((var_u2879 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), _lbv0 ), ltree ), _lbv8 ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), _lbv0 ), ltree ), _lbv7 ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), apply int_gen  (, dummy ) ), ltree ), apply subs  (, s01 ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), _lbv0 ), ltree ), _lbv7 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv7 :: {v:Ty_int | (v) ==((s01) -- (1))} | (_lbv7) ==((s01) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((_lbv0) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T3759)
(declare-fun |0| () Int)
(declare-fun tlen (T3759) Int)
(declare-fun v () T3759)
(declare-fun _lbv0 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T3759)
(declare-fun s01 () Int)
(declare-fun _lbv7 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T3759)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T3759)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2885 Int)
         (var_u2884 Int)
         (var_u2883 Int)
         (var_u2882 Int)
         (var_u2881 Int)
         (var_u2880 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2882 (+ _lbv0 1)) (= (tlen v) var_u2882))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= _lbv7 (- s01 1))
         (= (tlen rtree) sizer)
         (=> (= var_u2885 (+ _lbv0 1)) (= (tlen v) var_u2885))))))
(assert (not (forall ((var_u2886 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), _lbv0 ), ltree ), _lbv7 ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), _lbv0 ), ltree ), _lbv6 ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), apply int_gen  (, dummy ) ), ltree ), apply subs  (, root ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), _lbv0 ), ltree ), _lbv6 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv6 :: {v:Ty_int | (v) ==((root) -- (1))} | (_lbv6) ==((root) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((_lbv0) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T3765)
(declare-fun |0| () Int)
(declare-fun tlen (T3765) Int)
(declare-fun v () T3765)
(declare-fun _lbv0 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T3765)
(declare-fun root () Int)
(declare-fun _lbv6 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T3765)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T3765)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2892 Int)
         (var_u2891 Int)
         (var_u2890 Int)
         (var_u2889 Int)
         (var_u2888 Int)
         (var_u2887 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2889 (+ _lbv0 1)) (= (tlen v) var_u2889))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= _lbv6 (- root 1))
         (= (tlen rtree) sizer)
         (=> (= var_u2892 (+ _lbv0 1)) (= (tlen v) var_u2892))))))
(assert (not (forall ((var_u2893 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), _lbv0 ), ltree ), _lbv6 ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), _lbv0 ), ltree ), _lbv10 ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), apply int_gen  (, dummy ) ), ltree ), apply subs  (, sizel ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), _lbv0 ), ltree ), _lbv10 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv10 :: {v:Ty_int | (v) ==((sizel) -- (1))} | (_lbv10) ==((sizel) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((_lbv0) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T3771)
(declare-fun |0| () Int)
(declare-fun tlen (T3771) Int)
(declare-fun v () T3771)
(declare-fun _lbv0 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T3771)
(declare-fun sizel () Int)
(declare-fun _lbv10 () Int)
(declare-fun ltree () T3771)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T3771)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2899 Int)
         (var_u2898 Int)
         (var_u2897 Int)
         (var_u2896 Int)
         (var_u2895 Int)
         (var_u2894 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2896 (+ _lbv0 1)) (= (tlen v) var_u2896))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= _lbv10 (- sizel 1))
         (= (tlen rtree) sizer)
         (=> (= var_u2899 (+ _lbv0 1)) (= (tlen v) var_u2899))))))
(assert (not (forall ((var_u2900 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), _lbv0 ), ltree ), _lbv10 ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), _lbv0 ), ltree ), _lbv9 ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), apply int_gen  (, dummy ) ), ltree ), apply subs  (, sizer ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), _lbv0 ), ltree ), _lbv9 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument _lbv0 :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  _lbv0 > 0
 	,   _lbv0 = 0>d 
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv9 :: {v:Ty_int | (v) ==((sizer) -- (1))} | (_lbv9) ==((sizer) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((_lbv0) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T3777)
(declare-fun |0| () Int)
(declare-fun tlen (T3777) Int)
(declare-fun v () T3777)
(declare-fun _lbv0 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T3777)
(declare-fun _lbv9 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T3777)
(declare-fun s0 () Int)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T3777)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2906 Int)
         (var_u2905 Int)
         (var_u2904 Int)
         (var_u2903 Int)
         (var_u2902 Int)
         (var_u2901 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2903 (+ _lbv0 1)) (= (tlen v) var_u2903))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= (tlen ltree) sizel)
         (= _lbv9 (- sizer 1))
         (= (tlen rtree) sizer)
         (=> (= var_u2906 (+ _lbv0 1)) (= (tlen v) var_u2906))))))
(assert (not (forall ((var_u2907 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), _lbv0 ), ltree ), _lbv9 ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), s0 ), ltree ), sizer ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), s0 ), ltree ), sizer ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), s0 ), ltree ), sizer ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument s0 :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument sizer :: {v:Ty_int | true} | true
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((s0) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                    
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T3783)
(declare-fun |0| () Int)
(declare-fun tlen (T3783) Int)
(declare-fun v () T3783)
(declare-fun s0 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T3783)
(declare-fun sizel () Int)
(declare-fun ltree () T3783)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T3783)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2913 Int)
         (var_u2912 Int)
         (var_u2911 Int)
         (var_u2910 Int)
         (var_u2909 Int)
         (var_u2908 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2910 (+ s0 1)) (= (tlen v) var_u2910))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2913 (+ s0 1)) (= (tlen v) var_u2913))))))
(assert (not (forall ((var_u2914 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), s0 ), ltree ), sizer ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), s0 ), ltree ), sizel ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), s0 ), ltree ), sizel ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), s0 ), ltree ), sizel ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument s0 :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument sizel :: {v:Ty_int | true} | true
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((s0) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                    
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T3789)
(declare-fun |0| () Int)
(declare-fun tlen (T3789) Int)
(declare-fun v () T3789)
(declare-fun s0 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T3789)
(declare-fun sizel () Int)
(declare-fun ltree () T3789)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T3789)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2920 Int)
         (var_u2919 Int)
         (var_u2918 Int)
         (var_u2917 Int)
         (var_u2916 Int)
         (var_u2915 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2917 (+ s0 1)) (= (tlen v) var_u2917))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2920 (+ s0 1)) (= (tlen v) var_u2920))))))
(assert (not (forall ((var_u2921 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), s0 ), ltree ), sizel ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), s0 ), ltree ), root ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), s0 ), ltree ), root ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), s0 ), ltree ), root ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument s0 :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument root :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  root > 0
 	,   root = 0>d 
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((s0) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                               
# of Final Z3 expressions 18
 Final solver 
 (declare-sort T3795)
(declare-fun |0| () Int)
(declare-fun tlen (T3795) Int)
(declare-fun v () T3795)
(declare-fun s0 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T3795)
(declare-fun root () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T3795)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T3795)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2927 Int)
         (var_u2926 Int)
         (var_u2925 Int)
         (var_u2924 Int)
         (var_u2923 Int)
         (var_u2922 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2924 (+ s0 1)) (= (tlen v) var_u2924))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (= (tlen ltree) sizel)
         (or (> root |0|) (= root |0|))
         (= (tlen rtree) sizer)
         (=> (= var_u2927 (+ s0 1)) (= (tlen v) var_u2927))))))
(assert (not (forall ((var_u2928 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), s0 ), ltree ), root ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), s0 ), ltree ), s01 ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), s0 ), ltree ), s01 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), s0 ), ltree ), s01 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument s0 :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument s01 :: {v:Ty_int | 
 	 Conj <c true
 	 , s0 > v >c } | 
 	 Conj <c true
 	 , s0 > s01 >c 
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((s0) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                         
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T3801)
(declare-fun |0| () Int)
(declare-fun tlen (T3801) Int)
(declare-fun v () T3801)
(declare-fun s0 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T3801)
(declare-fun s01 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T3801)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T3801)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2934 Int)
         (var_u2933 Int)
         (var_u2932 Int)
         (var_u2931 Int)
         (var_u2930 Int)
         (var_u2929 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2931 (+ s0 1)) (= (tlen v) var_u2931))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (= (tlen ltree) sizel)
         (> s0 s01)
         (= (tlen rtree) sizer)
         (=> (= var_u2934 (+ s0 1)) (= (tlen v) var_u2934))))))
(assert (not (forall ((var_u2935 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), s0 ), ltree ), s01 ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), s0 ), ltree ), n ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), s0 ), ltree ), n ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), s0 ), ltree ), n ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument s0 :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument n :: {v:Ty_int | true} | true
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((s0) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                    
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T3807)
(declare-fun |0| () Int)
(declare-fun tlen (T3807) Int)
(declare-fun v () T3807)
(declare-fun s0 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T3807)
(declare-fun sizel () Int)
(declare-fun ltree () T3807)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T3807)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2941 Int)
         (var_u2940 Int)
         (var_u2939 Int)
         (var_u2938 Int)
         (var_u2937 Int)
         (var_u2936 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2938 (+ s0 1)) (= (tlen v) var_u2938))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2941 (+ s0 1)) (= (tlen v) var_u2941))))))
(assert (not (forall ((var_u2942 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), s0 ), ltree ), n ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), s0 ), ltree ), _lbv10 ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), s0 ), ltree ), apply subs  (, sizel ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), s0 ), ltree ), _lbv10 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument s0 :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv10 :: {v:Ty_int | (v) ==((sizel) -- (1))} | (_lbv10) ==((sizel) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((s0) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                    
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T3813)
(declare-fun |0| () Int)
(declare-fun tlen (T3813) Int)
(declare-fun v () T3813)
(declare-fun s0 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T3813)
(declare-fun sizel () Int)
(declare-fun _lbv10 () Int)
(declare-fun ltree () T3813)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T3813)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2948 Int)
         (var_u2947 Int)
         (var_u2946 Int)
         (var_u2945 Int)
         (var_u2944 Int)
         (var_u2943 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2945 (+ s0 1)) (= (tlen v) var_u2945))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (= (tlen ltree) sizel)
         (= _lbv10 (- sizel 1))
         (= (tlen rtree) sizer)
         (=> (= var_u2948 (+ s0 1)) (= (tlen v) var_u2948))))))
(assert (not (forall ((var_u2949 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), s0 ), ltree ), _lbv10 ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), s0 ), ltree ), _lbv9 ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), s0 ), ltree ), apply subs  (, sizer ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), s0 ), ltree ), _lbv9 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument s0 :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv9 :: {v:Ty_int | (v) ==((sizer) -- (1))} | (_lbv9) ==((sizer) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((s0) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                    
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T3819)
(declare-fun |0| () Int)
(declare-fun tlen (T3819) Int)
(declare-fun v () T3819)
(declare-fun s0 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T3819)
(declare-fun _lbv9 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T3819)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T3819)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2955 Int)
         (var_u2954 Int)
         (var_u2953 Int)
         (var_u2952 Int)
         (var_u2951 Int)
         (var_u2950 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2952 (+ s0 1)) (= (tlen v) var_u2952))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (= (tlen ltree) sizel)
         (= _lbv9 (- sizer 1))
         (= (tlen rtree) sizer)
         (=> (= var_u2955 (+ s0 1)) (= (tlen v) var_u2955))))))
(assert (not (forall ((var_u2956 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), s0 ), ltree ), _lbv9 ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), s0 ), ltree ), _lbv8 ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), s0 ), ltree ), apply subs  (, s ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), s0 ), ltree ), _lbv8 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument s0 :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv8 :: {v:Ty_int | (v) ==((s) -- (1))} | (_lbv8) ==((s) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((s0) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                    
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T3825)
(declare-fun |0| () Int)
(declare-fun tlen (T3825) Int)
(declare-fun v () T3825)
(declare-fun s0 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T3825)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T3825)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T3825)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2962 Int)
         (var_u2961 Int)
         (var_u2960 Int)
         (var_u2959 Int)
         (var_u2958 Int)
         (var_u2957 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2959 (+ s0 1)) (= (tlen v) var_u2959))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (= (tlen ltree) sizel)
         (= _lbv8 (- s 1))
         (= (tlen rtree) sizer)
         (=> (= var_u2962 (+ s0 1)) (= (tlen v) var_u2962))))))
(assert (not (forall ((var_u2963 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), s0 ), ltree ), _lbv8 ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), s0 ), ltree ), _lbv7 ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), s0 ), ltree ), apply subs  (, s01 ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), s0 ), ltree ), _lbv7 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument s0 :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv7 :: {v:Ty_int | (v) ==((s01) -- (1))} | (_lbv7) ==((s01) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((s0) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                    
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T3831)
(declare-fun |0| () Int)
(declare-fun tlen (T3831) Int)
(declare-fun v () T3831)
(declare-fun s0 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T3831)
(declare-fun s01 () Int)
(declare-fun _lbv7 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T3831)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T3831)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2969 Int)
         (var_u2968 Int)
         (var_u2967 Int)
         (var_u2966 Int)
         (var_u2965 Int)
         (var_u2964 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2966 (+ s0 1)) (= (tlen v) var_u2966))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (= (tlen ltree) sizel)
         (= _lbv7 (- s01 1))
         (= (tlen rtree) sizer)
         (=> (= var_u2969 (+ s0 1)) (= (tlen v) var_u2969))))))
(assert (not (forall ((var_u2970 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), s0 ), ltree ), _lbv7 ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), s0 ), ltree ), _lbv6 ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), s0 ), ltree ), apply subs  (, root ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), s0 ), ltree ), _lbv6 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument s0 :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv6 :: {v:Ty_int | (v) ==((root) -- (1))} | (_lbv6) ==((root) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((s0) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                    
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T3837)
(declare-fun |0| () Int)
(declare-fun tlen (T3837) Int)
(declare-fun v () T3837)
(declare-fun s0 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T3837)
(declare-fun root () Int)
(declare-fun _lbv6 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T3837)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T3837)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2976 Int)
         (var_u2975 Int)
         (var_u2974 Int)
         (var_u2973 Int)
         (var_u2972 Int)
         (var_u2971 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2973 (+ s0 1)) (= (tlen v) var_u2973))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (= (tlen ltree) sizel)
         (= _lbv6 (- root 1))
         (= (tlen rtree) sizer)
         (=> (= var_u2976 (+ s0 1)) (= (tlen v) var_u2976))))))
(assert (not (forall ((var_u2977 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), s0 ), ltree ), _lbv6 ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), s0 ), ltree ), s ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), s0 ), ltree ), s ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), s0 ), ltree ), s ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument s0 :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument s :: {var_v0:Ty_int | true} | true
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((s0) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                    
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T3843)
(declare-fun |0| () Int)
(declare-fun tlen (T3843) Int)
(declare-fun v () T3843)
(declare-fun s0 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T3843)
(declare-fun sizel () Int)
(declare-fun ltree () T3843)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T3843)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2983 Int)
         (var_u2982 Int)
         (var_u2981 Int)
         (var_u2980 Int)
         (var_u2979 Int)
         (var_u2978 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2980 (+ s0 1)) (= (tlen v) var_u2980))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2983 (+ s0 1)) (= (tlen v) var_u2983))))))
(assert (not (forall ((var_u2984 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), s0 ), ltree ), s ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), s0 ), ltree ), _lbv2 ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), s0 ), ltree ), apply subs  (, apply int_gen  (, dummy ) ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), s0 ), ltree ), _lbv2 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument s0 :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv2 :: {v:Ty_int | (v) ==((_lbv0) -- (1))} | (_lbv2) ==((_lbv0) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((s0) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                    
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T3849)
(declare-fun |0| () Int)
(declare-fun tlen (T3849) Int)
(declare-fun v () T3849)
(declare-fun s0 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T3849)
(declare-fun _lbv0 () Int)
(declare-fun _lbv2 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T3849)
(declare-fun _lbv1 () Int)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun leaf () T3849)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2990 Int)
         (var_u2989 Int)
         (var_u2988 Int)
         (var_u2987 Int)
         (var_u2986 Int)
         (var_u2985 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2987 (+ s0 1)) (= (tlen v) var_u2987))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (= (tlen ltree) sizel)
         (= _lbv2 (- _lbv0 1))
         (= (tlen rtree) sizer)
         (=> (= var_u2990 (+ s0 1)) (= (tlen v) var_u2990))))))
(assert (not (forall ((var_u2991 Int)) (= (tlen v) sizel))))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply node  (, _lbv1 ), s0 ), ltree ), _lbv2 ), rtree )
 Finding Already seen tree for apply node  (, _lbv1 ), s0 ), ltree ), _lbv1 ), rtree )
 Typechecking apply node  (, apply subs  (, s0 ) ), s0 ), ltree ), apply subs  (, s0 ) ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Typechecking the Term apply node  (, _lbv1 ), s0 ), ltree ), _lbv1 ), rtree )
 Against {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }}
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument s0 :: {v:Ty_int | true} | true
 Argument ltree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizel) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(ltree) ==(sizel) }
 Argument _lbv1 :: {v:Ty_int | (v) ==((s0) -- (1))} | (_lbv1) ==((s0) -- (1))
 Argument rtree :: {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(v) ==(sizer) }} | Forall 
 	 
 Key =u Value = Ty_int{ (tlen)(rtree) ==(sizer) }
 AppType Type {v:Ty_alphatree | Forall 
 	 
 Key =u Value = Ty_int{ 
 	 Impl < (u) ==((s0) + (1))
 	 (tlen)(v) ==(u) > }}                                                                                                                                                    
# of Final Z3 expressions 16
 Final solver 
 (declare-sort T3855)
(declare-fun |0| () Int)
(declare-fun tlen (T3855) Int)
(declare-fun v () T3855)
(declare-fun s0 () Int)
(declare-fun sizer () Int)
(declare-fun rtree () T3855)
(declare-fun _lbv1 () Int)
(declare-fun sizel () Int)
(declare-fun ltree () T3855)
(declare-fun var_v3 () Bool)
(declare-fun root () Int)
(declare-fun s01 () Int)
(declare-fun _lbv10 () Int)
(declare-fun _lbv9 () Int)
(declare-fun s () Int)
(declare-fun _lbv8 () Int)
(declare-fun _lbv7 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv5 () Bool)
(declare-fun _lbv2 () Int)
(declare-fun _lbv4 () Bool)
(declare-fun _lbv3 () Bool)
(declare-fun _lbv0 () Int)
(declare-fun leaf () T3855)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u2997 Int)
         (var_u2996 Int)
         (var_u2995 Int)
         (var_u2994 Int)
         (var_u2993 Int)
         (var_u2992 Int))
  (let ((a!1 (= (= _lbv3 true) (and (= s0 |0|) (= (= _lbv3 false) (> s0 |0|)))))
        (a!2 (= (= _lbv4 true)
                (and (= _lbv2 |0|) (= (= _lbv4 false) (> _lbv2 |0|)))))
        (a!3 (= (= _lbv5 true)
                (and (= _lbv1 |0|) (= (= _lbv5 false) (> _lbv1 |0|)))))
        (a!4 (= (= var_v3 true)
                (and (= s0 |0|) (= (= var_v3 false) (> s0 |0|))))))
    (and (= (tlen leaf) 0)
         (or (> _lbv0 |0|) (= _lbv0 |0|))
         (= _lbv1 (- s0 1))
         (= _lbv2 (- _lbv0 1))
         a!1
         a!2
         a!3
         a!4
         (= _lbv6 (- root 1))
         (= _lbv7 (- s01 1))
         (= _lbv8 (- s 1))
         (= _lbv9 (- sizer 1))
         (= _lbv10 (- sizel 1))
         (> s0 s01)
         (or (> root |0|) (= root |0|))
         (= (tlen ltree) sizel)
         (= (tlen rtree) sizer)
         (=> (= var_u2994 (+ s0 1)) (= (tlen v) var_u2994))
         (= var_v3 false)
         a!4
         (= _lbv1 (- s0 1))
         (= (tlen ltree) sizel)
         (= _lbv1 (- s0 1))
         (= (tlen rtree) sizer)
         (=> (= var_u2997 (+ s0 1)) (= (tlen v) var_u2997))))))
(assert (not (fo