
  EXPLORED Args.parser output 
 EXPLORED learningOn  true
 EXPLORED bidirectionality  true
 EXPLORED effect-filter  false
 EXPLORED specfile :: tests_specsynth/sizedlist_quant_exact.spec
 EXPLORED goal Number :: 0
 EXPLORED Max path length :: 3
 EXPLORED Nested If :: 2stexcwhitespace var: slen
whitespace colon
whitespace var: list
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: slist
whitespace colon
whitespace var: list
whitespace colon
whitespace var: bool
semicolon
stexcwhitespace var: shd
whitespace colon
whitespace var: list
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: sorder
whitespace colon
whitespace var: list
whitespace colon
whitespace var: int
whitespace colon
whitespace var: int
whitespace colon
whitespace var: bool
semicolon
stexcwhitespace var: smem
whitespace colon
whitespace var: list
whitespace colon
whitespace var: int
whitespace colon
whitespace var: bool
semicolon
var: subs
whitespace colon
whitespace lparen
var: n
whitespace colon
whitespace lcurly
var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace truercurly
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace var: v
whitespace equalopwhitespace var: n
whitespace ar-minuswhitespace int: 1
rcurly
semicolon
var: gt_eq_int_gen
whitespace colon
whitespace lparen
var: n3
colon
whitespace var: int
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace lbrace
var: v
whitespace lessthanopwhitespace var: n3
rbrace
whitespace disjwhitespace lbrace
var: v
whitespace equalopwhitespace var: n3
rbrace
rcurly
semicolon
whitespace var: Nil
whitespace colon
whitespace lcurly
var: v
whitespace colon
whitespace var: list
whitespace pipe
whitespace lambdalparen
var: u
whitespace colon
whitespace var: int
rparen
dotwhitespace var: slen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace int: 0
rcurly
semicolon
var: sizecheck
whitespace colon
whitespace lparen
var: s
whitespace colon
whitespace var: int
rparen
whitespace arrow
whitespace whitespace lcurly
var: v
whitespace colon
whitespace var: bool
whitespace pipe
whitespace lbrace
var: v
equaloptruerbrace
whitespace iffwhitespace lbrace
var: s
equalopint: 0
rbrace
whitespace conjwhitespace whitespace lbrace
var: v
equalopfalserbrace
whitespace iffwhitespace lbrace
var: s
lessthanopint: 0
rbrace
rcurly
semicolon
var: Cons
whitespace colon
whitespace lparen
var: x
whitespace colon
whitespace lcurly
var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace truercurly
rparen
whitespace arrow
whitespace whitespace lparen
var: xs
whitespace colon
whitespace lcurly
var: v
whitespace colon
whitespace var: list
whitespace pipe
whitespace truercurly
rparen
whitespace arrow
whitespace whitespace lcurly
var: v
whitespace colon
whitespace var: list
whitespace pipe
whitespace whitespace lambdalparen
var: u
whitespace colon
whitespace var: int
rparen
dotwhitespace whitespace lparen
lparen
var: u
whitespace equalopwhitespace var: slen
whitespace lparen
var: xs
rparen
whitespace pluswhitespace int: 1
rparen
whitespace implieswhitespace var: slen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: u
rparen
whitespace rcurly
semicolon
whitespace var: goal
whitespace colon
whitespace lparen
var: size
whitespace colon
whitespace lcurly
whitespace var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace truercurly
rparen
whitespace arrow
whitespace whitespace lcurly
var: v
whitespace colon
whitespace var: list
whitespace pipe
whitespace lambdalparen
var: u
whitespace colon
whitespace var: int
rparen
dotwhitespace whitespace lparen
var: slen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: u
whitespace implieswhitespace lparen
whitespace lparen
lbrace
var: u
whitespace lessthanopwhitespace int: 0
rbrace
whitespace disjwhitespace lbrace
var: u
whitespace equalopwhitespace int: 0
rbrace
rparen
whitespace conjwhitespace whitespace lbrace
var: u
whitespace equalopwhitespace var: size
rbrace
rparen
rparen
rcurly
semicolon
RelSpec {  SRs ;  PRs ;  TSs  
 Assume false
 name subs : 
 params :
 Type  Arrow ( ( n : {v:int | true} ) -> {v:int | (v) ==((n) -- (1))} 
 Assume false
 name gt_eq_int_gen : 
 params :
 Type  Arrow ( ( n3 : {var_v0:int | true} ) -> {v:int | 
 Disj <d  v > n3
 	,   v = n3>d } 
 Assume false
 name Nil : 
 params :
 Type {v:int list | Forall 
 	 
 Key =u Value = int{ (slen)(v) ==(0) }} 
 Assume false
 name sizecheck : 
 params :
 Type  Arrow ( ( s : {var_v1:int | true} ) -> {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c s = 0
 	 , DoubleImpl 
 v = false
  s > 0 >c } 
 Assume false
 name Cons : 
 params :
 Type  Arrow ( ( x : {v:int | true} ) ->  Arrow ( ( xs : {v:int list | true} ) -> {v:int list | Forall 
 	 
 Key =u Value = int{ 
 	 Impl < (u) ==((slen)(xs) + (1))
 	 (slen)(v) ==(u) > }} 
 Assume false
 name goal : 
 params :
 Type  Arrow ( ( size : {v:int | true} ) -> {v:int list | Forall 
 	 
 Key =u Value = int{ 
 	 Impl < (slen)(v) ==(u)
 	 
 	 Conj <c 
 Disj <d  u > 0
 	,   u = 0>d 
 	 , u = size >c  > }};  Formulas  }
 INITIAL GAMMA 
 
 goal :  Arrow ( ( size : {v:int | true} ) -> {v:int list | Forall 
 	 
 Key =u Value = int{ 
 	 Impl < (slen)(v) ==(u)
 	 
 	 Conj <c 
 Disj <d  u > 0
 	,   u = 0>d 
 	 , u = size >c  > }}
 Cons :  Arrow ( ( x : {v:int | true} ) ->  Arrow ( ( xs : {v:int list | true} ) -> {v:int list | Forall 
 	 
 Key =u Value = int{ 
 	 Impl < (u) ==((slen)(xs) + (1))
 	 (slen)(v) ==(u) > }}
 sizecheck :  Arrow ( ( s : {var_v1:int | true} ) -> {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c s = 0
 	 , DoubleImpl 
 v = false
  s > 0 >c }
 Nil : {v:int list | Forall 
 	 
 Key =u Value = int{ (slen)(v) ==(0) }}
 gt_eq_int_gen :  Arrow ( ( n3 : {var_v0:int | true} ) -> {v:int | 
 Disj <d  v > n3
 	,   v = n3>d }
 subs :  Arrow ( ( n : {v:int | true} ) -> {v:int | (v) ==((n) -- (1))}
 INITIAL SIGMA 
 
 TypeNames 
 
 Qualifiers 
 
 Qual slen :  :-> int list :-> int
 Qual slist :  :-> int list :-> Ty_bool
 Qual shd :  :-> int list :-> int
 Qual sorder :  :-> int list :-> int :-> int :-> Ty_bool
 Qual smem :  :-> int list :-> int :-> Ty_bool
 Show ***********Calling S-FUNC synthesize***************
 Show Uncurried , size:{v:int | true} -> {v:int list | Forall 
 	 
 Key =u Value = int{ 
 	 Impl < (slen)(v) ==(u)
 	 
 	 Conj <c 
 Disj <d  u > 0
 	,   u = 0>d 
 	 , u = size >c  > }}
 Decreasing Measure size
 Decreasing Type {v:int | true}
 Calculated Decreasing Predicate size > v
 Calculated Decreased Goal Type  Arrow ( ( size1 : {v:int | 
 	 Conj <c true
 	 , size > v >c } ) -> {v:int list | Forall 
 	 
 Key =u Value = int{ 
 	 Impl < (slen)(v) ==(u)
 	 
 	 Conj <c 
 Disj <d  u > 0
 	,   u = 0>d 
 	 , u = size1 >c  > }}
 Show Trying :: Top-level Match
 Show :: Synthesize Match {v:int list | Forall 
 	 
 Key =u Value = int{ 
 	 Impl < (slen)(v) ==(u)
 	 
 	 Conj <c 
 Disj <d  u > 0
 	,   u = 0>d 
 	 , u = size >c  > }}
 Show :: List int
 Show :: Non List Case
 Match-case failed :: Try Top-level If-then-else 
 **********************************************
 iSynthesize If-THEN-ELSE {v:int list | Forall 
 	 
 Key =u Value = int{ 
 	 Impl < (slen)(v) ==(u)
 	 
 	 Conj <c 
 Disj <d  u > 0
 	,   u = 0>d 
 	 , u = size >c  > }}
 **********************************************
  *********************Synthesizing the Guard*******************
 iSynthesize Boolean Guard {var_v2:Ty_bool | true}
  *********************Synthesizing the Guard*******************
 esynthesizeScalar for {var_v2:Ty_bool | true}
 >>>>>>>>>>>>>>>>>> No Scalar found in Environment, Trying Nested Ifs <<<<<<<<<<<<<<<<<< 
 **********************************************
 iSynthesize If-THEN-ELSE {var_v2:Ty_bool | true}
 **********************************************
  *********************Synthesizing the Guard*******************
 iSynthesize Boolean Guard {var_v3:Ty_bool | true}
  *********************Synthesizing the Guard*******************
 esynthesizeScalar for {var_v3:Ty_bool | true}
 >>>>>>>>>>>>>>>>>> No Scalar found in Environment, Trying Nested Ifs <<<<<<<<<<<<<<<<<< 
 **********************************************
 iSynthesize If-THEN-ELSE {var_v3:Ty_bool | true}
 **********************************************
 >>>>>>>>>>>>>>>>>> No If-term found at allowed defth found in Environment, Trying esynthesizePureApp <<<<<<<<<<<<<<<<<< 
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 >>>>>>>>>>>>>>>>>> No If-term found at allowed defth found in Environment, Trying esynthesizePureApp <<<<<<<<<<<<<<<<<< 
  Entering Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  , 
 sizecheck
 ############################################################
  Synthesizing the Function application Pure Component sizecheck
 ############################################################
  *************** Trying Arrow Component ************sizecheck :  Arrow ( ( s : {var_v1:int | true} ) -> {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c s = 0
 	 , DoubleImpl 
 v = false
  s > 0 >c }
  *************** Synthesizing Args ei : ti for ************sizecheck
 ##################################################################################
  Synthesizing the 1th argument for Function sizecheck
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v1:int | true}
 
 Enumerating a Scalar Term size
 
 Type of the Scalar Term {v:int | true}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>> 1th Args option for sizecheck : size
  DEPTH vs MAX  2 vs 3
 ##################################################################################
  *************** Successfully Synthesized Args ei Forall i 
 1 th Argument Options for sizecheck
 EI size
 # of Possible Argument Options for sizecheck 1
 HERE
 # of Possible Argument Options for sizecheck 1
 Possible Arg Options 
 EI size
 Apply Single Argument Case : f (ei) Case sizecheck
  Case : f (ei) Case sizecheck size
 Finding Already seen tree for apply sizecheck  (, size )
 Typechecking apply sizecheck  (, size )
 Against {var_v2:Ty_bool | true}
 Typechecking the Term apply sizecheck  (, size )
 Against {var_v2:Ty_bool | true}
 Argument size :: {v:int | true} | true
 AppType Type {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c size = 0
 	 , DoubleImpl 
 v = false
  size > 0 >c }
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
  Show *************** TypeChecking Succsessful {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c size = 0
 	 , DoubleImpl 
 v = false
  size > 0 >c }
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 let _lbv0 = apply sizecheck  (, size )
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 Show :: Synthesizing The IF-THEN-ELSE for Next Boolean Guard apply sizecheck  (, size )
  *********************Synthesizing the True branch*******************
 Show :: True Predicate 
 	 Conj <c var_v4 = true
 	 , DoubleImpl 
 var_v4 = true
  
 	 Conj <c size = 0
 	 , DoubleImpl 
 var_v4 = false
  size > 0 >c  >c 
 Show ***********Calling Scalar synthesize***************
 esynthesizeScalar for {v:int list | Forall 
 	 
 Key =u Value = int{ 
 	 Impl < (slen)(v) ==(u)
 	 
 	 Conj <c 
 Disj <d  u > 0
 	,   u = 0>d 
 	 , u = size >c  > }}
 
 Enumerating a Scalar Term Nil
 
 Type of the Scalar Term {v:int list | Forall 
 	 
 Key =u Value = int{ (slen)(v) ==(0) }}                                                                                            
# of Final Z3 expressions 10
 Final solver 
 (declare-sort T13 0)
(declare-fun |0| () Int)
(declare-fun slen (T13) Int)
(declare-fun Nil () T13)
(declare-fun size () Int)
(declare-fun var_v4 () Bool)
(declare-fun _lbv0 () Bool)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u6 Int) (var_u5 Int))
  (let ((a!1 (= (= _lbv0 true)
                (and (= size |0|) (= (= _lbv0 false) (> size |0|)))))
        (a!2 (= (= var_v4 true)
                (and (= size |0|) (= (= var_v4 false) (> size |0|))))))
    (and a!1 a!2 (= (slen Nil) 0) (= var_v4 true) a!2 (= (slen Nil) 0)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (let ((a!1 (forall ((var_u7 Int))
             (=> (= (slen Nil) var_u7)
                 (and (or (> var_u7 |0|) (= var_u7 |0|)) (= var_u7 size))))))
  (not a!1)))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Show :: Found a Few Macthing Scalars 
 *********************************************
 True Branch :: Successfully Synthesisized
 *********************************************
 if apply sizecheck  (, size )
 	 then 
 ***********
 Nil
 *********************************************
 ************ Synthesize False Branch**************
 *********************************************
 False Branch :: Trying False Branch
 Show :: Synthesizing the false branch
 Show :: False Predicate 
 	 Conj <c var_v4 = false
 	 , DoubleImpl 
 var_v4 = true
  
 	 Conj <c size = 0
 	 , DoubleImpl 
 var_v4 = false
  size > 0 >c  >c 
 Show ***********Calling Scalar synthesize***************
 esynthesizeScalar for {v:int list | Forall 
 	 
 Key =u Value = int{ 
 	 Impl < (slen)(v) ==(u)
 	 
 	 Conj <c 
 Disj <d  u > 0
 	,   u = 0>d 
 	 , u = size >c  > }}
 
 Enumerating a Scalar Term Nil
 
 Type of the Scalar Term {v:int list | Forall 
 	 
 Key =u Value = int{ (slen)(v) ==(0) }}                                                                                            
# of Final Z3 expressions 10
 Final solver 
 (declare-sort T17 0)
(declare-fun |0| () Int)
(declare-fun slen (T17) Int)
(declare-fun Nil () T17)
(declare-fun size () Int)
(declare-fun var_v4 () Bool)
(declare-fun _lbv0 () Bool)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u9 Int) (var_u8 Int))
  (let ((a!1 (= (= _lbv0 true)
                (and (= size |0|) (= (= _lbv0 false) (> size |0|)))))
        (a!2 (= (= var_v4 true)
                (and (= size |0|) (= (= var_v4 false) (> size |0|))))))
    (and a!1 a!2 (= (slen Nil) 0) (= var_v4 false) a!2 (= (slen Nil) 0)))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (let ((a!1 (forall ((var_u10 Int))
             (=> (= (slen Nil) var_u10)
                 (and (or (> var_u10 |0|) (= var_u10 |0|)) (= var_u10 size))))))
  (not a!1)))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 
 FaileD the subtype check T_vi <: T_goal
 >>>>>>>>>>>>>>>>>> No Scalar found in Environment, Trying Nested Ifs <<<<<<<<<<<<<<<<<< 
 **********************************************
 iSynthesize If-THEN-ELSE {v:int list | Forall 
 	 
 Key =u Value = int{ 
 	 Impl < (slen)(v) ==(u)
 	 
 	 Conj <c 
 Disj <d  u > 0
 	,   u = 0>d 
 	 , u = size >c  > }}
 **********************************************
 >>>>>>>>>>>>>>>>>> No If-term found at allowed defth found in Environment, Trying esynthesizePureApp <<<<<<<<<<<<<<<<<< 
  Entering Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  , 
 goal, 
 Cons
 ############################################################
  Synthesizing the Function application Pure Component goal
 ############################################################
  *************** Trying Arrow Component ************goal :  Arrow ( ( size1 : {v:int | 
 	 Conj <c true
 	 , size > v >c } ) -> {v:int list | Forall 
 	 
 Key =u Value = int{ 
 	 Impl < (slen)(v) ==(u)
 	 
 	 Conj <c 
 Disj <d  u > 0
 	,   u = 0>d 
 	 , u = size1 >c  > }}
  *************** Synthesizing Args ei : ti for ************goal
 ##################################################################################
  Synthesizing the 1th argument for Function goal
  Trying Arguments in Scalars 
 esynthesizeScalar for {v:int | 
 	 Conj <c true
 	 , size > v >c }
 
 Enumerating a Scalar Term size
 
 Type of the Scalar Term {v:int | true}                                                                                
# of Final Z3 expressions 8
 Final solver 
 (declare-sort T20 0)
(declare-fun |0| () Int)
(declare-fun size () Int)
(declare-fun var_v4 () Bool)
(declare-fun _lbv0 () Bool)
(declare-fun slen (T20) Int)
(declare-fun Nil () T20)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u11 Int))
  (let ((a!1 (= (= _lbv0 true)
                (and (= size |0|) (= (= _lbv0 false) (> size |0|)))))
        (a!2 (= (= var_v4 true)
                (and (= size |0|) (= (= var_v4 false) (> size |0|))))))
    (and (= (slen Nil) 0) a!1 a!2 (= var_v4 false) a!2))))
(assert (not (> size size)))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term s
 
 Type of the Scalar Term {var_v1:int | true}                                                                                
# of Final Z3 expressions 8
 Final solver 
 (declare-sort T24 0)
(declare-fun |0| () Int)
(declare-fun size () Int)
(declare-fun var_v4 () Bool)
(declare-fun _lbv0 () Bool)
(declare-fun slen (T24) Int)
(declare-fun Nil () T24)
(declare-fun s () Int)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u12 Int))
  (let ((a!1 (= (= _lbv0 true)
                (and (= size |0|) (= (= _lbv0 false) (> size |0|)))))
        (a!2 (= (= var_v4 true)
                (and (= size |0|) (= (= var_v4 false) (> size |0|))))))
    (and (= (slen Nil) 0) a!1 a!2 (= var_v4 false) a!2))))
(assert (not (> size s)))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 
 FaileD the subtype check T_vi <: T_goal
 >>>>>>>>>>>>>>>>>> No Scalar found in Environment, Trying Nested Ifs <<<<<<<<<<<<<<<<<< 
 **********************************************
 iSynthesize If-THEN-ELSE {v:int | 
 	 Conj <c true
 	 , size > v >c }
 **********************************************
 >>>>>>>>>>>>>>>>>> No If-term found at allowed defth found in Environment, Trying esynthesizePureApp <<<<<<<<<<<<<<<<<< 
  Entering Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  , 
 gt_eq_int_gen, 
 subs
 ############################################################
  Synthesizing the Function application Pure Component gt_eq_int_gen
 ############################################################
  *************** Trying Arrow Component ************gt_eq_int_gen :  Arrow ( ( n3 : {var_v0:int | true} ) -> {v:int | 
 Disj <d  v > n3
 	,   v = n3>d }
  *************** Synthesizing Args ei : ti for ************gt_eq_int_gen
 ##################################################################################
  Synthesizing the 1th argument for Function gt_eq_int_gen
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v0:int | true}
 
 Enumerating a Scalar Term size
 
 Type of the Scalar Term {v:int | true}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term s
 
 Type of the Scalar Term {var_v1:int | true}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>> 1th Args option for gt_eq_int_gen : s
 >>>>>>>>>>>>>>>>>>> 1th Args option for gt_eq_int_gen : size
  DEPTH vs MAX  2 vs 3
 ##################################################################################
  *************** Successfully Synthesized Args ei Forall i 
 1 th Argument Options for gt_eq_int_gen
 EI s
 EI size
 # of Possible Argument Options for gt_eq_int_gen 2
 HERE
 # of Possible Argument Options for gt_eq_int_gen 2
 Possible Arg Options 
 EI s
 Possible Arg Options 
 EI size
 Apply Single Argument Case : f (ei) Case gt_eq_int_gen
  Case : f (ei) Case gt_eq_int_gen s
 Finding Already seen tree for apply gt_eq_int_gen  (, s )
 Typechecking apply gt_eq_int_gen  (, s )
 Against {v:int | 
 	 Conj <c true
 	 , size > v >c }
 Typechecking the Term apply gt_eq_int_gen  (, s )
 Against {v:int | 
 	 Conj <c true
 	 , size > v >c }
 Argument s :: {var_v1:int | true} | true
 AppType Type {v:int | 
 Disj <d  v > s
 	,   v = s>d }                                                                                                      
# of Final Z3 expressions 8
 Final solver 
 (declare-sort T38 0)
(declare-fun |0| () Int)
(declare-fun s () Int)
(declare-fun v () Int)
(declare-fun size () Int)
(declare-fun var_v4 () Bool)
(declare-fun _lbv0 () Bool)
(declare-fun slen (T38) Int)
(declare-fun Nil () T38)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u13 Int))
  (let ((a!1 (= (= _lbv0 true)
                (and (= size |0|) (= (= _lbv0 false) (> size |0|)))))
        (a!2 (= (= var_v4 true)
                (and (= size |0|) (= (= var_v4 false) (> size |0|))))))
    (and (= (slen Nil) 0)
         a!1
         a!2
         (or (> v s) (= v s))
         (= var_v4 false)
         a!2
         (or (> v s) (= v s))))))
(assert (not (> size v)))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply gt_eq_int_gen  (, s )
  Case : f (ei) Case gt_eq_int_gen size
 Finding Already seen tree for apply gt_eq_int_gen  (, size )
 Typechecking apply gt_eq_int_gen  (, size )
 Against {v:int | 
 	 Conj <c true
 	 , size > v >c }
 Typechecking the Term apply gt_eq_int_gen  (, size )
 Against {v:int | 
 	 Conj <c true
 	 , size > v >c }
 Argument size :: {v:int | true} | true
 AppType Type {v:int | 
 Disj <d  v > size
 	,   v = size>d }                                                                                                      
# of Final Z3 expressions 8
 Final solver 
 (declare-sort T42 0)
(declare-fun |0| () Int)
(declare-fun size () Int)
(declare-fun v () Int)
(declare-fun var_v4 () Bool)
(declare-fun _lbv0 () Bool)
(declare-fun slen (T42) Int)
(declare-fun Nil () T42)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u14 Int))
  (let ((a!1 (= (= _lbv0 true)
                (and (= size |0|) (= (= _lbv0 false) (> size |0|)))))
        (a!2 (= (= var_v4 true)
                (and (= size |0|) (= (= var_v4 false) (> size |0|))))))
    (and (= (slen Nil) 0)
         a!1
         a!2
         (or (> v size) (= v size))
         (= var_v4 false)
         a!2
         (or (> v size) (= v size))))))
(assert (not (> size v)))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply gt_eq_int_gen  (, size )
  ###################################################
  The Choice of Function gt_eq_int_gen Was Ill Fated Try Next Choice of function
 ############################################################
  Synthesizing the Function application Pure Component subs
 ############################################################
  *************** Trying Arrow Component ************subs :  Arrow ( ( n : {v:int | true} ) -> {v:int | (v) ==((n) -- (1))}
  *************** Synthesizing Args ei : ti for ************subs
 ##################################################################################
  Synthesizing the 1th argument for Function subs
  Trying Arguments in Scalars 
 esynthesizeScalar for {v:int | true}
 
 Enumerating a Scalar Term size
 
 Type of the Scalar Term {v:int | true}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term s
 
 Type of the Scalar Term {var_v1:int | true}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term n3
 
 Type of the Scalar Term {var_v0:int | true}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>> 1th Args option for subs : n3
 >>>>>>>>>>>>>>>>>>> 1th Args option for subs : s
 >>>>>>>>>>>>>>>>>>> 1th Args option for subs : size
  DEPTH vs MAX  2 vs 3
 ##################################################################################
  *************** Successfully Synthesized Args ei Forall i 
 1 th Argument Options for subs
 EI n3
 EI s
 EI size
 # of Possible Argument Options for subs 3
 HERE
 # of Possible Argument Options for subs 3
 Possible Arg Options 
 EI n3
 Possible Arg Options 
 EI s
 Possible Arg Options 
 EI size
 Apply Single Argument Case : f (ei) Case subs
  Case : f (ei) Case subs n3
 Finding Already seen tree for apply subs  (, n3 )
 Typechecking apply subs  (, n3 )
 Against {v:int | 
 	 Conj <c true
 	 , size > v >c }
 Typechecking the Term apply subs  (, n3 )
 Against {v:int | 
 	 Conj <c true
 	 , size > v >c }
 Argument n3 :: {var_v0:int | true} | true
 AppType Type {v:int | (v) ==((n3) -- (1))}                                                                                
# of Final Z3 expressions 8
 Final solver 
 (declare-sort T61 0)
(declare-fun |0| () Int)
(declare-fun n3 () Int)
(declare-fun v () Int)
(declare-fun size () Int)
(declare-fun var_v4 () Bool)
(declare-fun _lbv0 () Bool)
(declare-fun slen (T61) Int)
(declare-fun Nil () T61)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u15 Int))
  (let ((a!1 (= (= _lbv0 true)
                (and (= size |0|) (= (= _lbv0 false) (> size |0|)))))
        (a!2 (= (= var_v4 true)
                (and (= size |0|) (= (= var_v4 false) (> size |0|))))))
    (and (= (slen Nil) 0)
         a!1
         a!2
         (= v (- n3 1))
         (= var_v4 false)
         a!2
         (= v (- n3 1))))))
(assert (not (> size v)))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply subs  (, n3 )
  Case : f (ei) Case subs s
 Finding Already seen tree for apply subs  (, s )
 Typechecking apply subs  (, s )
 Against {v:int | 
 	 Conj <c true
 	 , size > v >c }
 Typechecking the Term apply subs  (, s )
 Against {v:int | 
 	 Conj <c true
 	 , size > v >c }
 Argument s :: {var_v1:int | true} | true
 AppType Type {v:int | (v) ==((s) -- (1))}                                                                                
# of Final Z3 expressions 8
 Final solver 
 (declare-sort T65 0)
(declare-fun |0| () Int)
(declare-fun s () Int)
(declare-fun v () Int)
(declare-fun size () Int)
(declare-fun var_v4 () Bool)
(declare-fun _lbv0 () Bool)
(declare-fun slen (T65) Int)
(declare-fun Nil () T65)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u16 Int))
  (let ((a!1 (= (= _lbv0 true)
                (and (= size |0|) (= (= _lbv0 false) (> size |0|)))))
        (a!2 (= (= var_v4 true)
                (and (= size |0|) (= (= var_v4 false) (> size |0|))))))
    (and (= (slen Nil) 0)
         a!1
         a!2
         (= v (- s 1))
         (= var_v4 false)
         a!2
         (= v (- s 1))))))
(assert (not (> size v)))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply subs  (, s )
  Case : f (ei) Case subs size
 Finding Already seen tree for apply subs  (, size )
 Typechecking apply subs  (, size )
 Against {v:int | 
 	 Conj <c true
 	 , size > v >c }
 Typechecking the Term apply subs  (, size )
 Against {v:int | 
 	 Conj <c true
 	 , size > v >c }
 Argument size :: {v:int | true} | true
 AppType Type {v:int | (v) ==((size) -- (1))}                                                                                
# of Final Z3 expressions 8
 Final solver 
 (declare-sort T69 0)
(declare-fun |0| () Int)
(declare-fun size () Int)
(declare-fun v () Int)
(declare-fun var_v4 () Bool)
(declare-fun _lbv0 () Bool)
(declare-fun slen (T69) Int)
(declare-fun Nil () T69)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u17 Int))
  (let ((a!1 (= (= _lbv0 true)
                (and (= size |0|) (= (= _lbv0 false) (> size |0|)))))
        (a!2 (= (= var_v4 true)
                (and (= size |0|) (= (= var_v4 false) (> size |0|))))))
    (and (= (slen Nil) 0)
         a!1
         a!2
         (= v (- size 1))
         (= var_v4 false)
         a!2
         (= v (- size 1))))))
(assert (not (> size v)))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
  Show *************** TypeChecking Succsessful {v:int | (v) ==((size) -- (1))}
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 let _lbv1 = apply subs  (, size )
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  , 
 gt_eq_int_gen, 
 subs
 ############################################################
  Synthesizing the Function application Pure Component gt_eq_int_gen
 ############################################################
  *************** Trying Arrow Component ************gt_eq_int_gen :  Arrow ( ( n3 : {var_v0:int | true} ) -> {v:int | 
 Disj <d  v > n3
 	,   v = n3>d }
  *************** Synthesizing Args ei : ti for ************gt_eq_int_gen
 ##################################################################################
  Synthesizing the 1th argument for Function gt_eq_int_gen
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v0:int | true}
 
 Enumerating a Scalar Term size
 
 Type of the Scalar Term {v:int | true}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term s
 
 Type of the Scalar Term {var_v1:int | true}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term n3
 
 Type of the Scalar Term {var_v0:int | true}
 ################################################
 Skipping Variable n3 As this a  Formal Parameter to the current function Call
 ################################################
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {v:int | true}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term _lbv1
 
 Type of the Scalar Term {v:int | (v) ==((size) -- (1))}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Returned Successfully
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>> 1th Args option for gt_eq_int_gen : apply subs  (, size )
 >>>>>>>>>>>>>>>>>>> 1th Args option for gt_eq_int_gen : n
 >>>>>>>>>>>>>>>>>>> 1th Args option for gt_eq_int_gen : s
 >>>>>>>>>>>>>>>>>>> 1th Args option for gt_eq_int_gen : size
  DEPTH vs MAX  2 vs 3
 ##################################################################################
  *************** Successfully Synthesized Args ei Forall i 
 1 th Argument Options for gt_eq_int_gen
 EI apply subs  (, size )
 EI n
 EI s
 EI size
 # of Possible Argument Options for gt_eq_int_gen 4
 HERE
 # of Possible Argument Options for gt_eq_int_gen 4
 Possible Arg Options 
 EI apply subs  (, size )
 Possible Arg Options 
 EI n
 Possible Arg Options 
 EI s
 Possible Arg Options 
 EI size
 Apply Single Argument Case : f (ei) Case gt_eq_int_gen
  Case : f (ei) Case gt_eq_int_gen _lbv1
 Finding Already seen tree for apply gt_eq_int_gen  (, _lbv1 )
 Typechecking apply gt_eq_int_gen  (, apply subs  (, size ) )
 Against {v:int | 
 	 Conj <c true
 	 , size > v >c }
 Typechecking the Term apply gt_eq_int_gen  (, _lbv1 )
 Against {v:int | 
 	 Conj <c true
 	 , size > v >c }
 Argument _lbv1 :: {v:int | (v) ==((size) -- (1))} | (_lbv1) ==((size) -- (1))
 AppType Type {v:int | 
 Disj <d  v > _lbv1
 	,   v = _lbv1>d }                                                                                                      
# of Final Z3 expressions 8
 Final solver 
 (declare-sort T93 0)
(declare-fun |0| () Int)
(declare-fun _lbv1 () Int)
(declare-fun v () Int)
(declare-fun size () Int)
(declare-fun var_v4 () Bool)
(declare-fun _lbv0 () Bool)
(declare-fun slen (T93) Int)
(declare-fun Nil () T93)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u18 Int))
  (let ((a!1 (= (= _lbv0 true)
                (and (= size |0|) (= (= _lbv0 false) (> size |0|)))))
        (a!2 (= (= var_v4 true)
                (and (= size |0|) (= (= var_v4 false) (> size |0|))))))
    (and (= (slen Nil) 0)
         a!1
         a!2
         (= _lbv1 (- size 1))
         (or (> v _lbv1) (= v _lbv1))
         (= var_v4 false)
         a!2
         (= _lbv1 (- size 1))
         (or (> v _lbv1) (= v _lbv1))))))
(assert (not (> size v)))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply gt_eq_int_gen  (, _lbv1 )
  Case : f (ei) Case gt_eq_int_gen n
 Finding Already seen tree for apply gt_eq_int_gen  (, n )
 Typechecking apply gt_eq_int_gen  (, n )
 Against {v:int | 
 	 Conj <c true
 	 , size > v >c }
 Typechecking the Term apply gt_eq_int_gen  (, n )
 Against {v:int | 
 	 Conj <c true
 	 , size > v >c }
 Argument n :: {v:int | true} | true
 AppType Type {v:int | 
 Disj <d  v > n
 	,   v = n>d }                                                                                                      
# of Final Z3 expressions 8
 Final solver 
 (declare-sort T97 0)
(declare-fun |0| () Int)
(declare-fun n () Int)
(declare-fun v () Int)
(declare-fun size () Int)
(declare-fun var_v4 () Bool)
(declare-fun _lbv1 () Int)
(declare-fun _lbv0 () Bool)
(declare-fun slen (T97) Int)
(declare-fun Nil () T97)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u19 Int))
  (let ((a!1 (= (= _lbv0 true)
                (and (= size |0|) (= (= _lbv0 false) (> size |0|)))))
        (a!2 (= (= var_v4 true)
                (and (= size |0|) (= (= var_v4 false) (> size |0|))))))
    (and (= (slen Nil) 0)
         a!1
         a!2
         (= _lbv1 (- size 1))
         (or (> v n) (= v n))
         (= var_v4 false)
         a!2
         (or (> v n) (= v n))))))
(assert (not (> size v)))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply gt_eq_int_gen  (, n )
  Case : f (ei) Case gt_eq_int_gen s
 Finding Already seen tree for apply gt_eq_int_gen  (, s )
 Typechecking apply gt_eq_int_gen  (, s )
 Against {v:int | 
 	 Conj <c true
 	 , size > v >c }
 Typechecking the Term apply gt_eq_int_gen  (, s )
 Against {v:int | 
 	 Conj <c true
 	 , size > v >c }
 Argument s :: {var_v1:int | true} | true
 AppType Type {v:int | 
 Disj <d  v > s
 	,   v = s>d }                                                                                                      
# of Final Z3 expressions 8
 Final solver 
 (declare-sort T101 0)
(declare-fun |0| () Int)
(declare-fun s () Int)
(declare-fun v () Int)
(declare-fun size () Int)
(declare-fun var_v4 () Bool)
(declare-fun _lbv1 () Int)
(declare-fun _lbv0 () Bool)
(declare-fun slen (T101) Int)
(declare-fun Nil () T101)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u20 Int))
  (let ((a!1 (= (= _lbv0 true)
                (and (= size |0|) (= (= _lbv0 false) (> size |0|)))))
        (a!2 (= (= var_v4 true)
                (and (= size |0|) (= (= var_v4 false) (> size |0|))))))
    (and (= (slen Nil) 0)
         a!1
         a!2
         (= _lbv1 (- size 1))
         (or (> v s) (= v s))
         (= var_v4 false)
         a!2
         (or (> v s) (= v s))))))
(assert (not (> size v)))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply gt_eq_int_gen  (, s )
  Case : f (ei) Case gt_eq_int_gen size
 Finding Already seen tree for apply gt_eq_int_gen  (, size )
 Typechecking apply gt_eq_int_gen  (, size )
 Against {v:int | 
 	 Conj <c true
 	 , size > v >c }
 Typechecking the Term apply gt_eq_int_gen  (, size )
 Against {v:int | 
 	 Conj <c true
 	 , size > v >c }
 Argument size :: {v:int | true} | true
 AppType Type {v:int | 
 Disj <d  v > size
 	,   v = size>d }                                                                                                      
# of Final Z3 expressions 8
 Final solver 
 (declare-sort T105 0)
(declare-fun |0| () Int)
(declare-fun size () Int)
(declare-fun v () Int)
(declare-fun var_v4 () Bool)
(declare-fun _lbv1 () Int)
(declare-fun _lbv0 () Bool)
(declare-fun slen (T105) Int)
(declare-fun Nil () T105)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u21 Int))
  (let ((a!1 (= (= _lbv0 true)
                (and (= size |0|) (= (= _lbv0 false) (> size |0|)))))
        (a!2 (= (= var_v4 true)
                (and (= size |0|) (= (= var_v4 false) (> size |0|))))))
    (and (= (slen Nil) 0)
         a!1
         a!2
         (= _lbv1 (- size 1))
         (or (> v size) (= v size))
         (= var_v4 false)
         a!2
         (or (> v size) (= v size))))))
(assert (not (> size v)))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply gt_eq_int_gen  (, size )
  ###################################################
  The Choice of Function gt_eq_int_gen Was Ill Fated Try Next Choice of function
 ############################################################
  Synthesizing the Function application Pure Component subs
 ############################################################
  *************** Trying Arrow Component ************subs :  Arrow ( ( n : {v:int | true} ) -> {v:int | (v) ==((n) -- (1))}
  *************** Synthesizing Args ei : ti for ************subs
 ##################################################################################
  Synthesizing the 1th argument for Function subs
  Trying Arguments in Scalars 
 esynthesizeScalar for {v:int | true}
 
 Enumerating a Scalar Term size
 
 Type of the Scalar Term {v:int | true}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term s
 
 Type of the Scalar Term {var_v1:int | true}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {v:int | true}
 ################################################
 Skipping Variable n As this a  Formal Parameter to the current function Call
 ################################################
 
 Enumerating a Scalar Term _lbv1
 
 Type of the Scalar Term {v:int | (v) ==((size) -- (1))}
 ################################################
 Skipping Variable _lbv1 As Outer Function Call is subs
 
 Enumerating a Scalar Term n3
 
 Type of the Scalar Term {var_v0:int | true}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>> 1th Args option for subs : n3
 >>>>>>>>>>>>>>>>>>> 1th Args option for subs : s
 >>>>>>>>>>>>>>>>>>> 1th Args option for subs : size
  DEPTH vs MAX  2 vs 3
 ##################################################################################
  *************** Successfully Synthesized Args ei Forall i 
 1 th Argument Options for subs
 EI n3
 EI s
 EI size
 # of Possible Argument Options for subs 3
 HERE
 # of Possible Argument Options for subs 3
 Possible Arg Options 
 EI n3
 Possible Arg Options 
 EI s
 Possible Arg Options 
 EI size
 Apply Single Argument Case : f (ei) Case subs
  Case : f (ei) Case subs n3
 Finding Already seen tree for apply subs  (, n3 )
 Typechecking apply subs  (, n3 )
 Against {v:int | 
 	 Conj <c true
 	 , size > v >c }
 Typechecking the Term apply subs  (, n3 )
 Against {v:int | 
 	 Conj <c true
 	 , size > v >c }
 Argument n3 :: {var_v0:int | true} | true
 AppType Type {v:int | (v) ==((n3) -- (1))}                                                                                
# of Final Z3 expressions 8
 Final solver 
 (declare-sort T124 0)
(declare-fun |0| () Int)
(declare-fun n3 () Int)
(declare-fun v () Int)
(declare-fun size () Int)
(declare-fun var_v4 () Bool)
(declare-fun _lbv1 () Int)
(declare-fun _lbv0 () Bool)
(declare-fun slen (T124) Int)
(declare-fun Nil () T124)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u22 Int))
  (let ((a!1 (= (= _lbv0 true)
                (and (= size |0|) (= (= _lbv0 false) (> size |0|)))))
        (a!2 (= (= var_v4 true)
                (and (= size |0|) (= (= var_v4 false) (> size |0|))))))
    (and (= (slen Nil) 0)
         a!1
         a!2
         (= _lbv1 (- size 1))
         (= v (- n3 1))
         (= var_v4 false)
         a!2
         (= v (- n3 1))))))
(assert (not (> size v)))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply subs  (, n3 )
  Case : f (ei) Case subs s
 Finding Already seen tree for apply subs  (, s )
 Typechecking apply subs  (, s )
 Against {v:int | 
 	 Conj <c true
 	 , size > v >c }
 Typechecking the Term apply subs  (, s )
 Against {v:int | 
 	 Conj <c true
 	 , size > v >c }
 Argument s :: {var_v1:int | true} | true
 AppType Type {v:int | (v) ==((s) -- (1))}                                                                                
# of Final Z3 expressions 8
 Final solver 
 (declare-sort T128 0)
(declare-fun |0| () Int)
(declare-fun s () Int)
(declare-fun v () Int)
(declare-fun size () Int)
(declare-fun var_v4 () Bool)
(declare-fun _lbv1 () Int)
(declare-fun _lbv0 () Bool)
(declare-fun slen (T128) Int)
(declare-fun Nil () T128)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u23 Int))
  (let ((a!1 (= (= _lbv0 true)
                (and (= size |0|) (= (= _lbv0 false) (> size |0|)))))
        (a!2 (= (= var_v4 true)
                (and (= size |0|) (= (= var_v4 false) (> size |0|))))))
    (and (= (slen Nil) 0)
         a!1
         a!2
         (= _lbv1 (- size 1))
         (= v (- s 1))
         (= var_v4 false)
         a!2
         (= v (- s 1))))))
(assert (not (> size v)))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply subs  (, s )
  Case : f (ei) Case subs size
 Finding Already seen tree for apply subs  (, size )
 Found _lbv1
 >>>>>>>>>>>>>>>>>>> 1th Args option for goal : apply subs  (, size )
 >>>>>>>>>>>>>>>>>>> 1th Args option for goal : apply subs  (, size )
  DEPTH vs MAX  1 vs 3
 ##################################################################################
  *************** Successfully Synthesized Args ei Forall i 
 1 th Argument Options for goal
 EI apply subs  (, size )
 EI apply subs  (, size )
 # of Possible Argument Options for goal 2
 HERE
 # of Possible Argument Options for goal 2
 Possible Arg Options 
 EI apply subs  (, size )
 Possible Arg Options 
 EI apply subs  (, size )
 Apply Single Argument Case : f (ei) Case goal
  Case : f (ei) Case goal _lbv1
 Finding Already seen tree for apply goal  (, _lbv1 )
 Typechecking apply goal  (, apply subs  (, size ) )
 Against {v:int list | Forall 
 	 
 Key =u Value = int{ 
 	 Impl < (slen)(v) ==(u)
 	 
 	 Conj <c 
 Disj <d  u > 0
 	,   u = 0>d 
 	 , u = size >c  > }}
 Typechecking the Term apply goal  (, _lbv1 )
 Against {v:int list | Forall 
 	 
 Key =u Value = int{ 
 	 Impl < (slen)(v) ==(u)
 	 
 	 Conj <c 
 Disj <d  u > 0
 	,   u = 0>d 
 	 , u = size >c  > }}
 Argument _lbv1 :: {v:int | (v) ==((size) -- (1))} | (_lbv1) ==((size) -- (1))
 AppType Type {v:int list | Forall 
 	 
 Key =u Value = int{ 
 	 Impl < (slen)(v) ==(u)
 	 
 	 Conj <c 
 Disj <d  u > 0
 	,   u = 0>d 
 	 , u = _lbv1 >c  > }}                                                                                                                                   
# of Final Z3 expressions 14
 Final solver 
 (declare-sort T132 0)
(declare-fun |0| () Int)
(declare-fun _lbv1 () Int)
(declare-fun slen (T132) Int)
(declare-fun v () T132)
(declare-fun size () Int)
(declare-fun var_v4 () Bool)
(declare-fun size1 () Int)
(declare-fun _lbv0 () Bool)
(declare-fun Nil () T132)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u26 Int) (var_u25 Int) (var_u24 Int))
  (let ((a!1 (= (= _lbv0 true)
                (and (= size |0|) (= (= _lbv0 false) (> size |0|)))))
        (a!2 (= (= var_v4 true)
                (and (= size |0|) (= (= var_v4 false) (> size |0|)))))
        (a!3 (=> (= (slen v) var_u25)
                 (and (or (> var_u25 |0|) (= var_u25 |0|)) (= var_u25 _lbv1))))
        (a!4 (=> (= (slen v) var_u26)
                 (and (or (> var_u26 |0|) (= var_u26 |0|)) (= var_u26 _lbv1)))))
    (and (= (slen Nil) 0)
         a!1
         a!2
         (= _lbv1 (- size 1))
         (> size size1)
         a!3
         (= var_v4 false)
         a!2
         (= _lbv1 (- size 1))
         a!4))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (let ((a!1 (forall ((var_u27 Int))
             (=> (= (slen v) var_u27)
                 (and (or (> var_u27 |0|) (= var_u27 |0|)) (= var_u27 size))))))
  (not a!1)))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply goal  (, _lbv1 )
  Case : f (ei) Case goal _lbv1
 Finding Already seen tree for apply goal  (, _lbv1 )
 Typechecking apply goal  (, apply subs  (, size ) )
 Against {v:int list | Forall 
 	 
 Key =u Value = int{ 
 	 Impl < (slen)(v) ==(u)
 	 
 	 Conj <c 
 Disj <d  u > 0
 	,   u = 0>d 
 	 , u = size >c  > }}
 Typechecking the Term apply goal  (, _lbv1 )
 Against {v:int list | Forall 
 	 
 Key =u Value = int{ 
 	 Impl < (slen)(v) ==(u)
 	 
 	 Conj <c 
 Disj <d  u > 0
 	,   u = 0>d 
 	 , u = size >c  > }}
 Argument _lbv1 :: {v:int | (v) ==((size) -- (1))} | (_lbv1) ==((size) -- (1))
 AppType Type {v:int list | Forall 
 	 
 Key =u Value = int{ 
 	 Impl < (slen)(v) ==(u)
 	 
 	 Conj <c 
 Disj <d  u > 0
 	,   u = 0>d 
 	 , u = _lbv1 >c  > }}                                                                                                                                   
# of Final Z3 expressions 14
 Final solver 
 (declare-sort T136 0)
(declare-fun |0| () Int)
(declare-fun _lbv1 () Int)
(declare-fun slen (T136) Int)
(declare-fun v () T136)
(declare-fun size () Int)
(declare-fun var_v4 () Bool)
(declare-fun size1 () Int)
(declare-fun _lbv0 () Bool)
(declare-fun Nil () T136)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u30 Int) (var_u29 Int) (var_u28 Int))
  (let ((a!1 (= (= _lbv0 true)
                (and (= size |0|) (= (= _lbv0 false) (> size |0|)))))
        (a!2 (= (= var_v4 true)
                (and (= size |0|) (= (= var_v4 false) (> size |0|)))))
        (a!3 (=> (= (slen v) var_u29)
                 (and (or (> var_u29 |0|) (= var_u29 |0|)) (= var_u29 _lbv1))))
        (a!4 (=> (= (slen v) var_u30)
                 (and (or (> var_u30 |0|) (= var_u30 |0|)) (= var_u30 _lbv1)))))
    (and (= (slen Nil) 0)
         a!1
         a!2
         (= _lbv1 (- size 1))
         (> size size1)
         a!3
         (= var_v4 false)
         a!2
         (= _lbv1 (- size 1))
         a!4))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (let ((a!1 (forall ((var_u31 Int))
             (=> (= (slen v) var_u31)
                 (and (or (> var_u31 |0|) (= var_u31 |0|)) (= var_u31 size))))))
  (not a!1)))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply goal  (, _lbv1 )
  ###################################################
  The Choice of Function goal Was Ill Fated Try Next Choice of function
 ############################################################
  Synthesizing the Function application Pure Component Cons
 ############################################################
  *************** Trying Arrow Component ************Cons :  Arrow ( ( x : {v:int | true} ) ->  Arrow ( ( xs : {v:int list | true} ) -> {v:int list | Forall 
 	 
 Key =u Value = int{ 
 	 Impl < (u) ==((slen)(xs) + (1))
 	 (slen)(v) ==(u) > }}
  *************** Synthesizing Args ei : ti for ************Cons
 ##################################################################################
  Synthesizing the 1th argument for Function Cons
  Trying Arguments in Scalars 
 esynthesizeScalar for {v:int | true}
 
 Enumerating a Scalar Term size
 
 Type of the Scalar Term {v:int | true}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term s
 
 Type of the Scalar Term {var_v1:int | true}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term _lbv1
 
 Type of the Scalar Term {v:int | (v) ==((size) -- (1))}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 Enumerating a Scalar Term n3
 
 Type of the Scalar Term {var_v0:int | true}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {v:int | true}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term size1
 
 Type of the Scalar Term {v:int | 
 	 Conj <c true
 	 , size > v >c }
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  , 
 gt_eq_int_gen, 
 subs
 ############################################################
  Synthesizing the Function application Pure Component gt_eq_int_gen
 ############################################################
  *************** Trying Arrow Component ************gt_eq_int_gen :  Arrow ( ( n3 : {var_v0:int | true} ) -> {v:int | 
 Disj <d  v > n3
 	,   v = n3>d }
  *************** Synthesizing Args ei : ti for ************gt_eq_int_gen
 ##################################################################################
  Synthesizing the 1th argument for Function gt_eq_int_gen
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v0:int | true}
 
 Enumerating a Scalar Term size
 
 Type of the Scalar Term {v:int | true}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term s
 
 Type of the Scalar Term {var_v1:int | true}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term _lbv1
 
 Type of the Scalar Term {v:int | (v) ==((size) -- (1))}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 Enumerating a Scalar Term n3
 
 Type of the Scalar Term {var_v0:int | true}
 ################################################
 Skipping Variable n3 As this a  Formal Parameter to the current function Call
 ################################################
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {v:int | true}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 
 Enumerating a Scalar Term size1
 
 Type of the Scalar Term {v:int | 
 	 Conj <c true
 	 , size > v >c }
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>> 1th Args option for gt_eq_int_gen : size1
 >>>>>>>>>>>>>>>>>>> 1th Args option for gt_eq_int_gen : n
 >>>>>>>>>>>>>>>>>>> 1th Args option for gt_eq_int_gen : apply subs  (, size )
 >>>>>>>>>>>>>>>>>>> 1th Args option for gt_eq_int_gen : s
 >>>>>>>>>>>>>>>>>>> 1th Args option for gt_eq_int_gen : size
  DEPTH vs MAX  2 vs 3
 ##################################################################################
  *************** Successfully Synthesized Args ei Forall i 
 1 th Argument Options for gt_eq_int_gen
 EI size1
 EI n
 EI apply subs  (, size )
 EI s
 EI size
 # of Possible Argument Options for gt_eq_int_gen 5
 HERE
 # of Possible Argument Options for gt_eq_int_gen 5
 Possible Arg Options 
 EI size1
 Possible Arg Options 
 EI n
 Possible Arg Options 
 EI apply subs  (, size )
 Possible Arg Options 
 EI s
 Possible Arg Options 
 EI size
 Apply Single Argument Case : f (ei) Case gt_eq_int_gen
  Case : f (ei) Case gt_eq_int_gen size1
 Finding Already seen tree for apply gt_eq_int_gen  (, size1 )
 Typechecking apply gt_eq_int_gen  (, size1 )
 Against {v:int | true}
 Typechecking the Term apply gt_eq_int_gen  (, size1 )
 Against {v:int | true}
 Argument size1 :: {v:int | 
 	 Conj <c true
 	 , size > v >c } | 
 	 Conj <c true
 	 , size > size1 >c 
 AppType Type {v:int | 
 Disj <d  v > size1
 	,   v = size1>d }
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
  Show *************** TypeChecking Succsessful {v:int | 
 Disj <d  v > size1
 	,   v = size1>d }
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 let _lbv2 = apply gt_eq_int_gen  (, size1 )
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  Case : f (ei) Case gt_eq_int_gen n
 Finding Already seen tree for apply gt_eq_int_gen  (, n )
 Typechecking apply gt_eq_int_gen  (, n )
 Against {v:int | true}
 Typechecking the Term apply gt_eq_int_gen  (, n )
 Against {v:int | true}
 Argument n :: {v:int | true} | true
 AppType Type {v:int | 
 Disj <d  v > n
 	,   v = n>d }
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
  Show *************** TypeChecking Succsessful {v:int | 
 Disj <d  v > n
 	,   v = n>d }
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 let _lbv3 = apply gt_eq_int_gen  (, n )
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  Case : f (ei) Case gt_eq_int_gen _lbv1
 Finding Already seen tree for apply gt_eq_int_gen  (, _lbv1 )
 Typechecking apply gt_eq_int_gen  (, apply subs  (, size ) )
 Against {v:int | true}
 Typechecking the Term apply gt_eq_int_gen  (, _lbv1 )
 Against {v:int | true}
 Argument _lbv1 :: {v:int | (v) ==((size) -- (1))} | (_lbv1) ==((size) -- (1))
 AppType Type {v:int | 
 Disj <d  v > _lbv1
 	,   v = _lbv1>d }
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
  Show *************** TypeChecking Succsessful {v:int | 
 Disj <d  v > _lbv1
 	,   v = _lbv1>d }
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 let _lbv4 = apply gt_eq_int_gen  (, _lbv1 )
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  Case : f (ei) Case gt_eq_int_gen s
 Finding Already seen tree for apply gt_eq_int_gen  (, s )
 Typechecking apply gt_eq_int_gen  (, s )
 Against {v:int | true}
 Typechecking the Term apply gt_eq_int_gen  (, s )
 Against {v:int | true}
 Argument s :: {var_v1:int | true} | true
 AppType Type {v:int | 
 Disj <d  v > s
 	,   v = s>d }
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
  Show *************** TypeChecking Succsessful {v:int | 
 Disj <d  v > s
 	,   v = s>d }
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 let _lbv5 = apply gt_eq_int_gen  (, s )
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  Case : f (ei) Case gt_eq_int_gen size
 Finding Already seen tree for apply gt_eq_int_gen  (, size )
 Typechecking apply gt_eq_int_gen  (, size )
 Against {v:int | true}
 Typechecking the Term apply gt_eq_int_gen  (, size )
 Against {v:int | true}
 Argument size :: {v:int | true} | true
 AppType Type {v:int | 
 Disj <d  v > size
 	,   v = size>d }
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
  Show *************** TypeChecking Succsessful {v:int | 
 Disj <d  v > size
 	,   v = size>d }
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 let _lbv6 = apply gt_eq_int_gen  (, size )
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 >>>>>>>>>>>>>>>>>>> 1th Args option for Cons : size1
 >>>>>>>>>>>>>>>>>>> 1th Args option for Cons : n
 >>>>>>>>>>>>>>>>>>> 1th Args option for Cons : n3
 >>>>>>>>>>>>>>>>>>> 1th Args option for Cons : apply subs  (, size )
 >>>>>>>>>>>>>>>>>>> 1th Args option for Cons : s
 >>>>>>>>>>>>>>>>>>> 1th Args option for Cons : size
 >>>>>>>>>>>>>>>>>>> 1th Args option for Cons : apply gt_eq_int_gen  (, size )
 >>>>>>>>>>>>>>>>>>> 1th Args option for Cons : apply gt_eq_int_gen  (, s )
 >>>>>>>>>>>>>>>>>>> 1th Args option for Cons : apply gt_eq_int_gen  (, apply subs  (, size ) )
 >>>>>>>>>>>>>>>>>>> 1th Args option for Cons : apply gt_eq_int_gen  (, n )
 >>>>>>>>>>>>>>>>>>> 1th Args option for Cons : apply gt_eq_int_gen  (, size1 )
  DEPTH vs MAX  1 vs 3
 ##################################################################################
  Synthesizing the 2th argument for Function Cons
  Trying Arguments in Scalars 
 esynthesizeScalar for {v:int list | true}
 
 Enumerating a Scalar Term Nil
 
 Type of the Scalar Term {v:int list | Forall 
 	 
 Key =u Value = int{ (slen)(v) ==(0) }}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  , 
 goal, 
 Cons
 ############################################################
  Synthesizing the Function application Pure Component goal
 ############################################################
  *************** Trying Arrow Component ************goal :  Arrow ( ( size1 : {v:int | 
 	 Conj <c true
 	 , size > v >c } ) -> {v:int list | Forall 
 	 
 Key =u Value = int{ 
 	 Impl < (slen)(v) ==(u)
 	 
 	 Conj <c 
 Disj <d  u > 0
 	,   u = 0>d 
 	 , u = size1 >c  > }}
  *************** Synthesizing Args ei : ti for ************goal
 ##################################################################################
  Synthesizing the 1th argument for Function goal
  Trying Arguments in Scalars 
 esynthesizeScalar for {v:int | 
 	 Conj <c true
 	 , size > v >c }
 
 Enumerating a Scalar Term size
 
 Type of the Scalar Term {v:int | true}                                                                                                                                            
# of Final Z3 expressions 8
 Final solver 
 (declare-sort T225 0)
(declare-fun |0| () Int)
(declare-fun size () Int)
(declare-fun var_v4 () Bool)
(declare-fun _lbv6 () Int)
(declare-fun s () Int)
(declare-fun _lbv5 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv4 () Int)
(declare-fun n () Int)
(declare-fun _lbv3 () Int)
(declare-fun size1 () Int)
(declare-fun _lbv2 () Int)
(declare-fun _lbv0 () Bool)
(declare-fun slen (T225) Int)
(declare-fun Nil () T225)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u32 Int))
  (let ((a!1 (= (= _lbv0 true)
                (and (= size |0|) (= (= _lbv0 false) (> size |0|)))))
        (a!2 (= (= var_v4 true)
                (and (= size |0|) (= (= var_v4 false) (> size |0|))))))
    (and (= (slen Nil) 0)
         a!1
         a!2
         (= _lbv1 (- size 1))
         (> size size1)
         (or (> _lbv2 size1) (= _lbv2 size1))
         (or (> _lbv3 n) (= _lbv3 n))
         (or (> _lbv4 _lbv1) (= _lbv4 _lbv1))
         (or (> _lbv5 s) (= _lbv5 s))
         (or (> _lbv6 size) (= _lbv6 size))
         (= var_v4 false)
         a!2))))
(assert (not (> size size)))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term s
 
 Type of the Scalar Term {var_v1:int | true}                                                                                                                                            
# of Final Z3 expressions 8
 Final solver 
 (declare-sort T229 0)
(declare-fun |0| () Int)
(declare-fun size () Int)
(declare-fun var_v4 () Bool)
(declare-fun _lbv6 () Int)
(declare-fun s () Int)
(declare-fun _lbv5 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv4 () Int)
(declare-fun n () Int)
(declare-fun _lbv3 () Int)
(declare-fun size1 () Int)
(declare-fun _lbv2 () Int)
(declare-fun _lbv0 () Bool)
(declare-fun slen (T229) Int)
(declare-fun Nil () T229)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u33 Int))
  (let ((a!1 (= (= _lbv0 true)
                (and (= size |0|) (= (= _lbv0 false) (> size |0|)))))
        (a!2 (= (= var_v4 true)
                (and (= size |0|) (= (= var_v4 false) (> size |0|))))))
    (and (= (slen Nil) 0)
         a!1
         a!2
         (= _lbv1 (- size 1))
         (> size size1)
         (or (> _lbv2 size1) (= _lbv2 size1))
         (or (> _lbv3 n) (= _lbv3 n))
         (or (> _lbv4 _lbv1) (= _lbv4 _lbv1))
         (or (> _lbv5 s) (= _lbv5 s))
         (or (> _lbv6 size) (= _lbv6 size))
         (= var_v4 false)
         a!2))))
(assert (not (> size s)))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term _lbv1
 
 Type of the Scalar Term {v:int | (v) ==((size) -- (1))}                                                                                                                                            
# of Final Z3 expressions 8
 Final solver 
 (declare-sort T233 0)
(declare-fun |0| () Int)
(declare-fun size () Int)
(declare-fun _lbv1 () Int)
(declare-fun var_v4 () Bool)
(declare-fun _lbv6 () Int)
(declare-fun s () Int)
(declare-fun _lbv5 () Int)
(declare-fun _lbv4 () Int)
(declare-fun n () Int)
(declare-fun _lbv3 () Int)
(declare-fun size1 () Int)
(declare-fun _lbv2 () Int)
(declare-fun _lbv0 () Bool)
(declare-fun slen (T233) Int)
(declare-fun Nil () T233)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u34 Int))
  (let ((a!1 (= (= _lbv0 true)
                (and (= size |0|) (= (= _lbv0 false) (> size |0|)))))
        (a!2 (= (= var_v4 true)
                (and (= size |0|) (= (= var_v4 false) (> size |0|))))))
    (and (= (slen Nil) 0)
         a!1
         a!2
         (> size size1)
         (or (> _lbv2 size1) (= _lbv2 size1))
         (or (> _lbv3 n) (= _lbv3 n))
         (or (> _lbv4 _lbv1) (= _lbv4 _lbv1))
         (or (> _lbv5 s) (= _lbv5 s))
         (or (> _lbv6 size) (= _lbv6 size))
         (= _lbv1 (- size 1))
         (= var_v4 false)
         a!2
         (= _lbv1 (- size 1))))))
(assert (not (> size _lbv1)))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 Enumerating a Scalar Term n
 
 Type of the Scalar Term {v:int | true}                                                                                                                                            
# of Final Z3 expressions 8
 Final solver 
 (declare-sort T237 0)
(declare-fun |0| () Int)
(declare-fun size () Int)
(declare-fun var_v4 () Bool)
(declare-fun _lbv6 () Int)
(declare-fun s () Int)
(declare-fun _lbv5 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv4 () Int)
(declare-fun n () Int)
(declare-fun _lbv3 () Int)
(declare-fun size1 () Int)
(declare-fun _lbv2 () Int)
(declare-fun _lbv0 () Bool)
(declare-fun slen (T237) Int)
(declare-fun Nil () T237)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u35 Int))
  (let ((a!1 (= (= _lbv0 true)
                (and (= size |0|) (= (= _lbv0 false) (> size |0|)))))
        (a!2 (= (= var_v4 true)
                (and (= size |0|) (= (= var_v4 false) (> size |0|))))))
    (and (= (slen Nil) 0)
         a!1
         a!2
         (= _lbv1 (- size 1))
         (> size size1)
         (or (> _lbv2 size1) (= _lbv2 size1))
         (or (> _lbv3 n) (= _lbv3 n))
         (or (> _lbv4 _lbv1) (= _lbv4 _lbv1))
         (or (> _lbv5 s) (= _lbv5 s))
         (or (> _lbv6 size) (= _lbv6 size))
         (= var_v4 false)
         a!2))))
(assert (not (> size n)))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term size1
 
 Type of the Scalar Term {v:int | 
 	 Conj <c true
 	 , size > v >c }
 ################################################
 Skipping Variable size1 As this a  Formal Parameter to the current function Call
 ################################################
 
 Enumerating a Scalar Term n3
 
 Type of the Scalar Term {var_v0:int | true}                                                                                                                                            
# of Final Z3 expressions 8
 Final solver 
 (declare-sort T241 0)
(declare-fun |0| () Int)
(declare-fun size () Int)
(declare-fun var_v4 () Bool)
(declare-fun _lbv6 () Int)
(declare-fun s () Int)
(declare-fun _lbv5 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv4 () Int)
(declare-fun n () Int)
(declare-fun _lbv3 () Int)
(declare-fun size1 () Int)
(declare-fun _lbv2 () Int)
(declare-fun _lbv0 () Bool)
(declare-fun slen (T241) Int)
(declare-fun Nil () T241)
(declare-fun n3 () Int)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u36 Int))
  (let ((a!1 (= (= _lbv0 true)
                (and (= size |0|) (= (= _lbv0 false) (> size |0|)))))
        (a!2 (= (= var_v4 true)
                (and (= size |0|) (= (= var_v4 false) (> size |0|))))))
    (and (= (slen Nil) 0)
         a!1
         a!2
         (= _lbv1 (- size 1))
         (> size size1)
         (or (> _lbv2 size1) (= _lbv2 size1))
         (or (> _lbv3 n) (= _lbv3 n))
         (or (> _lbv4 _lbv1) (= _lbv4 _lbv1))
         (or (> _lbv5 s) (= _lbv5 s))
         (or (> _lbv6 size) (= _lbv6 size))
         (= var_v4 false)
         a!2))))
(assert (not (> size n3)))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term _lbv2
 
 Type of the Scalar Term {v:int | 
 Disj <d  v > size1
 	,   v = size1>d }                                                                                                                                                       
# of Final Z3 expressions 8
 Final solver 
 (declare-sort T245 0)
(declare-fun |0| () Int)
(declare-fun size1 () Int)
(declare-fun _lbv2 () Int)
(declare-fun size () Int)
(declare-fun var_v4 () Bool)
(declare-fun _lbv6 () Int)
(declare-fun s () Int)
(declare-fun _lbv5 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv4 () Int)
(declare-fun n () Int)
(declare-fun _lbv3 () Int)
(declare-fun _lbv0 () Bool)
(declare-fun slen (T245) Int)
(declare-fun Nil () T245)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u37 Int))
  (let ((a!1 (= (= _lbv0 true)
                (and (= size |0|) (= (= _lbv0 false) (> size |0|)))))
        (a!2 (= (= var_v4 true)
                (and (= size |0|) (= (= var_v4 false) (> size |0|))))))
    (and (= (slen Nil) 0)
         a!1
         a!2
         (= _lbv1 (- size 1))
         (> size size1)
         (or (> _lbv3 n) (= _lbv3 n))
         (or (> _lbv4 _lbv1) (= _lbv4 _lbv1))
         (or (> _lbv5 s) (= _lbv5 s))
         (or (> _lbv6 size) (= _lbv6 size))
         (or (> _lbv2 size1) (= _lbv2 size1))
         (= var_v4 false)
         a!2
         (or (> _lbv2 size1) (= _lbv2 size1))))))
(assert (not (> size _lbv2)))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term _lbv3
 
 Type of the Scalar Term {v:int | 
 Disj <d  v > n
 	,   v = n>d }                                                                                                                                                       
# of Final Z3 expressions 8
 Final solver 
 (declare-sort T249 0)
(declare-fun |0| () Int)
(declare-fun n () Int)
(declare-fun _lbv3 () Int)
(declare-fun size () Int)
(declare-fun var_v4 () Bool)
(declare-fun _lbv6 () Int)
(declare-fun s () Int)
(declare-fun _lbv5 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv4 () Int)
(declare-fun size1 () Int)
(declare-fun _lbv2 () Int)
(declare-fun _lbv0 () Bool)
(declare-fun slen (T249) Int)
(declare-fun Nil () T249)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u38 Int))
  (let ((a!1 (= (= _lbv0 true)
                (and (= size |0|) (= (= _lbv0 false) (> size |0|)))))
        (a!2 (= (= var_v4 true)
                (and (= size |0|) (= (= var_v4 false) (> size |0|))))))
    (and (= (slen Nil) 0)
         a!1
         a!2
         (= _lbv1 (- size 1))
         (> size size1)
         (or (> _lbv2 size1) (= _lbv2 size1))
         (or (> _lbv4 _lbv1) (= _lbv4 _lbv1))
         (or (> _lbv5 s) (= _lbv5 s))
         (or (> _lbv6 size) (= _lbv6 size))
         (or (> _lbv3 n) (= _lbv3 n))
         (= var_v4 false)
         a!2
         (or (> _lbv3 n) (= _lbv3 n))))))
(assert (not (> size _lbv3)))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term _lbv4
 
 Type of the Scalar Term {v:int | 
 Disj <d  v > _lbv1
 	,   v = _lbv1>d }                                                                                                                                                       
# of Final Z3 expressions 8
 Final solver 
 (declare-sort T253 0)
(declare-fun |0| () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv4 () Int)
(declare-fun size () Int)
(declare-fun var_v4 () Bool)
(declare-fun _lbv6 () Int)
(declare-fun s () Int)
(declare-fun _lbv5 () Int)
(declare-fun n () Int)
(declare-fun _lbv3 () Int)
(declare-fun size1 () Int)
(declare-fun _lbv2 () Int)
(declare-fun _lbv0 () Bool)
(declare-fun slen (T253) Int)
(declare-fun Nil () T253)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u39 Int))
  (let ((a!1 (= (= _lbv0 true)
                (and (= size |0|) (= (= _lbv0 false) (> size |0|)))))
        (a!2 (= (= var_v4 true)
                (and (= size |0|) (= (= var_v4 false) (> size |0|))))))
    (and (= (slen Nil) 0)
         a!1
         a!2
         (= _lbv1 (- size 1))
         (> size size1)
         (or (> _lbv2 size1) (= _lbv2 size1))
         (or (> _lbv3 n) (= _lbv3 n))
         (or (> _lbv5 s) (= _lbv5 s))
         (or (> _lbv6 size) (= _lbv6 size))
         (or (> _lbv4 _lbv1) (= _lbv4 _lbv1))
         (= var_v4 false)
         a!2
         (or (> _lbv4 _lbv1) (= _lbv4 _lbv1))))))
(assert (not (> size _lbv4)))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term _lbv5
 
 Type of the Scalar Term {v:int | 
 Disj <d  v > s
 	,   v = s>d }                                                                                                                                                       
# of Final Z3 expressions 8
 Final solver 
 (declare-sort T257 0)
(declare-fun |0| () Int)
(declare-fun s () Int)
(declare-fun _lbv5 () Int)
(declare-fun size () Int)
(declare-fun var_v4 () Bool)
(declare-fun _lbv6 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv4 () Int)
(declare-fun n () Int)
(declare-fun _lbv3 () Int)
(declare-fun size1 () Int)
(declare-fun _lbv2 () Int)
(declare-fun _lbv0 () Bool)
(declare-fun slen (T257) Int)
(declare-fun Nil () T257)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u40 Int))
  (let ((a!1 (= (= _lbv0 true)
                (and (= size |0|) (= (= _lbv0 false) (> size |0|)))))
        (a!2 (= (= var_v4 true)
                (and (= size |0|) (= (= var_v4 false) (> size |0|))))))
    (and (= (slen Nil) 0)
         a!1
         a!2
         (= _lbv1 (- size 1))
         (> size size1)
         (or (> _lbv2 size1) (= _lbv2 size1))
         (or (> _lbv3 n) (= _lbv3 n))
         (or (> _lbv4 _lbv1) (= _lbv4 _lbv1))
         (or (> _lbv6 size) (= _lbv6 size))
         (or (> _lbv5 s) (= _lbv5 s))
         (= var_v4 false)
         a!2
         (or (> _lbv5 s) (= _lbv5 s))))))
(assert (not (> size _lbv5)))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term _lbv6
 
 Type of the Scalar Term {v:int | 
 Disj <d  v > size
 	,   v = size>d }                                                                                                                                                       
# of Final Z3 expressions 8
 Final solver 
 (declare-sort T261 0)
(declare-fun |0| () Int)
(declare-fun size () Int)
(declare-fun _lbv6 () Int)
(declare-fun var_v4 () Bool)
(declare-fun s () Int)
(declare-fun _lbv5 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv4 () Int)
(declare-fun n () Int)
(declare-fun _lbv3 () Int)
(declare-fun size1 () Int)
(declare-fun _lbv2 () Int)
(declare-fun _lbv0 () Bool)
(declare-fun slen (T261) Int)
(declare-fun Nil () T261)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u41 Int))
  (let ((a!1 (= (= _lbv0 true)
                (and (= size |0|) (= (= _lbv0 false) (> size |0|)))))
        (a!2 (= (= var_v4 true)
                (and (= size |0|) (= (= var_v4 false) (> size |0|))))))
    (and (= (slen Nil) 0)
         a!1
         a!2
         (= _lbv1 (- size 1))
         (> size size1)
         (or (> _lbv2 size1) (= _lbv2 size1))
         (or (> _lbv3 n) (= _lbv3 n))
         (or (> _lbv4 _lbv1) (= _lbv4 _lbv1))
         (or (> _lbv5 s) (= _lbv5 s))
         (or (> _lbv6 size) (= _lbv6 size))
         (= var_v4 false)
         a!2
         (or (> _lbv6 size) (= _lbv6 size))))))
(assert (not (> size _lbv6)))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 Returned Successfully
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term x
 
 Type of the Scalar Term {v:int | true}                                                                                                                                            
# of Final Z3 expressions 8
 Final solver 
 (declare-sort T265 0)
(declare-fun |0| () Int)
(declare-fun size () Int)
(declare-fun var_v4 () Bool)
(declare-fun _lbv6 () Int)
(declare-fun s () Int)
(declare-fun _lbv5 () Int)
(declare-fun _lbv1 () Int)
(declare-fun _lbv4 () Int)
(declare-fun n () Int)
(declare-fun _lbv3 () Int)
(declare-fun size1 () Int)
(declare-fun _lbv2 () Int)
(declare-fun _lbv0 () Bool)
(declare-fun slen (T265) Int)
(declare-fun Nil () T265)
(declare-fun x () Int)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u42 Int))
  (let ((a!1 (= (= _lbv0 true)
                (and (= size |0|) (= (= _lbv0 false) (> size |0|)))))
        (a!2 (= (= var_v4 true)
                (and (= size |0|) (= (= var_v4 false) (> size |0|))))))
    (and (= (slen Nil) 0)
         a!1
         a!2
         (= _lbv1 (- size 1))
         (> size size1)
         (or (> _lbv2 size1) (= _lbv2 size1))
         (or (> _lbv3 n) (= _lbv3 n))
         (or (> _lbv4 _lbv1) (= _lbv4 _lbv1))
         (or (> _lbv5 s) (= _lbv5 s))
         (or (> _lbv6 size) (= _lbv6 size))
         (= var_v4 false)
         a!2))))
(assert (not (> size x)))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
 
 FaileD the subtype check T_vi <: T_goal
 Show :: Found a Few Macthing Scalars 
 ##################################################################################
  Next Trying Arguments of the form f (ei...) 
 ##################################################################################
  Entering Pure Fun Application: esynthesizePureApp 
 ############################################################
 Max depth reached
 ############################################################
 >>>>>>>>>>>>>>>>>>> 1th Args option for goal : apply subs  (, size )
  DEPTH vs MAX  2 vs 3
 ##################################################################################
  *************** Successfully Synthesized Args ei Forall i 
 1 th Argument Options for goal
 EI apply subs  (, size )
 # of Possible Argument Options for goal 1
 HERE
 # of Possible Argument Options for goal 1
 Possible Arg Options 
 EI apply subs  (, size )
 Apply Single Argument Case : f (ei) Case goal
  Case : f (ei) Case goal _lbv1
 Finding Already seen tree for apply goal  (, _lbv1 )
 Typechecking apply goal  (, apply subs  (, size ) )
 Against {v:int list | true}
 Typechecking the Term apply goal  (, _lbv1 )
 Against {v:int list | true}
 Argument _lbv1 :: {v:int | (v) ==((size) -- (1))} | (_lbv1) ==((size) -- (1))
 AppType Type {v:int list | Forall 
 	 
 Key =u Value = int{ 
 	 Impl < (slen)(v) ==(u)
 	 
 	 Conj <c 
 Disj <d  u > 0
 	,   u = 0>d 
 	 , u = _lbv1 >c  > }}
# of Final Z3 expressions 2
 Final solver 
 (assert false)
(assert (not true))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
  Show *************** TypeChecking Succsessful {v:int list | Forall 
 	 
 Key =u Value = int{ 
 	 Impl < (slen)(v) ==(u)
 	 
 	 Conj <c 
 Disj <d  u > 0
 	,   u = 0>d 
 	 , u = _lbv1 >c  > }}
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 let _lbv7 = apply goal  (, _lbv1 )
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 >>>>>>>>>>>>>>>>>>> 2th Args option for Cons : Nil
 >>>>>>>>>>>>>>>>>>> 2th Args option for Cons : apply goal  (, apply subs  (, size ) )
  DEPTH vs MAX  1 vs 3
 ##################################################################################
  *************** Successfully Synthesized Args ei Forall i 
 1 th Argument Options for Cons
 EI size1
 EI n
 EI n3
 EI apply subs  (, size )
 EI s
 EI size
 EI apply gt_eq_int_gen  (, size )
 EI apply gt_eq_int_gen  (, s )
 EI apply gt_eq_int_gen  (, apply subs  (, size ) )
 EI apply gt_eq_int_gen  (, n )
 EI apply gt_eq_int_gen  (, size1 )
 2 th Argument Options for Cons
 EI Nil
 EI apply goal  (, apply subs  (, size ) )
 # of Possible Argument Options for Cons 22
 HERE
 # of Possible Argument Options for Cons 22
 Possible Arg Options 
 EI size1
 EI Nil
 Possible Arg Options 
 EI size1
 EI apply goal  (, apply subs  (, size ) )
 Possible Arg Options 
 EI n
 EI Nil
 Possible Arg Options 
 EI n
 EI apply goal  (, apply subs  (, size ) )
 Possible Arg Options 
 EI n3
 EI Nil
 Possible Arg Options 
 EI n3
 EI apply goal  (, apply subs  (, size ) )
 Possible Arg Options 
 EI apply subs  (, size )
 EI Nil
 Possible Arg Options 
 EI apply subs  (, size )
 EI apply goal  (, apply subs  (, size ) )
 Possible Arg Options 
 EI s
 EI Nil
 Possible Arg Options 
 EI s
 EI apply goal  (, apply subs  (, size ) )
 Possible Arg Options 
 EI size
 EI Nil
 Possible Arg Options 
 EI size
 EI apply goal  (, apply subs  (, size ) )
 Possible Arg Options 
 EI apply gt_eq_int_gen  (, size )
 EI Nil
 Possible Arg Options 
 EI apply gt_eq_int_gen  (, size )
 EI apply goal  (, apply subs  (, size ) )
 Possible Arg Options 
 EI apply gt_eq_int_gen  (, s )
 EI Nil
 Possible Arg Options 
 EI apply gt_eq_int_gen  (, s )
 EI apply goal  (, apply subs  (, size ) )
 Possible Arg Options 
 EI apply gt_eq_int_gen  (, apply subs  (, size ) )
 EI Nil
 Possible Arg Options 
 EI apply gt_eq_int_gen  (, apply subs  (, size ) )
 EI apply goal  (, apply subs  (, size ) )
 Possible Arg Options 
 EI apply gt_eq_int_gen  (, n )
 EI Nil
 Possible Arg Options 
 EI apply gt_eq_int_gen  (, n )
 EI apply goal  (, apply subs  (, size ) )
 Possible Arg Options 
 EI apply gt_eq_int_gen  (, size1 )
 EI Nil
 Possible Arg Options 
 EI apply gt_eq_int_gen  (, size1 )
 EI apply goal  (, apply subs  (, size ) )
 Show f (ei, e2, ....en) Case
 Finding Already seen tree for apply Cons  (, size1 ), Nil )
 Typechecking apply Cons  (, size1 ), Nil )
 Against {v:int list | Forall 
 	 
 Key =u Value = int{ 
 	 Impl < (slen)(v) ==(u)
 	 
 	 Conj <c 
 Disj <d  u > 0
 	,   u = 0>d 
 	 , u = size >c  > }}
 Typechecking the Term apply Cons  (, size1 ), Nil )
 Against {v:int list | Forall 
 	 
 Key =u Value = int{ 
 	 Impl < (slen)(v) ==(u)
 	 
 	 Conj <c 
 Disj <d  u > 0
 	,   u = 0>d 
 	 , u = size >c  > }}
 Argument size1 :: {v:int | 
 	 Conj <c true
 	 , size > v >c } | 
 	 Conj <c true
 	 , size > size1 >c 
 Argument Nil :: {v:int list | Forall 
 	 
 Key =u Value = int{ (slen)(v) ==(0) }} | Forall 
 	 
 Key =u Value = int{ (slen)(Nil) ==(0) }
 AppType Type {v:int list | Forall 
 	 
 Key =u Value = int{ 
 	 Impl < (u) ==((slen)(Nil) + (1))
 	 (slen)(v) ==(u) > }}                                                                                                                                                                              
# of Final Z3 expressions 12
 Final solver 
 (declare-sort T274 0)
(declare-fun |0| () Int)
(declare-fun slen (T274) Int)
(declare-fun v () T274)
(declare-fun Nil () T274)
(declare-fun size1 () Int)
(declare-fun size () Int)
(declare-fun var_v4 () Bool)
(declare-fun _lbv1 () Int)
(declare-fun _lbv7 () T274)
(declare-fun _lbv6 () Int)
(declare-fun s () Int)
(declare-fun _lbv5 () Int)
(declare-fun _lbv4 () Int)
(declare-fun n () Int)
(declare-fun _lbv3 () Int)
(declare-fun _lbv2 () Int)
(declare-fun _lbv0 () Bool)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u47 Int) (var_u46 Int) (var_u45 Int) (var_u44 Int) (var_u43 Int))
  (let ((a!1 (= (= _lbv0 true)
                (and (= size |0|) (= (= _lbv0 false) (> size |0|)))))
        (a!2 (= (= var_v4 true)
                (and (= size |0|) (= (= var_v4 false) (> size |0|)))))
        (a!3 (=> (= (slen _lbv7) var_u44)
                 (and (or (> var_u44 |0|) (= var_u44 |0|)) (= var_u44 _lbv1))))
        (a!4 (=> (= var_u45 (+ (slen Nil) 1)) (= (slen v) var_u45)))
        (a!5 (=> (= var_u47 (+ (slen Nil) 1)) (= (slen v) var_u47))))
    (and (= (slen Nil) 0)
         a!1
         a!2
         (= _lbv1 (- size 1))
         (or (> _lbv2 size1) (= _lbv2 size1))
         (or (> _lbv3 n) (= _lbv3 n))
         (or (> _lbv4 _lbv1) (= _lbv4 _lbv1))
         (or (> _lbv5 s) (= _lbv5 s))
         (or (> _lbv6 size) (= _lbv6 size))
         (> size size1)
         a!3
         a!4
         (= var_v4 false)
         a!2
         (> size size1)
         (= (slen Nil) 0)
         a!5))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (let ((a!1 (forall ((var_u48 Int))
             (=> (= (slen v) var_u48)
                 (and (or (> var_u48 |0|) (= var_u48 |0|)) (= var_u48 size))))))
  (not a!1)))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply Cons  (, size1 ), Nil )
 Finding Already seen tree for apply Cons  (, size1 ), _lbv7 )
 Typechecking apply Cons  (, size1 ), apply goal  (, apply subs  (, size ) ) )
 Against {v:int list | Forall 
 	 
 Key =u Value = int{ 
 	 Impl < (slen)(v) ==(u)
 	 
 	 Conj <c 
 Disj <d  u > 0
 	,   u = 0>d 
 	 , u = size >c  > }}
 Typechecking the Term apply Cons  (, size1 ), _lbv7 )
 Against {v:int list | Forall 
 	 
 Key =u Value = int{ 
 	 Impl < (slen)(v) ==(u)
 	 
 	 Conj <c 
 Disj <d  u > 0
 	,   u = 0>d 
 	 , u = size >c  > }}
 Argument size1 :: {v:int | 
 	 Conj <c true
 	 , size > v >c } | 
 	 Conj <c true
 	 , size > size1 >c 
 Argument _lbv7 :: {v:int list | Forall 
 	 
 Key =u Value = int{ 
 	 Impl < (slen)(v) ==(u)
 	 
 	 Conj <c 
 Disj <d  u > 0
 	,   u = 0>d 
 	 , u = _lbv1 >c  > }} | Forall 
 	 
 Key =u Value = int{ 
 	 Impl < (slen)(_lbv7) ==(u)
 	 
 	 Conj <c 
 Disj <d  u > 0
 	,   u = 0>d 
 	 , u = _lbv1 >c  > }
 AppType Type {v:int list | Forall 
 	 
 Key =u Value = int{ 
 	 Impl < (u) ==((slen)(_lbv7) + (1))
 	 (slen)(v) ==(u) > }}                                                                                                                                                                                               
# of Final Z3 expressions 14
 Final solver 
 (declare-sort T278 0)
(declare-fun |0| () Int)
(declare-fun slen (T278) Int)
(declare-fun v () T278)
(declare-fun _lbv7 () T278)
(declare-fun _lbv1 () Int)
(declare-fun size1 () Int)
(declare-fun size () Int)
(declare-fun var_v4 () Bool)
(declare-fun _lbv6 () Int)
(declare-fun s () Int)
(declare-fun _lbv5 () Int)
(declare-fun _lbv4 () Int)
(declare-fun n () Int)
(declare-fun _lbv3 () Int)
(declare-fun _lbv2 () Int)
(declare-fun _lbv0 () Bool)
(declare-fun Nil () T278)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u53 Int) (var_u52 Int) (var_u51 Int) (var_u50 Int) (var_u49 Int))
  (let ((a!1 (= (= _lbv0 true)
                (and (= size |0|) (= (= _lbv0 false) (> size |0|)))))
        (a!2 (= (= var_v4 true)
                (and (= size |0|) (= (= var_v4 false) (> size |0|)))))
        (a!3 (=> (= (slen _lbv7) var_u50)
                 (and (or (> var_u50 |0|) (= var_u50 |0|)) (= var_u50 _lbv1))))
        (a!4 (=> (= var_u51 (+ (slen _lbv7) 1)) (= (slen v) var_u51)))
        (a!5 (=> (= (slen _lbv7) var_u52)
                 (and (or (> var_u52 |0|) (= var_u52 |0|)) (= var_u52 _lbv1))))
        (a!6 (=> (= var_u53 (+ (slen _lbv7) 1)) (= (slen v) var_u53))))
    (and (= (slen Nil) 0)
         a!1
         a!2
         (= _lbv1 (- size 1))
         (or (> _lbv2 size1) (= _lbv2 size1))
         (or (> _lbv3 n) (= _lbv3 n))
         (or (> _lbv4 _lbv1) (= _lbv4 _lbv1))
         (or (> _lbv5 s) (= _lbv5 s))
         (or (> _lbv6 size) (= _lbv6 size))
         (> size size1)
         a!3
         a!4
         (= var_v4 false)
         a!2
         (> size size1)
         a!5
         a!6))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (let ((a!1 (forall ((var_u54 Int))
             (=> (= (slen v) var_u54)
                 (and (or (> var_u54 |0|) (= var_u54 |0|)) (= var_u54 size))))))
  (not a!1)))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
  Show *************** TypeChecking Succsessful {v:int list | Forall 
 	 
 Key =u Value = int{ 
 	 Impl < (u) ==((slen)(_lbv7) + (1))
 	 (slen)(v) ==(u) > }}
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 let _lbv8 = apply Cons  (, size1 ), _lbv7 )
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 Finding Already seen tree for apply Cons  (, n ), Nil )
 Typechecking apply Cons  (, n ), Nil )
 Against {v:int list | Forall 
 	 
 Key =u Value = int{ 
 	 Impl < (slen)(v) ==(u)
 	 
 	 Conj <c 
 Disj <d  u > 0
 	,   u = 0>d 
 	 , u = size >c  > }}
 Typechecking the Term apply Cons  (, n ), Nil )
 Against {v:int list | Forall 
 	 
 Key =u Value = int{ 
 	 Impl < (slen)(v) ==(u)
 	 
 	 Conj <c 
 Disj <d  u > 0
 	,   u = 0>d 
 	 , u = size >c  > }}
 Argument n :: {v:int | true} | true
 Argument Nil :: {v:int list | Forall 
 	 
 Key =u Value = int{ (slen)(v) ==(0) }} | Forall 
 	 
 Key =u Value = int{ (slen)(Nil) ==(0) }
 AppType Type {v:int list | Forall 
 	 
 Key =u Value = int{ 
 	 Impl < (u) ==((slen)(Nil) + (1))
 	 (slen)(v) ==(u) > }}                                                                                                                                                                         
# of Final Z3 expressions 12
 Final solver 
 (declare-sort T282 0)
(declare-fun |0| () Int)
(declare-fun slen (T282) Int)
(declare-fun v () T282)
(declare-fun Nil () T282)
(declare-fun size () Int)
(declare-fun var_v4 () Bool)
(declare-fun _lbv8 () T282)
(declare-fun _lbv7 () T282)
(declare-fun _lbv1 () Int)
(declare-fun size1 () Int)
(declare-fun _lbv6 () Int)
(declare-fun s () Int)
(declare-fun _lbv5 () Int)
(declare-fun _lbv4 () Int)
(declare-fun n () Int)
(declare-fun _lbv3 () Int)
(declare-fun _lbv2 () Int)
(declare-fun _lbv0 () Bool)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u60 Int)
         (var_u59 Int)
         (var_u58 Int)
         (var_u57 Int)
         (var_u56 Int)
         (var_u55 Int))
  (let ((a!1 (= (= _lbv0 true)
                (and (= size |0|) (= (= _lbv0 false) (> size |0|)))))
        (a!2 (= (= var_v4 true)
                (and (= size |0|) (= (= var_v4 false) (> size |0|)))))
        (a!3 (=> (= (slen _lbv7) var_u56)
                 (and (or (> var_u56 |0|) (= var_u56 |0|)) (= var_u56 _lbv1))))
        (a!4 (=> (= var_u57 (+ (slen _lbv7) 1)) (= (slen _lbv8) var_u57)))
        (a!5 (=> (= var_u58 (+ (slen Nil) 1)) (= (slen v) var_u58)))
        (a!6 (=> (= var_u60 (+ (slen Nil) 1)) (= (slen v) var_u60))))
    (and (= (slen Nil) 0)
         a!1
         a!2
         (= _lbv1 (- size 1))
         (or (> _lbv2 size1) (= _lbv2 size1))
         (or (> _lbv3 n) (= _lbv3 n))
         (or (> _lbv4 _lbv1) (= _lbv4 _lbv1))
         (or (> _lbv5 s) (= _lbv5 s))
         (or (> _lbv6 size) (= _lbv6 size))
         (> size size1)
         a!3
         a!4
         a!5
         (= var_v4 false)
         a!2
         (= (slen Nil) 0)
         a!6))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (let ((a!1 (forall ((var_u61 Int))
             (=> (= (slen v) var_u61)
                 (and (or (> var_u61 |0|) (= var_u61 |0|)) (= var_u61 size))))))
  (not a!1)))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply Cons  (, n ), Nil )
 Finding Already seen tree for apply Cons  (, n ), _lbv7 )
 Typechecking apply Cons  (, n ), apply goal  (, apply subs  (, size ) ) )
 Against {v:int list | Forall 
 	 
 Key =u Value = int{ 
 	 Impl < (slen)(v) ==(u)
 	 
 	 Conj <c 
 Disj <d  u > 0
 	,   u = 0>d 
 	 , u = size >c  > }}
 Typechecking the Term apply Cons  (, n ), _lbv7 )
 Against {v:int list | Forall 
 	 
 Key =u Value = int{ 
 	 Impl < (slen)(v) ==(u)
 	 
 	 Conj <c 
 Disj <d  u > 0
 	,   u = 0>d 
 	 , u = size >c  > }}
 Argument n :: {v:int | true} | true
 Argument _lbv7 :: {v:int list | Forall 
 	 
 Key =u Value = int{ 
 	 Impl < (slen)(v) ==(u)
 	 
 	 Conj <c 
 Disj <d  u > 0
 	,   u = 0>d 
 	 , u = _lbv1 >c  > }} | Forall 
 	 
 Key =u Value = int{ 
 	 Impl < (slen)(_lbv7) ==(u)
 	 
 	 Conj <c 
 Disj <d  u > 0
 	,   u = 0>d 
 	 , u = _lbv1 >c  > }
 AppType Type {v:int list | Forall 
 	 
 Key =u Value = int{ 
 	 Impl < (u) ==((slen)(_lbv7) + (1))
 	 (slen)(v) ==(u) > }}                                                                                                                                                                                          
# of Final Z3 expressions 14
 Final solver 
 (declare-sort T286 0)
(declare-fun |0| () Int)
(declare-fun slen (T286) Int)
(declare-fun v () T286)
(declare-fun _lbv7 () T286)
(declare-fun _lbv1 () Int)
(declare-fun size () Int)
(declare-fun var_v4 () Bool)
(declare-fun _lbv8 () T286)
(declare-fun size1 () Int)
(declare-fun _lbv6 () Int)
(declare-fun s () Int)
(declare-fun _lbv5 () Int)
(declare-fun _lbv4 () Int)
(declare-fun n () Int)
(declare-fun _lbv3 () Int)
(declare-fun _lbv2 () Int)
(declare-fun _lbv0 () Bool)
(declare-fun Nil () T286)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u67 Int)
         (var_u66 Int)
         (var_u65 Int)
         (var_u64 Int)
         (var_u63 Int)
         (var_u62 Int))
  (let ((a!1 (= (= _lbv0 true)
                (and (= size |0|) (= (= _lbv0 false) (> size |0|)))))
        (a!2 (= (= var_v4 true)
                (and (= size |0|) (= (= var_v4 false) (> size |0|)))))
        (a!3 (=> (= (slen _lbv7) var_u63)
                 (and (or (> var_u63 |0|) (= var_u63 |0|)) (= var_u63 _lbv1))))
        (a!4 (=> (= var_u64 (+ (slen _lbv7) 1)) (= (slen _lbv8) var_u64)))
        (a!5 (=> (= var_u65 (+ (slen _lbv7) 1)) (= (slen v) var_u65)))
        (a!6 (=> (= (slen _lbv7) var_u66)
                 (and (or (> var_u66 |0|) (= var_u66 |0|)) (= var_u66 _lbv1))))
        (a!7 (=> (= var_u67 (+ (slen _lbv7) 1)) (= (slen v) var_u67))))
    (and (= (slen Nil) 0)
         a!1
         a!2
         (= _lbv1 (- size 1))
         (or (> _lbv2 size1) (= _lbv2 size1))
         (or (> _lbv3 n) (= _lbv3 n))
         (or (> _lbv4 _lbv1) (= _lbv4 _lbv1))
         (or (> _lbv5 s) (= _lbv5 s))
         (or (> _lbv6 size) (= _lbv6 size))
         (> size size1)
         a!3
         a!4
         a!5
         (= var_v4 false)
         a!2
         a!6
         a!7))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (let ((a!1 (forall ((var_u68 Int))
             (=> (= (slen v) var_u68)
                 (and (or (> var_u68 |0|) (= var_u68 |0|)) (= var_u68 size))))))
  (not a!1)))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
  Show *************** TypeChecking Succsessful {v:int list | Forall 
 	 
 Key =u Value = int{ 
 	 Impl < (u) ==((slen)(_lbv7) + (1))
 	 (slen)(v) ==(u) > }}
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 let _lbv9 = apply Cons  (, n ), _lbv7 )
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 Finding Already seen tree for apply Cons  (, n3 ), Nil )
 Typechecking apply Cons  (, n3 ), Nil )
 Against {v:int list | Forall 
 	 
 Key =u Value = int{ 
 	 Impl < (slen)(v) ==(u)
 	 
 	 Conj <c 
 Disj <d  u > 0
 	,   u = 0>d 
 	 , u = size >c  > }}
 Typechecking the Term apply Cons  (, n3 ), Nil )
 Against {v:int list | Forall 
 	 
 Key =u Value = int{ 
 	 Impl < (slen)(v) ==(u)
 	 
 	 Conj <c 
 Disj <d  u > 0
 	,   u = 0>d 
 	 , u = size >c  > }}
 Argument n3 :: {var_v0:int | true} | true
 Argument Nil :: {v:int list | Forall 
 	 
 Key =u Value = int{ (slen)(v) ==(0) }} | Forall 
 	 
 Key =u Value = int{ (slen)(Nil) ==(0) }
 AppType Type {v:int list | Forall 
 	 
 Key =u Value = int{ 
 	 Impl < (u) ==((slen)(Nil) + (1))
 	 (slen)(v) ==(u) > }}                                                                                                                                                                         
# of Final Z3 expressions 12
 Final solver 
 (declare-sort T290 0)
(declare-fun |0| () Int)
(declare-fun slen (T290) Int)
(declare-fun v () T290)
(declare-fun Nil () T290)
(declare-fun size () Int)
(declare-fun var_v4 () Bool)
(declare-fun _lbv9 () T290)
(declare-fun _lbv7 () T290)
(declare-fun _lbv8 () T290)
(declare-fun _lbv1 () Int)
(declare-fun size1 () Int)
(declare-fun _lbv6 () Int)
(declare-fun s () Int)
(declare-fun _lbv5 () Int)
(declare-fun _lbv4 () Int)
(declare-fun n () Int)
(declare-fun _lbv3 () Int)
(declare-fun _lbv2 () Int)
(declare-fun _lbv0 () Bool)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u75 Int)
         (var_u74 Int)
         (var_u73 Int)
         (var_u72 Int)
         (var_u71 Int)
         (var_u70 Int)
         (var_u69 Int))
  (let ((a!1 (= (= _lbv0 true)
                (and (= size |0|) (= (= _lbv0 false) (> size |0|)))))
        (a!2 (= (= var_v4 true)
                (and (= size |0|) (= (= var_v4 false) (> size |0|)))))
        (a!3 (=> (= (slen _lbv7) var_u70)
                 (and (or (> var_u70 |0|) (= var_u70 |0|)) (= var_u70 _lbv1))))
        (a!4 (=> (= var_u71 (+ (slen _lbv7) 1)) (= (slen _lbv8) var_u71)))
        (a!5 (=> (= var_u72 (+ (slen _lbv7) 1)) (= (slen _lbv9) var_u72)))
        (a!6 (=> (= var_u73 (+ (slen Nil) 1)) (= (slen v) var_u73)))
        (a!7 (=> (= var_u75 (+ (slen Nil) 1)) (= (slen v) var_u75))))
    (and (= (slen Nil) 0)
         a!1
         a!2
         (= _lbv1 (- size 1))
         (or (> _lbv2 size1) (= _lbv2 size1))
         (or (> _lbv3 n) (= _lbv3 n))
         (or (> _lbv4 _lbv1) (= _lbv4 _lbv1))
         (or (> _lbv5 s) (= _lbv5 s))
         (or (> _lbv6 size) (= _lbv6 size))
         (> size size1)
         a!3
         a!4
         a!5
         a!6
         (= var_v4 false)
         a!2
         (= (slen Nil) 0)
         a!7))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (let ((a!1 (forall ((var_u76 Int))
             (=> (= (slen v) var_u76)
                 (and (or (> var_u76 |0|) (= var_u76 |0|)) (= var_u76 size))))))
  (not a!1)))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply Cons  (, n3 ), Nil )
 Finding Already seen tree for apply Cons  (, n3 ), _lbv7 )
 Typechecking apply Cons  (, n3 ), apply goal  (, apply subs  (, size ) ) )
 Against {v:int list | Forall 
 	 
 Key =u Value = int{ 
 	 Impl < (slen)(v) ==(u)
 	 
 	 Conj <c 
 Disj <d  u > 0
 	,   u = 0>d 
 	 , u = size >c  > }}
 Typechecking the Term apply Cons  (, n3 ), _lbv7 )
 Against {v:int list | Forall 
 	 
 Key =u Value = int{ 
 	 Impl < (slen)(v) ==(u)
 	 
 	 Conj <c 
 Disj <d  u > 0
 	,   u = 0>d 
 	 , u = size >c  > }}
 Argument n3 :: {var_v0:int | true} | true
 Argument _lbv7 :: {v:int list | Forall 
 	 
 Key =u Value = int{ 
 	 Impl < (slen)(v) ==(u)
 	 
 	 Conj <c 
 Disj <d  u > 0
 	,   u = 0>d 
 	 , u = _lbv1 >c  > }} | Forall 
 	 
 Key =u Value = int{ 
 	 Impl < (slen)(_lbv7) ==(u)
 	 
 	 Conj <c 
 Disj <d  u > 0
 	,   u = 0>d 
 	 , u = _lbv1 >c  > }
 AppType Type {v:int list | Forall 
 	 
 Key =u Value = int{ 
 	 Impl < (u) ==((slen)(_lbv7) + (1))
 	 (slen)(v) ==(u) > }}                                                                                                                                                                                          
# of Final Z3 expressions 14
 Final solver 
 (declare-sort T294 0)
(declare-fun |0| () Int)
(declare-fun slen (T294) Int)
(declare-fun v () T294)
(declare-fun _lbv7 () T294)
(declare-fun _lbv1 () Int)
(declare-fun size () Int)
(declare-fun var_v4 () Bool)
(declare-fun _lbv9 () T294)
(declare-fun _lbv8 () T294)
(declare-fun size1 () Int)
(declare-fun _lbv6 () Int)
(declare-fun s () Int)
(declare-fun _lbv5 () Int)
(declare-fun _lbv4 () Int)
(declare-fun n () Int)
(declare-fun _lbv3 () Int)
(declare-fun _lbv2 () Int)
(declare-fun _lbv0 () Bool)
(declare-fun Nil () T294)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u83 Int)
         (var_u82 Int)
         (var_u81 Int)
         (var_u80 Int)
         (var_u79 Int)
         (var_u78 Int)
         (var_u77 Int))
  (let ((a!1 (= (= _lbv0 true)
                (and (= size |0|) (= (= _lbv0 false) (> size |0|)))))
        (a!2 (= (= var_v4 true)
                (and (= size |0|) (= (= var_v4 false) (> size |0|)))))
        (a!3 (=> (= (slen _lbv7) var_u78)
                 (and (or (> var_u78 |0|) (= var_u78 |0|)) (= var_u78 _lbv1))))
        (a!4 (=> (= var_u79 (+ (slen _lbv7) 1)) (= (slen _lbv8) var_u79)))
        (a!5 (=> (= var_u80 (+ (slen _lbv7) 1)) (= (slen _lbv9) var_u80)))
        (a!6 (=> (= var_u81 (+ (slen _lbv7) 1)) (= (slen v) var_u81)))
        (a!7 (=> (= (slen _lbv7) var_u82)
                 (and (or (> var_u82 |0|) (= var_u82 |0|)) (= var_u82 _lbv1))))
        (a!8 (=> (= var_u83 (+ (slen _lbv7) 1)) (= (slen v) var_u83))))
    (and (= (slen Nil) 0)
         a!1
         a!2
         (= _lbv1 (- size 1))
         (or (> _lbv2 size1) (= _lbv2 size1))
         (or (> _lbv3 n) (= _lbv3 n))
         (or (> _lbv4 _lbv1) (= _lbv4 _lbv1))
         (or (> _lbv5 s) (= _lbv5 s))
         (or (> _lbv6 size) (= _lbv6 size))
         (> size size1)
         a!3
         a!4
         a!5
         a!6
         (= var_v4 false)
         a!2
         a!7
         a!8))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (let ((a!1 (forall ((var_u84 Int))
             (=> (= (slen v) var_u84)
                 (and (or (> var_u84 |0|) (= var_u84 |0|)) (= var_u84 size))))))
  (not a!1)))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
  Show *************** TypeChecking Succsessful {v:int list | Forall 
 	 
 Key =u Value = int{ 
 	 Impl < (u) ==((slen)(_lbv7) + (1))
 	 (slen)(v) ==(u) > }}
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 let _lbv10 = apply Cons  (, n3 ), _lbv7 )
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 Finding Already seen tree for apply Cons  (, _lbv1 ), Nil )
 Typechecking apply Cons  (, apply subs  (, size ) ), Nil )
 Against {v:int list | Forall 
 	 
 Key =u Value = int{ 
 	 Impl < (slen)(v) ==(u)
 	 
 	 Conj <c 
 Disj <d  u > 0
 	,   u = 0>d 
 	 , u = size >c  > }}
 Typechecking the Term apply Cons  (, _lbv1 ), Nil )
 Against {v:int list | Forall 
 	 
 Key =u Value = int{ 
 	 Impl < (slen)(v) ==(u)
 	 
 	 Conj <c 
 Disj <d  u > 0
 	,   u = 0>d 
 	 , u = size >c  > }}
 Argument _lbv1 :: {v:int | (v) ==((size) -- (1))} | (_lbv1) ==((size) -- (1))
 Argument Nil :: {v:int list | Forall 
 	 
 Key =u Value = int{ (slen)(v) ==(0) }} | Forall 
 	 
 Key =u Value = int{ (slen)(Nil) ==(0) }
 AppType Type {v:int list | Forall 
 	 
 Key =u Value = int{ 
 	 Impl < (u) ==((slen)(Nil) + (1))
 	 (slen)(v) ==(u) > }}                                                                                                                                                                         
# of Final Z3 expressions 12
 Final solver 
 (declare-sort T298 0)
(declare-fun |0| () Int)
(declare-fun slen (T298) Int)
(declare-fun v () T298)
(declare-fun Nil () T298)
(declare-fun size () Int)
(declare-fun _lbv1 () Int)
(declare-fun var_v4 () Bool)
(declare-fun _lbv10 () T298)
(declare-fun _lbv7 () T298)
(declare-fun _lbv9 () T298)
(declare-fun _lbv8 () T298)
(declare-fun size1 () Int)
(declare-fun _lbv6 () Int)
(declare-fun s () Int)
(declare-fun _lbv5 () Int)
(declare-fun _lbv4 () Int)
(declare-fun n () Int)
(declare-fun _lbv3 () Int)
(declare-fun _lbv2 () Int)
(declare-fun _lbv0 () Bool)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u92 Int)
         (var_u91 Int)
         (var_u90 Int)
         (var_u89 Int)
         (var_u88 Int)
         (var_u87 Int)
         (var_u86 Int)
         (var_u85 Int))
  (let ((a!1 (= (= _lbv0 true)
                (and (= size |0|) (= (= _lbv0 false) (> size |0|)))))
        (a!2 (= (= var_v4 true)
                (and (= size |0|) (= (= var_v4 false) (> size |0|)))))
        (a!3 (=> (= (slen _lbv7) var_u86)
                 (and (or (> var_u86 |0|) (= var_u86 |0|)) (= var_u86 _lbv1))))
        (a!4 (=> (= var_u87 (+ (slen _lbv7) 1)) (= (slen _lbv8) var_u87)))
        (a!5 (=> (= var_u88 (+ (slen _lbv7) 1)) (= (slen _lbv9) var_u88)))
        (a!6 (=> (= var_u89 (+ (slen _lbv7) 1)) (= (slen _lbv10) var_u89)))
        (a!7 (=> (= var_u90 (+ (slen Nil) 1)) (= (slen v) var_u90)))
        (a!8 (=> (= var_u92 (+ (slen Nil) 1)) (= (slen v) var_u92))))
    (and (= (slen Nil) 0)
         a!1
         a!2
         (= _lbv1 (- size 1))
         (or (> _lbv2 size1) (= _lbv2 size1))
         (or (> _lbv3 n) (= _lbv3 n))
         (or (> _lbv4 _lbv1) (= _lbv4 _lbv1))
         (or (> _lbv5 s) (= _lbv5 s))
         (or (> _lbv6 size) (= _lbv6 size))
         (> size size1)
         a!3
         a!4
         a!5
         a!6
         a!7
         (= var_v4 false)
         a!2
         (= _lbv1 (- size 1))
         (= (slen Nil) 0)
         a!8))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (let ((a!1 (forall ((var_u93 Int))
             (=> (= (slen v) var_u93)
                 (and (or (> var_u93 |0|) (= var_u93 |0|)) (= var_u93 size))))))
  (not a!1)))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply Cons  (, _lbv1 ), Nil )
 Finding Already seen tree for apply Cons  (, _lbv1 ), _lbv7 )
 Typechecking apply Cons  (, apply subs  (, size ) ), apply goal  (, apply subs  (, size ) ) )
 Against {v:int list | Forall 
 	 
 Key =u Value = int{ 
 	 Impl < (slen)(v) ==(u)
 	 
 	 Conj <c 
 Disj <d  u > 0
 	,   u = 0>d 
 	 , u = size >c  > }}
 Typechecking the Term apply Cons  (, _lbv1 ), _lbv7 )
 Against {v:int list | Forall 
 	 
 Key =u Value = int{ 
 	 Impl < (slen)(v) ==(u)
 	 
 	 Conj <c 
 Disj <d  u > 0
 	,   u = 0>d 
 	 , u = size >c  > }}
 Argument _lbv1 :: {v:int | (v) ==((size) -- (1))} | (_lbv1) ==((size) -- (1))
 Argument _lbv7 :: {v:int list | Forall 
 	 
 Key =u Value = int{ 
 	 Impl < (slen)(v) ==(u)
 	 
 	 Conj <c 
 Disj <d  u > 0
 	,   u = 0>d 
 	 , u = _lbv1 >c  > }} | Forall 
 	 
 Key =u Value = int{ 
 	 Impl < (slen)(_lbv7) ==(u)
 	 
 	 Conj <c 
 Disj <d  u > 0
 	,   u = 0>d 
 	 , u = _lbv1 >c  > }
 AppType Type {v:int list | Forall 
 	 
 Key =u Value = int{ 
 	 Impl < (u) ==((slen)(_lbv7) + (1))
 	 (slen)(v) ==(u) > }}                                                                                                                                                                                          
# of Final Z3 expressions 14
 Final solver 
 (declare-sort T302 0)
(declare-fun |0| () Int)
(declare-fun slen (T302) Int)
(declare-fun v () T302)
(declare-fun _lbv7 () T302)
(declare-fun _lbv1 () Int)
(declare-fun size () Int)
(declare-fun var_v4 () Bool)
(declare-fun _lbv10 () T302)
(declare-fun _lbv9 () T302)
(declare-fun _lbv8 () T302)
(declare-fun size1 () Int)
(declare-fun _lbv6 () Int)
(declare-fun s () Int)
(declare-fun _lbv5 () Int)
(declare-fun _lbv4 () Int)
(declare-fun n () Int)
(declare-fun _lbv3 () Int)
(declare-fun _lbv2 () Int)
(declare-fun _lbv0 () Bool)
(declare-fun Nil () T302)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u101 Int)
         (var_u100 Int)
         (var_u99 Int)
         (var_u98 Int)
         (var_u97 Int)
         (var_u96 Int)
         (var_u95 Int)
         (var_u94 Int))
  (let ((a!1 (= (= _lbv0 true)
                (and (= size |0|) (= (= _lbv0 false) (> size |0|)))))
        (a!2 (= (= var_v4 true)
                (and (= size |0|) (= (= var_v4 false) (> size |0|)))))
        (a!3 (=> (= (slen _lbv7) var_u95)
                 (and (or (> var_u95 |0|) (= var_u95 |0|)) (= var_u95 _lbv1))))
        (a!4 (=> (= var_u96 (+ (slen _lbv7) 1)) (= (slen _lbv8) var_u96)))
        (a!5 (=> (= var_u97 (+ (slen _lbv7) 1)) (= (slen _lbv9) var_u97)))
        (a!6 (=> (= var_u98 (+ (slen _lbv7) 1)) (= (slen _lbv10) var_u98)))
        (a!7 (=> (= var_u99 (+ (slen _lbv7) 1)) (= (slen v) var_u99)))
        (a!8 (=> (= (slen _lbv7) var_u100)
                 (and (or (> var_u100 |0|) (= var_u100 |0|)) (= var_u100 _lbv1))))
        (a!9 (=> (= var_u101 (+ (slen _lbv7) 1)) (= (slen v) var_u101))))
    (and (= (slen Nil) 0)
         a!1
         a!2
         (= _lbv1 (- size 1))
         (or (> _lbv2 size1) (= _lbv2 size1))
         (or (> _lbv3 n) (= _lbv3 n))
         (or (> _lbv4 _lbv1) (= _lbv4 _lbv1))
         (or (> _lbv5 s) (= _lbv5 s))
         (or (> _lbv6 size) (= _lbv6 size))
         (> size size1)
         a!3
         a!4
         a!5
         a!6
         a!7
         (= var_v4 false)
         a!2
         (= _lbv1 (- size 1))
         a!8
         a!9))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (let ((a!1 (forall ((var_u102 Int))
             (=> (= (slen v) var_u102)
                 (and (or (> var_u102 |0|) (= var_u102 |0|)) (= var_u102 size))))))
  (not a!1)))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
  Show *************** TypeChecking Succsessful {v:int list | Forall 
 	 
 Key =u Value = int{ 
 	 Impl < (u) ==((slen)(_lbv7) + (1))
 	 (slen)(v) ==(u) > }}
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 let _lbv11 = apply Cons  (, _lbv1 ), _lbv7 )
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 Finding Already seen tree for apply Cons  (, s ), Nil )
 Typechecking apply Cons  (, s ), Nil )
 Against {v:int list | Forall 
 	 
 Key =u Value = int{ 
 	 Impl < (slen)(v) ==(u)
 	 
 	 Conj <c 
 Disj <d  u > 0
 	,   u = 0>d 
 	 , u = size >c  > }}
 Typechecking the Term apply Cons  (, s ), Nil )
 Against {v:int list | Forall 
 	 
 Key =u Value = int{ 
 	 Impl < (slen)(v) ==(u)
 	 
 	 Conj <c 
 Disj <d  u > 0
 	,   u = 0>d 
 	 , u = size >c  > }}
 Argument s :: {var_v1:int | true} | true
 Argument Nil :: {v:int list | Forall 
 	 
 Key =u Value = int{ (slen)(v) ==(0) }} | Forall 
 	 
 Key =u Value = int{ (slen)(Nil) ==(0) }
 AppType Type {v:int list | Forall 
 	 
 Key =u Value = int{ 
 	 Impl < (u) ==((slen)(Nil) + (1))
 	 (slen)(v) ==(u) > }}                                                                                                                                                                         
# of Final Z3 expressions 12
 Final solver 
 (declare-sort T306 0)
(declare-fun |0| () Int)
(declare-fun slen (T306) Int)
(declare-fun v () T306)
(declare-fun Nil () T306)
(declare-fun size () Int)
(declare-fun var_v4 () Bool)
(declare-fun _lbv11 () T306)
(declare-fun _lbv7 () T306)
(declare-fun _lbv10 () T306)
(declare-fun _lbv9 () T306)
(declare-fun _lbv8 () T306)
(declare-fun _lbv1 () Int)
(declare-fun size1 () Int)
(declare-fun _lbv6 () Int)
(declare-fun s () Int)
(declare-fun _lbv5 () Int)
(declare-fun _lbv4 () Int)
(declare-fun n () Int)
(declare-fun _lbv3 () Int)
(declare-fun _lbv2 () Int)
(declare-fun _lbv0 () Bool)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u111 Int)
         (var_u110 Int)
         (var_u109 Int)
         (var_u108 Int)
         (var_u107 Int)
         (var_u106 Int)
         (var_u105 Int)
         (var_u104 Int)
         (var_u103 Int))
  (let ((a!1 (= (= _lbv0 true)
                (and (= size |0|) (= (= _lbv0 false) (> size |0|)))))
        (a!2 (= (= var_v4 true)
                (and (= size |0|) (= (= var_v4 false) (> size |0|)))))
        (a!3 (=> (= (slen _lbv7) var_u104)
                 (and (or (> var_u104 |0|) (= var_u104 |0|)) (= var_u104 _lbv1))))
        (a!4 (=> (= var_u105 (+ (slen _lbv7) 1)) (= (slen _lbv8) var_u105)))
        (a!5 (=> (= var_u106 (+ (slen _lbv7) 1)) (= (slen _lbv9) var_u106)))
        (a!6 (=> (= var_u107 (+ (slen _lbv7) 1)) (= (slen _lbv10) var_u107)))
        (a!7 (=> (= var_u108 (+ (slen _lbv7) 1)) (= (slen _lbv11) var_u108)))
        (a!8 (=> (= var_u109 (+ (slen Nil) 1)) (= (slen v) var_u109)))
        (a!9 (=> (= var_u111 (+ (slen Nil) 1)) (= (slen v) var_u111))))
    (and (= (slen Nil) 0)
         a!1
         a!2
         (= _lbv1 (- size 1))
         (or (> _lbv2 size1) (= _lbv2 size1))
         (or (> _lbv3 n) (= _lbv3 n))
         (or (> _lbv4 _lbv1) (= _lbv4 _lbv1))
         (or (> _lbv5 s) (= _lbv5 s))
         (or (> _lbv6 size) (= _lbv6 size))
         (> size size1)
         a!3
         a!4
         a!5
         a!6
         a!7
         a!8
         (= var_v4 false)
         a!2
         (= (slen Nil) 0)
         a!9))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (let ((a!1 (forall ((var_u112 Int))
             (=> (= (slen v) var_u112)
                 (and (or (> var_u112 |0|) (= var_u112 |0|)) (= var_u112 size))))))
  (not a!1)))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply Cons  (, s ), Nil )
 Finding Already seen tree for apply Cons  (, s ), _lbv7 )
 Typechecking apply Cons  (, s ), apply goal  (, apply subs  (, size ) ) )
 Against {v:int list | Forall 
 	 
 Key =u Value = int{ 
 	 Impl < (slen)(v) ==(u)
 	 
 	 Conj <c 
 Disj <d  u > 0
 	,   u = 0>d 
 	 , u = size >c  > }}
 Typechecking the Term apply Cons  (, s ), _lbv7 )
 Against {v:int list | Forall 
 	 
 Key =u Value = int{ 
 	 Impl < (slen)(v) ==(u)
 	 
 	 Conj <c 
 Disj <d  u > 0
 	,   u = 0>d 
 	 , u = size >c  > }}
 Argument s :: {var_v1:int | true} | true
 Argument _lbv7 :: {v:int list | Forall 
 	 
 Key =u Value = int{ 
 	 Impl < (slen)(v) ==(u)
 	 
 	 Conj <c 
 Disj <d  u > 0
 	,   u = 0>d 
 	 , u = _lbv1 >c  > }} | Forall 
 	 
 Key =u Value = int{ 
 	 Impl < (slen)(_lbv7) ==(u)
 	 
 	 Conj <c 
 Disj <d  u > 0
 	,   u = 0>d 
 	 , u = _lbv1 >c  > }
 AppType Type {v:int list | Forall 
 	 
 Key =u Value = int{ 
 	 Impl < (u) ==((slen)(_lbv7) + (1))
 	 (slen)(v) ==(u) > }}                                                                                                                                                                                          
# of Final Z3 expressions 14
 Final solver 
 (declare-sort T310 0)
(declare-fun |0| () Int)
(declare-fun slen (T310) Int)
(declare-fun v () T310)
(declare-fun _lbv7 () T310)
(declare-fun _lbv1 () Int)
(declare-fun size () Int)
(declare-fun var_v4 () Bool)
(declare-fun _lbv11 () T310)
(declare-fun _lbv10 () T310)
(declare-fun _lbv9 () T310)
(declare-fun _lbv8 () T310)
(declare-fun size1 () Int)
(declare-fun _lbv6 () Int)
(declare-fun s () Int)
(declare-fun _lbv5 () Int)
(declare-fun _lbv4 () Int)
(declare-fun n () Int)
(declare-fun _lbv3 () Int)
(declare-fun _lbv2 () Int)
(declare-fun _lbv0 () Bool)
(declare-fun Nil () T310)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u121 Int)
         (var_u120 Int)
         (var_u119 Int)
         (var_u118 Int)
         (var_u117 Int)
         (var_u116 Int)
         (var_u115 Int)
         (var_u114 Int)
         (var_u113 Int))
  (let ((a!1 (= (= _lbv0 true)
                (and (= size |0|) (= (= _lbv0 false) (> size |0|)))))
        (a!2 (= (= var_v4 true)
                (and (= size |0|) (= (= var_v4 false) (> size |0|)))))
        (a!3 (=> (= (slen _lbv7) var_u114)
                 (and (or (> var_u114 |0|) (= var_u114 |0|)) (= var_u114 _lbv1))))
        (a!4 (=> (= var_u115 (+ (slen _lbv7) 1)) (= (slen _lbv8) var_u115)))
        (a!5 (=> (= var_u116 (+ (slen _lbv7) 1)) (= (slen _lbv9) var_u116)))
        (a!6 (=> (= var_u117 (+ (slen _lbv7) 1)) (= (slen _lbv10) var_u117)))
        (a!7 (=> (= var_u118 (+ (slen _lbv7) 1)) (= (slen _lbv11) var_u118)))
        (a!8 (=> (= var_u119 (+ (slen _lbv7) 1)) (= (slen v) var_u119)))
        (a!9 (=> (= (slen _lbv7) var_u120)
                 (and (or (> var_u120 |0|) (= var_u120 |0|)) (= var_u120 _lbv1))))
        (a!10 (=> (= var_u121 (+ (slen _lbv7) 1)) (= (slen v) var_u121))))
    (and (= (slen Nil) 0)
         a!1
         a!2
         (= _lbv1 (- size 1))
         (or (> _lbv2 size1) (= _lbv2 size1))
         (or (> _lbv3 n) (= _lbv3 n))
         (or (> _lbv4 _lbv1) (= _lbv4 _lbv1))
         (or (> _lbv5 s) (= _lbv5 s))
         (or (> _lbv6 size) (= _lbv6 size))
         (> size size1)
         a!3
         a!4
         a!5
         a!6
         a!7
         a!8
         (= var_v4 false)
         a!2
         a!9
         a!10))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (let ((a!1 (forall ((var_u122 Int))
             (=> (= (slen v) var_u122)
                 (and (or (> var_u122 |0|) (= var_u122 |0|)) (= var_u122 size))))))
  (not a!1)))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
  Show *************** TypeChecking Succsessful {v:int list | Forall 
 	 
 Key =u Value = int{ 
 	 Impl < (u) ==((slen)(_lbv7) + (1))
 	 (slen)(v) ==(u) > }}
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 let _lbv12 = apply Cons  (, s ), _lbv7 )
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 Finding Already seen tree for apply Cons  (, size ), Nil )
 Typechecking apply Cons  (, size ), Nil )
 Against {v:int list | Forall 
 	 
 Key =u Value = int{ 
 	 Impl < (slen)(v) ==(u)
 	 
 	 Conj <c 
 Disj <d  u > 0
 	,   u = 0>d 
 	 , u = size >c  > }}
 Typechecking the Term apply Cons  (, size ), Nil )
 Against {v:int list | Forall 
 	 
 Key =u Value = int{ 
 	 Impl < (slen)(v) ==(u)
 	 
 	 Conj <c 
 Disj <d  u > 0
 	,   u = 0>d 
 	 , u = size >c  > }}
 Argument size :: {v:int | true} | true
 Argument Nil :: {v:int list | Forall 
 	 
 Key =u Value = int{ (slen)(v) ==(0) }} | Forall 
 	 
 Key =u Value = int{ (slen)(Nil) ==(0) }
 AppType Type {v:int list | Forall 
 	 
 Key =u Value = int{ 
 	 Impl < (u) ==((slen)(Nil) + (1))
 	 (slen)(v) ==(u) > }}                                                                                                                                                                         
# of Final Z3 expressions 12
 Final solver 
 (declare-sort T314 0)
(declare-fun |0| () Int)
(declare-fun slen (T314) Int)
(declare-fun v () T314)
(declare-fun Nil () T314)
(declare-fun size () Int)
(declare-fun var_v4 () Bool)
(declare-fun _lbv12 () T314)
(declare-fun _lbv7 () T314)
(declare-fun _lbv11 () T314)
(declare-fun _lbv10 () T314)
(declare-fun _lbv9 () T314)
(declare-fun _lbv8 () T314)
(declare-fun _lbv1 () Int)
(declare-fun size1 () Int)
(declare-fun _lbv6 () Int)
(declare-fun s () Int)
(declare-fun _lbv5 () Int)
(declare-fun _lbv4 () Int)
(declare-fun n () Int)
(declare-fun _lbv3 () Int)
(declare-fun _lbv2 () Int)
(declare-fun _lbv0 () Bool)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u132 Int)
         (var_u131 Int)
         (var_u130 Int)
         (var_u129 Int)
         (var_u128 Int)
         (var_u127 Int)
         (var_u126 Int)
         (var_u125 Int)
         (var_u124 Int)
         (var_u123 Int))
  (let ((a!1 (= (= _lbv0 true)
                (and (= size |0|) (= (= _lbv0 false) (> size |0|)))))
        (a!2 (= (= var_v4 true)
                (and (= size |0|) (= (= var_v4 false) (> size |0|)))))
        (a!3 (=> (= (slen _lbv7) var_u124)
                 (and (or (> var_u124 |0|) (= var_u124 |0|)) (= var_u124 _lbv1))))
        (a!4 (=> (= var_u125 (+ (slen _lbv7) 1)) (= (slen _lbv8) var_u125)))
        (a!5 (=> (= var_u126 (+ (slen _lbv7) 1)) (= (slen _lbv9) var_u126)))
        (a!6 (=> (= var_u127 (+ (slen _lbv7) 1)) (= (slen _lbv10) var_u127)))
        (a!7 (=> (= var_u128 (+ (slen _lbv7) 1)) (= (slen _lbv11) var_u128)))
        (a!8 (=> (= var_u129 (+ (slen _lbv7) 1)) (= (slen _lbv12) var_u129)))
        (a!9 (=> (= var_u130 (+ (slen Nil) 1)) (= (slen v) var_u130)))
        (a!10 (=> (= var_u132 (+ (slen Nil) 1)) (= (slen v) var_u132))))
    (and (= (slen Nil) 0)
         a!1
         a!2
         (= _lbv1 (- size 1))
         (or (> _lbv2 size1) (= _lbv2 size1))
         (or (> _lbv3 n) (= _lbv3 n))
         (or (> _lbv4 _lbv1) (= _lbv4 _lbv1))
         (or (> _lbv5 s) (= _lbv5 s))
         (or (> _lbv6 size) (= _lbv6 size))
         (> size size1)
         a!3
         a!4
         a!5
         a!6
         a!7
         a!8
         a!9
         (= var_v4 false)
         a!2
         (= (slen Nil) 0)
         a!10))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (let ((a!1 (forall ((var_u133 Int))
             (=> (= (slen v) var_u133)
                 (and (or (> var_u133 |0|) (= var_u133 |0|)) (= var_u133 size))))))
  (not a!1)))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply Cons  (, size ), Nil )
 Finding Already seen tree for apply Cons  (, size ), _lbv7 )
 Typechecking apply Cons  (, size ), apply goal  (, apply subs  (, size ) ) )
 Against {v:int list | Forall 
 	 
 Key =u Value = int{ 
 	 Impl < (slen)(v) ==(u)
 	 
 	 Conj <c 
 Disj <d  u > 0
 	,   u = 0>d 
 	 , u = size >c  > }}
 Typechecking the Term apply Cons  (, size ), _lbv7 )
 Against {v:int list | Forall 
 	 
 Key =u Value = int{ 
 	 Impl < (slen)(v) ==(u)
 	 
 	 Conj <c 
 Disj <d  u > 0
 	,   u = 0>d 
 	 , u = size >c  > }}
 Argument size :: {v:int | true} | true
 Argument _lbv7 :: {v:int list | Forall 
 	 
 Key =u Value = int{ 
 	 Impl < (slen)(v) ==(u)
 	 
 	 Conj <c 
 Disj <d  u > 0
 	,   u = 0>d 
 	 , u = _lbv1 >c  > }} | Forall 
 	 
 Key =u Value = int{ 
 	 Impl < (slen)(_lbv7) ==(u)
 	 
 	 Conj <c 
 Disj <d  u > 0
 	,   u = 0>d 
 	 , u = _lbv1 >c  > }
 AppType Type {v:int list | Forall 
 	 
 Key =u Value = int{ 
 	 Impl < (u) ==((slen)(_lbv7) + (1))
 	 (slen)(v) ==(u) > }}                                                                                                                                                                                          
# of Final Z3 expressions 14
 Final solver 
 (declare-sort T318 0)
(declare-fun |0| () Int)
(declare-fun slen (T318) Int)
(declare-fun v () T318)
(declare-fun _lbv7 () T318)
(declare-fun _lbv1 () Int)
(declare-fun size () Int)
(declare-fun var_v4 () Bool)
(declare-fun _lbv12 () T318)
(declare-fun _lbv11 () T318)
(declare-fun _lbv10 () T318)
(declare-fun _lbv9 () T318)
(declare-fun _lbv8 () T318)
(declare-fun size1 () Int)
(declare-fun _lbv6 () Int)
(declare-fun s () Int)
(declare-fun _lbv5 () Int)
(declare-fun _lbv4 () Int)
(declare-fun n () Int)
(declare-fun _lbv3 () Int)
(declare-fun _lbv2 () Int)
(declare-fun _lbv0 () Bool)
(declare-fun Nil () T318)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u143 Int)
         (var_u142 Int)
         (var_u141 Int)
         (var_u140 Int)
         (var_u139 Int)
         (var_u138 Int)
         (var_u137 Int)
         (var_u136 Int)
         (var_u135 Int)
         (var_u134 Int))
  (let ((a!1 (= (= _lbv0 true)
                (and (= size |0|) (= (= _lbv0 false) (> size |0|)))))
        (a!2 (= (= var_v4 true)
                (and (= size |0|) (= (= var_v4 false) (> size |0|)))))
        (a!3 (=> (= (slen _lbv7) var_u135)
                 (and (or (> var_u135 |0|) (= var_u135 |0|)) (= var_u135 _lbv1))))
        (a!4 (=> (= var_u136 (+ (slen _lbv7) 1)) (= (slen _lbv8) var_u136)))
        (a!5 (=> (= var_u137 (+ (slen _lbv7) 1)) (= (slen _lbv9) var_u137)))
        (a!6 (=> (= var_u138 (+ (slen _lbv7) 1)) (= (slen _lbv10) var_u138)))
        (a!7 (=> (= var_u139 (+ (slen _lbv7) 1)) (= (slen _lbv11) var_u139)))
        (a!8 (=> (= var_u140 (+ (slen _lbv7) 1)) (= (slen _lbv12) var_u140)))
        (a!9 (=> (= var_u141 (+ (slen _lbv7) 1)) (= (slen v) var_u141)))
        (a!10 (=> (= (slen _lbv7) var_u142)
                  (and (or (> var_u142 |0|) (= var_u142 |0|))
                       (= var_u142 _lbv1))))
        (a!11 (=> (= var_u143 (+ (slen _lbv7) 1)) (= (slen v) var_u143))))
    (and (= (slen Nil) 0)
         a!1
         a!2
         (= _lbv1 (- size 1))
         (or (> _lbv2 size1) (= _lbv2 size1))
         (or (> _lbv3 n) (= _lbv3 n))
         (or (> _lbv4 _lbv1) (= _lbv4 _lbv1))
         (or (> _lbv5 s) (= _lbv5 s))
         (or (> _lbv6 size) (= _lbv6 size))
         (> size size1)
         a!3
         a!4
         a!5
         a!6
         a!7
         a!8
         a!9
         (= var_v4 false)
         a!2
         a!10
         a!11))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (let ((a!1 (forall ((var_u144 Int))
             (=> (= (slen v) var_u144)
                 (and (or (> var_u144 |0|) (= var_u144 |0|)) (= var_u144 size))))))
  (not a!1)))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
  Show *************** TypeChecking Succsessful {v:int list | Forall 
 	 
 Key =u Value = int{ 
 	 Impl < (u) ==((slen)(_lbv7) + (1))
 	 (slen)(v) ==(u) > }}
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 let _lbv13 = apply Cons  (, size ), _lbv7 )
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 Finding Already seen tree for apply Cons  (, _lbv6 ), Nil )
 Typechecking apply Cons  (, apply gt_eq_int_gen  (, size ) ), Nil )
 Against {v:int list | Forall 
 	 
 Key =u Value = int{ 
 	 Impl < (slen)(v) ==(u)
 	 
 	 Conj <c 
 Disj <d  u > 0
 	,   u = 0>d 
 	 , u = size >c  > }}
 Typechecking the Term apply Cons  (, _lbv6 ), Nil )
 Against {v:int list | Forall 
 	 
 Key =u Value = int{ 
 	 Impl < (slen)(v) ==(u)
 	 
 	 Conj <c 
 Disj <d  u > 0
 	,   u = 0>d 
 	 , u = size >c  > }}
 Argument _lbv6 :: {v:int | 
 Disj <d  v > size
 	,   v = size>d } | 
 Disj <d  _lbv6 > size
 	,   _lbv6 = size>d 
 Argument Nil :: {v:int list | Forall 
 	 
 Key =u Value = int{ (slen)(v) ==(0) }} | Forall 
 	 
 Key =u Value = int{ (slen)(Nil) ==(0) }
 AppType Type {v:int list | Forall 
 	 
 Key =u Value = int{ 
 	 Impl < (u) ==((slen)(Nil) + (1))
 	 (slen)(v) ==(u) > }}                                                                                                                                                                                    
# of Final Z3 expressions 12
 Final solver 
 (declare-sort T322 0)
(declare-fun |0| () Int)
(declare-fun slen (T322) Int)
(declare-fun v () T322)
(declare-fun Nil () T322)
(declare-fun size () Int)
(declare-fun _lbv6 () Int)
(declare-fun var_v4 () Bool)
(declare-fun _lbv13 () T322)
(declare-fun _lbv7 () T322)
(declare-fun _lbv12 () T322)
(declare-fun _lbv11 () T322)
(declare-fun _lbv10 () T322)
(declare-fun _lbv9 () T322)
(declare-fun _lbv8 () T322)
(declare-fun _lbv1 () Int)
(declare-fun size1 () Int)
(declare-fun s () Int)
(declare-fun _lbv5 () Int)
(declare-fun _lbv4 () Int)
(declare-fun n () Int)
(declare-fun _lbv3 () Int)
(declare-fun _lbv2 () Int)
(declare-fun _lbv0 () Bool)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u155 Int)
         (var_u154 Int)
         (var_u153 Int)
         (var_u152 Int)
         (var_u151 Int)
         (var_u150 Int)
         (var_u149 Int)
         (var_u148 Int)
         (var_u147 Int)
         (var_u146 Int)
         (var_u145 Int))
  (let ((a!1 (= (= _lbv0 true)
                (and (= size |0|) (= (= _lbv0 false) (> size |0|)))))
        (a!2 (= (= var_v4 true)
                (and (= size |0|) (= (= var_v4 false) (> size |0|)))))
        (a!3 (=> (= (slen _lbv7) var_u146)
                 (and (or (> var_u146 |0|) (= var_u146 |0|)) (= var_u146 _lbv1))))
        (a!4 (=> (= var_u147 (+ (slen _lbv7) 1)) (= (slen _lbv8) var_u147)))
        (a!5 (=> (= var_u148 (+ (slen _lbv7) 1)) (= (slen _lbv9) var_u148)))
        (a!6 (=> (= var_u149 (+ (slen _lbv7) 1)) (= (slen _lbv10) var_u149)))
        (a!7 (=> (= var_u150 (+ (slen _lbv7) 1)) (= (slen _lbv11) var_u150)))
        (a!8 (=> (= var_u151 (+ (slen _lbv7) 1)) (= (slen _lbv12) var_u151)))
        (a!9 (=> (= var_u152 (+ (slen _lbv7) 1)) (= (slen _lbv13) var_u152)))
        (a!10 (=> (= var_u153 (+ (slen Nil) 1)) (= (slen v) var_u153)))
        (a!11 (=> (= var_u155 (+ (slen Nil) 1)) (= (slen v) var_u155))))
    (and (= (slen Nil) 0)
         a!1
         a!2
         (= _lbv1 (- size 1))
         (or (> _lbv2 size1) (= _lbv2 size1))
         (or (> _lbv3 n) (= _lbv3 n))
         (or (> _lbv4 _lbv1) (= _lbv4 _lbv1))
         (or (> _lbv5 s) (= _lbv5 s))
         (or (> _lbv6 size) (= _lbv6 size))
         (> size size1)
         a!3
         a!4
         a!5
         a!6
         a!7
         a!8
         a!9
         a!10
         (= var_v4 false)
         a!2
         (or (> _lbv6 size) (= _lbv6 size))
         (= (slen Nil) 0)
         a!11))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (let ((a!1 (forall ((var_u156 Int))
             (=> (= (slen v) var_u156)
                 (and (or (> var_u156 |0|) (= var_u156 |0|)) (= var_u156 size))))))
  (not a!1)))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply Cons  (, _lbv6 ), Nil )
 Finding Already seen tree for apply Cons  (, _lbv6 ), _lbv7 )
 Typechecking apply Cons  (, apply gt_eq_int_gen  (, size ) ), apply goal  (, apply subs  (, size ) ) )
 Against {v:int list | Forall 
 	 
 Key =u Value = int{ 
 	 Impl < (slen)(v) ==(u)
 	 
 	 Conj <c 
 Disj <d  u > 0
 	,   u = 0>d 
 	 , u = size >c  > }}
 Typechecking the Term apply Cons  (, _lbv6 ), _lbv7 )
 Against {v:int list | Forall 
 	 
 Key =u Value = int{ 
 	 Impl < (slen)(v) ==(u)
 	 
 	 Conj <c 
 Disj <d  u > 0
 	,   u = 0>d 
 	 , u = size >c  > }}
 Argument _lbv6 :: {v:int | 
 Disj <d  v > size
 	,   v = size>d } | 
 Disj <d  _lbv6 > size
 	,   _lbv6 = size>d 
 Argument _lbv7 :: {v:int list | Forall 
 	 
 Key =u Value = int{ 
 	 Impl < (slen)(v) ==(u)
 	 
 	 Conj <c 
 Disj <d  u > 0
 	,   u = 0>d 
 	 , u = _lbv1 >c  > }} | Forall 
 	 
 Key =u Value = int{ 
 	 Impl < (slen)(_lbv7) ==(u)
 	 
 	 Conj <c 
 Disj <d  u > 0
 	,   u = 0>d 
 	 , u = _lbv1 >c  > }
 AppType Type {v:int list | Forall 
 	 
 Key =u Value = int{ 
 	 Impl < (u) ==((slen)(_lbv7) + (1))
 	 (slen)(v) ==(u) > }}                                                                                                                                                                                                     
# of Final Z3 expressions 14
 Final solver 
 (declare-sort T326 0)
(declare-fun |0| () Int)
(declare-fun slen (T326) Int)
(declare-fun v () T326)
(declare-fun _lbv7 () T326)
(declare-fun _lbv1 () Int)
(declare-fun size () Int)
(declare-fun _lbv6 () Int)
(declare-fun var_v4 () Bool)
(declare-fun _lbv13 () T326)
(declare-fun _lbv12 () T326)
(declare-fun _lbv11 () T326)
(declare-fun _lbv10 () T326)
(declare-fun _lbv9 () T326)
(declare-fun _lbv8 () T326)
(declare-fun size1 () Int)
(declare-fun s () Int)
(declare-fun _lbv5 () Int)
(declare-fun _lbv4 () Int)
(declare-fun n () Int)
(declare-fun _lbv3 () Int)
(declare-fun _lbv2 () Int)
(declare-fun _lbv0 () Bool)
(declare-fun Nil () T326)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u167 Int)
         (var_u166 Int)
         (var_u165 Int)
         (var_u164 Int)
         (var_u163 Int)
         (var_u162 Int)
         (var_u161 Int)
         (var_u160 Int)
         (var_u159 Int)
         (var_u158 Int)
         (var_u157 Int))
  (let ((a!1 (= (= _lbv0 true)
                (and (= size |0|) (= (= _lbv0 false) (> size |0|)))))
        (a!2 (= (= var_v4 true)
                (and (= size |0|) (= (= var_v4 false) (> size |0|)))))
        (a!3 (=> (= (slen _lbv7) var_u158)
                 (and (or (> var_u158 |0|) (= var_u158 |0|)) (= var_u158 _lbv1))))
        (a!4 (=> (= var_u159 (+ (slen _lbv7) 1)) (= (slen _lbv8) var_u159)))
        (a!5 (=> (= var_u160 (+ (slen _lbv7) 1)) (= (slen _lbv9) var_u160)))
        (a!6 (=> (= var_u161 (+ (slen _lbv7) 1)) (= (slen _lbv10) var_u161)))
        (a!7 (=> (= var_u162 (+ (slen _lbv7) 1)) (= (slen _lbv11) var_u162)))
        (a!8 (=> (= var_u163 (+ (slen _lbv7) 1)) (= (slen _lbv12) var_u163)))
        (a!9 (=> (= var_u164 (+ (slen _lbv7) 1)) (= (slen _lbv13) var_u164)))
        (a!10 (=> (= var_u165 (+ (slen _lbv7) 1)) (= (slen v) var_u165)))
        (a!11 (=> (= (slen _lbv7) var_u166)
                  (and (or (> var_u166 |0|) (= var_u166 |0|))
                       (= var_u166 _lbv1))))
        (a!12 (=> (= var_u167 (+ (slen _lbv7) 1)) (= (slen v) var_u167))))
    (and (= (slen Nil) 0)
         a!1
         a!2
         (= _lbv1 (- size 1))
         (or (> _lbv2 size1) (= _lbv2 size1))
         (or (> _lbv3 n) (= _lbv3 n))
         (or (> _lbv4 _lbv1) (= _lbv4 _lbv1))
         (or (> _lbv5 s) (= _lbv5 s))
         (or (> _lbv6 size) (= _lbv6 size))
         (> size size1)
         a!3
         a!4
         a!5
         a!6
         a!7
         a!8
         a!9
         a!10
         (= var_v4 false)
         a!2
         (or (> _lbv6 size) (= _lbv6 size))
         a!11
         a!12))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (let ((a!1 (forall ((var_u168 Int))
             (=> (= (slen v) var_u168)
                 (and (or (> var_u168 |0|) (= var_u168 |0|)) (= var_u168 size))))))
  (not a!1)))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
  Show *************** TypeChecking Succsessful {v:int list | Forall 
 	 
 Key =u Value = int{ 
 	 Impl < (u) ==((slen)(_lbv7) + (1))
 	 (slen)(v) ==(u) > }}
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 let _lbv14 = apply Cons  (, _lbv6 ), _lbv7 )
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 Finding Already seen tree for apply Cons  (, _lbv5 ), Nil )
 Typechecking apply Cons  (, apply gt_eq_int_gen  (, s ) ), Nil )
 Against {v:int list | Forall 
 	 
 Key =u Value = int{ 
 	 Impl < (slen)(v) ==(u)
 	 
 	 Conj <c 
 Disj <d  u > 0
 	,   u = 0>d 
 	 , u = size >c  > }}
 Typechecking the Term apply Cons  (, _lbv5 ), Nil )
 Against {v:int list | Forall 
 	 
 Key =u Value = int{ 
 	 Impl < (slen)(v) ==(u)
 	 
 	 Conj <c 
 Disj <d  u > 0
 	,   u = 0>d 
 	 , u = size >c  > }}
 Argument _lbv5 :: {v:int | 
 Disj <d  v > s
 	,   v = s>d } | 
 Disj <d  _lbv5 > s
 	,   _lbv5 = s>d 
 Argument Nil :: {v:int list | Forall 
 	 
 Key =u Value = int{ (slen)(v) ==(0) }} | Forall 
 	 
 Key =u Value = int{ (slen)(Nil) ==(0) }
 AppType Type {v:int list | Forall 
 	 
 Key =u Value = int{ 
 	 Impl < (u) ==((slen)(Nil) + (1))
 	 (slen)(v) ==(u) > }}                                                                                                                                                                                    
# of Final Z3 expressions 12
 Final solver 
 (declare-sort T330 0)
(declare-fun |0| () Int)
(declare-fun slen (T330) Int)
(declare-fun v () T330)
(declare-fun Nil () T330)
(declare-fun s () Int)
(declare-fun _lbv5 () Int)
(declare-fun size () Int)
(declare-fun var_v4 () Bool)
(declare-fun _lbv14 () T330)
(declare-fun _lbv7 () T330)
(declare-fun _lbv13 () T330)
(declare-fun _lbv12 () T330)
(declare-fun _lbv11 () T330)
(declare-fun _lbv10 () T330)
(declare-fun _lbv9 () T330)
(declare-fun _lbv8 () T330)
(declare-fun _lbv1 () Int)
(declare-fun size1 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv4 () Int)
(declare-fun n () Int)
(declare-fun _lbv3 () Int)
(declare-fun _lbv2 () Int)
(declare-fun _lbv0 () Bool)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u180 Int)
         (var_u179 Int)
         (var_u178 Int)
         (var_u177 Int)
         (var_u176 Int)
         (var_u175 Int)
         (var_u174 Int)
         (var_u173 Int)
         (var_u172 Int)
         (var_u171 Int)
         (var_u170 Int)
         (var_u169 Int))
  (let ((a!1 (= (= _lbv0 true)
                (and (= size |0|) (= (= _lbv0 false) (> size |0|)))))
        (a!2 (= (= var_v4 true)
                (and (= size |0|) (= (= var_v4 false) (> size |0|)))))
        (a!3 (=> (= (slen _lbv7) var_u170)
                 (and (or (> var_u170 |0|) (= var_u170 |0|)) (= var_u170 _lbv1))))
        (a!4 (=> (= var_u171 (+ (slen _lbv7) 1)) (= (slen _lbv8) var_u171)))
        (a!5 (=> (= var_u172 (+ (slen _lbv7) 1)) (= (slen _lbv9) var_u172)))
        (a!6 (=> (= var_u173 (+ (slen _lbv7) 1)) (= (slen _lbv10) var_u173)))
        (a!7 (=> (= var_u174 (+ (slen _lbv7) 1)) (= (slen _lbv11) var_u174)))
        (a!8 (=> (= var_u175 (+ (slen _lbv7) 1)) (= (slen _lbv12) var_u175)))
        (a!9 (=> (= var_u176 (+ (slen _lbv7) 1)) (= (slen _lbv13) var_u176)))
        (a!10 (=> (= var_u177 (+ (slen _lbv7) 1)) (= (slen _lbv14) var_u177)))
        (a!11 (=> (= var_u178 (+ (slen Nil) 1)) (= (slen v) var_u178)))
        (a!12 (=> (= var_u180 (+ (slen Nil) 1)) (= (slen v) var_u180))))
    (and (= (slen Nil) 0)
         a!1
         a!2
         (= _lbv1 (- size 1))
         (or (> _lbv2 size1) (= _lbv2 size1))
         (or (> _lbv3 n) (= _lbv3 n))
         (or (> _lbv4 _lbv1) (= _lbv4 _lbv1))
         (or (> _lbv5 s) (= _lbv5 s))
         (or (> _lbv6 size) (= _lbv6 size))
         (> size size1)
         a!3
         a!4
         a!5
         a!6
         a!7
         a!8
         a!9
         a!10
         a!11
         (= var_v4 false)
         a!2
         (or (> _lbv5 s) (= _lbv5 s))
         (= (slen Nil) 0)
         a!12))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (let ((a!1 (forall ((var_u181 Int))
             (=> (= (slen v) var_u181)
                 (and (or (> var_u181 |0|) (= var_u181 |0|)) (= var_u181 size))))))
  (not a!1)))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply Cons  (, _lbv5 ), Nil )
 Finding Already seen tree for apply Cons  (, _lbv5 ), _lbv7 )
 Typechecking apply Cons  (, apply gt_eq_int_gen  (, s ) ), apply goal  (, apply subs  (, size ) ) )
 Against {v:int list | Forall 
 	 
 Key =u Value = int{ 
 	 Impl < (slen)(v) ==(u)
 	 
 	 Conj <c 
 Disj <d  u > 0
 	,   u = 0>d 
 	 , u = size >c  > }}
 Typechecking the Term apply Cons  (, _lbv5 ), _lbv7 )
 Against {v:int list | Forall 
 	 
 Key =u Value = int{ 
 	 Impl < (slen)(v) ==(u)
 	 
 	 Conj <c 
 Disj <d  u > 0
 	,   u = 0>d 
 	 , u = size >c  > }}
 Argument _lbv5 :: {v:int | 
 Disj <d  v > s
 	,   v = s>d } | 
 Disj <d  _lbv5 > s
 	,   _lbv5 = s>d 
 Argument _lbv7 :: {v:int list | Forall 
 	 
 Key =u Value = int{ 
 	 Impl < (slen)(v) ==(u)
 	 
 	 Conj <c 
 Disj <d  u > 0
 	,   u = 0>d 
 	 , u = _lbv1 >c  > }} | Forall 
 	 
 Key =u Value = int{ 
 	 Impl < (slen)(_lbv7) ==(u)
 	 
 	 Conj <c 
 Disj <d  u > 0
 	,   u = 0>d 
 	 , u = _lbv1 >c  > }
 AppType Type {v:int list | Forall 
 	 
 Key =u Value = int{ 
 	 Impl < (u) ==((slen)(_lbv7) + (1))
 	 (slen)(v) ==(u) > }}                                                                                                                                                                                                     
# of Final Z3 expressions 14
 Final solver 
 (declare-sort T334 0)
(declare-fun |0| () Int)
(declare-fun slen (T334) Int)
(declare-fun v () T334)
(declare-fun _lbv7 () T334)
(declare-fun _lbv1 () Int)
(declare-fun s () Int)
(declare-fun _lbv5 () Int)
(declare-fun size () Int)
(declare-fun var_v4 () Bool)
(declare-fun _lbv14 () T334)
(declare-fun _lbv13 () T334)
(declare-fun _lbv12 () T334)
(declare-fun _lbv11 () T334)
(declare-fun _lbv10 () T334)
(declare-fun _lbv9 () T334)
(declare-fun _lbv8 () T334)
(declare-fun size1 () Int)
(declare-fun _lbv6 () Int)
(declare-fun _lbv4 () Int)
(declare-fun n () Int)
(declare-fun _lbv3 () Int)
(declare-fun _lbv2 () Int)
(declare-fun _lbv0 () Bool)
(declare-fun Nil () T334)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u193 Int)
         (var_u192 Int)
         (var_u191 Int)
         (var_u190 Int)
         (var_u189 Int)
         (var_u188 Int)
         (var_u187 Int)
         (var_u186 Int)
         (var_u185 Int)
         (var_u184 Int)
         (var_u183 Int)
         (var_u182 Int))
  (let ((a!1 (= (= _lbv0 true)
                (and (= size |0|) (= (= _lbv0 false) (> size |0|)))))
        (a!2 (= (= var_v4 true)
                (and (= size |0|) (= (= var_v4 false) (> size |0|)))))
        (a!3 (=> (= (slen _lbv7) var_u183)
                 (and (or (> var_u183 |0|) (= var_u183 |0|)) (= var_u183 _lbv1))))
        (a!4 (=> (= var_u184 (+ (slen _lbv7) 1)) (= (slen _lbv8) var_u184)))
        (a!5 (=> (= var_u185 (+ (slen _lbv7) 1)) (= (slen _lbv9) var_u185)))
        (a!6 (=> (= var_u186 (+ (slen _lbv7) 1)) (= (slen _lbv10) var_u186)))
        (a!7 (=> (= var_u187 (+ (slen _lbv7) 1)) (= (slen _lbv11) var_u187)))
        (a!8 (=> (= var_u188 (+ (slen _lbv7) 1)) (= (slen _lbv12) var_u188)))
        (a!9 (=> (= var_u189 (+ (slen _lbv7) 1)) (= (slen _lbv13) var_u189)))
        (a!10 (=> (= var_u190 (+ (slen _lbv7) 1)) (= (slen _lbv14) var_u190)))
        (a!11 (=> (= var_u191 (+ (slen _lbv7) 1)) (= (slen v) var_u191)))
        (a!12 (=> (= (slen _lbv7) var_u192)
                  (and (or (> var_u192 |0|) (= var_u192 |0|))
                       (= var_u192 _lbv1))))
        (a!13 (=> (= var_u193 (+ (slen _lbv7) 1)) (= (slen v) var_u193))))
    (and (= (slen Nil) 0)
         a!1
         a!2
         (= _lbv1 (- size 1))
         (or (> _lbv2 size1) (= _lbv2 size1))
         (or (> _lbv3 n) (= _lbv3 n))
         (or (> _lbv4 _lbv1) (= _lbv4 _lbv1))
         (or (> _lbv5 s) (= _lbv5 s))
         (or (> _lbv6 size) (= _lbv6 size))
         (> size size1)
         a!3
         a!4
         a!5
         a!6
         a!7
         a!8
         a!9
         a!10
         a!11
         (= var_v4 false)
         a!2
         (or (> _lbv5 s) (= _lbv5 s))
         a!12
         a!13))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (let ((a!1 (forall ((var_u194 Int))
             (=> (= (slen v) var_u194)
                 (and (or (> var_u194 |0|) (= var_u194 |0|)) (= var_u194 size))))))
  (not a!1)))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
  Show *************** TypeChecking Succsessful {v:int list | Forall 
 	 
 Key =u Value = int{ 
 	 Impl < (u) ==((slen)(_lbv7) + (1))
 	 (slen)(v) ==(u) > }}
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 let _lbv15 = apply Cons  (, _lbv5 ), _lbv7 )
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 Finding Already seen tree for apply Cons  (, _lbv4 ), Nil )
 Typechecking apply Cons  (, apply gt_eq_int_gen  (, apply subs  (, size ) ) ), Nil )
 Against {v:int list | Forall 
 	 
 Key =u Value = int{ 
 	 Impl < (slen)(v) ==(u)
 	 
 	 Conj <c 
 Disj <d  u > 0
 	,   u = 0>d 
 	 , u = size >c  > }}
 Typechecking the Term apply Cons  (, _lbv4 ), Nil )
 Against {v:int list | Forall 
 	 
 Key =u Value = int{ 
 	 Impl < (slen)(v) ==(u)
 	 
 	 Conj <c 
 Disj <d  u > 0
 	,   u = 0>d 
 	 , u = size >c  > }}
 Argument _lbv4 :: {v:int | 
 Disj <d  v > _lbv1
 	,   v = _lbv1>d } | 
 Disj <d  _lbv4 > _lbv1
 	,   _lbv4 = _lbv1>d 
 Argument Nil :: {v:int list | Forall 
 	 
 Key =u Value = int{ (slen)(v) ==(0) }} | Forall 
 	 
 Key =u Value = int{ (slen)(Nil) ==(0) }
 AppType Type {v:int list | Forall 
 	 
 Key =u Value = int{ 
 	 Impl < (u) ==((slen)(Nil) + (1))
 	 (slen)(v) ==(u) > }}                                                                                                                                                                                    
# of Final Z3 expressions 12
 Final solver 
 (declare-sort T338 0)
(declare-fun |0| () Int)
(declare-fun slen (T338) Int)
(declare-fun v () T338)
(declare-fun Nil () T338)
(declare-fun _lbv1 () Int)
(declare-fun _lbv4 () Int)
(declare-fun size () Int)
(declare-fun var_v4 () Bool)
(declare-fun _lbv15 () T338)
(declare-fun _lbv7 () T338)
(declare-fun _lbv14 () T338)
(declare-fun _lbv13 () T338)
(declare-fun _lbv12 () T338)
(declare-fun _lbv11 () T338)
(declare-fun _lbv10 () T338)
(declare-fun _lbv9 () T338)
(declare-fun _lbv8 () T338)
(declare-fun size1 () Int)
(declare-fun _lbv6 () Int)
(declare-fun s () Int)
(declare-fun _lbv5 () Int)
(declare-fun n () Int)
(declare-fun _lbv3 () Int)
(declare-fun _lbv2 () Int)
(declare-fun _lbv0 () Bool)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u207 Int)
         (var_u206 Int)
         (var_u205 Int)
         (var_u204 Int)
         (var_u203 Int)
         (var_u202 Int)
         (var_u201 Int)
         (var_u200 Int)
         (var_u199 Int)
         (var_u198 Int)
         (var_u197 Int)
         (var_u196 Int)
         (var_u195 Int))
  (let ((a!1 (= (= _lbv0 true)
                (and (= size |0|) (= (= _lbv0 false) (> size |0|)))))
        (a!2 (= (= var_v4 true)
                (and (= size |0|) (= (= var_v4 false) (> size |0|)))))
        (a!3 (=> (= (slen _lbv7) var_u196)
                 (and (or (> var_u196 |0|) (= var_u196 |0|)) (= var_u196 _lbv1))))
        (a!4 (=> (= var_u197 (+ (slen _lbv7) 1)) (= (slen _lbv8) var_u197)))
        (a!5 (=> (= var_u198 (+ (slen _lbv7) 1)) (= (slen _lbv9) var_u198)))
        (a!6 (=> (= var_u199 (+ (slen _lbv7) 1)) (= (slen _lbv10) var_u199)))
        (a!7 (=> (= var_u200 (+ (slen _lbv7) 1)) (= (slen _lbv11) var_u200)))
        (a!8 (=> (= var_u201 (+ (slen _lbv7) 1)) (= (slen _lbv12) var_u201)))
        (a!9 (=> (= var_u202 (+ (slen _lbv7) 1)) (= (slen _lbv13) var_u202)))
        (a!10 (=> (= var_u203 (+ (slen _lbv7) 1)) (= (slen _lbv14) var_u203)))
        (a!11 (=> (= var_u204 (+ (slen _lbv7) 1)) (= (slen _lbv15) var_u204)))
        (a!12 (=> (= var_u205 (+ (slen Nil) 1)) (= (slen v) var_u205)))
        (a!13 (=> (= var_u207 (+ (slen Nil) 1)) (= (slen v) var_u207))))
    (and (= (slen Nil) 0)
         a!1
         a!2
         (= _lbv1 (- size 1))
         (or (> _lbv2 size1) (= _lbv2 size1))
         (or (> _lbv3 n) (= _lbv3 n))
         (or (> _lbv4 _lbv1) (= _lbv4 _lbv1))
         (or (> _lbv5 s) (= _lbv5 s))
         (or (> _lbv6 size) (= _lbv6 size))
         (> size size1)
         a!3
         a!4
         a!5
         a!6
         a!7
         a!8
         a!9
         a!10
         a!11
         a!12
         (= var_v4 false)
         a!2
         (or (> _lbv4 _lbv1) (= _lbv4 _lbv1))
         (= (slen Nil) 0)
         a!13))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (let ((a!1 (forall ((var_u208 Int))
             (=> (= (slen v) var_u208)
                 (and (or (> var_u208 |0|) (= var_u208 |0|)) (= var_u208 size))))))
  (not a!1)))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply Cons  (, _lbv4 ), Nil )
 Finding Already seen tree for apply Cons  (, _lbv4 ), _lbv7 )
 Typechecking apply Cons  (, apply gt_eq_int_gen  (, apply subs  (, size ) ) ), apply goal  (, apply subs  (, size ) ) )
 Against {v:int list | Forall 
 	 
 Key =u Value = int{ 
 	 Impl < (slen)(v) ==(u)
 	 
 	 Conj <c 
 Disj <d  u > 0
 	,   u = 0>d 
 	 , u = size >c  > }}
 Typechecking the Term apply Cons  (, _lbv4 ), _lbv7 )
 Against {v:int list | Forall 
 	 
 Key =u Value = int{ 
 	 Impl < (slen)(v) ==(u)
 	 
 	 Conj <c 
 Disj <d  u > 0
 	,   u = 0>d 
 	 , u = size >c  > }}
 Argument _lbv4 :: {v:int | 
 Disj <d  v > _lbv1
 	,   v = _lbv1>d } | 
 Disj <d  _lbv4 > _lbv1
 	,   _lbv4 = _lbv1>d 
 Argument _lbv7 :: {v:int list | Forall 
 	 
 Key =u Value = int{ 
 	 Impl < (slen)(v) ==(u)
 	 
 	 Conj <c 
 Disj <d  u > 0
 	,   u = 0>d 
 	 , u = _lbv1 >c  > }} | Forall 
 	 
 Key =u Value = int{ 
 	 Impl < (slen)(_lbv7) ==(u)
 	 
 	 Conj <c 
 Disj <d  u > 0
 	,   u = 0>d 
 	 , u = _lbv1 >c  > }
 AppType Type {v:int list | Forall 
 	 
 Key =u Value = int{ 
 	 Impl < (u) ==((slen)(_lbv7) + (1))
 	 (slen)(v) ==(u) > }}                                                                                                                                                                                                     
# of Final Z3 expressions 14
 Final solver 
 (declare-sort T342 0)
(declare-fun |0| () Int)
(declare-fun slen (T342) Int)
(declare-fun v () T342)
(declare-fun _lbv7 () T342)
(declare-fun _lbv1 () Int)
(declare-fun _lbv4 () Int)
(declare-fun size () Int)
(declare-fun var_v4 () Bool)
(declare-fun _lbv15 () T342)
(declare-fun _lbv14 () T342)
(declare-fun _lbv13 () T342)
(declare-fun _lbv12 () T342)
(declare-fun _lbv11 () T342)
(declare-fun _lbv10 () T342)
(declare-fun _lbv9 () T342)
(declare-fun _lbv8 () T342)
(declare-fun size1 () Int)
(declare-fun _lbv6 () Int)
(declare-fun s () Int)
(declare-fun _lbv5 () Int)
(declare-fun n () Int)
(declare-fun _lbv3 () Int)
(declare-fun _lbv2 () Int)
(declare-fun _lbv0 () Bool)
(declare-fun Nil () T342)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u221 Int)
         (var_u220 Int)
         (var_u219 Int)
         (var_u218 Int)
         (var_u217 Int)
         (var_u216 Int)
         (var_u215 Int)
         (var_u214 Int)
         (var_u213 Int)
         (var_u212 Int)
         (var_u211 Int)
         (var_u210 Int)
         (var_u209 Int))
  (let ((a!1 (= (= _lbv0 true)
                (and (= size |0|) (= (= _lbv0 false) (> size |0|)))))
        (a!2 (= (= var_v4 true)
                (and (= size |0|) (= (= var_v4 false) (> size |0|)))))
        (a!3 (=> (= (slen _lbv7) var_u210)
                 (and (or (> var_u210 |0|) (= var_u210 |0|)) (= var_u210 _lbv1))))
        (a!4 (=> (= var_u211 (+ (slen _lbv7) 1)) (= (slen _lbv8) var_u211)))
        (a!5 (=> (= var_u212 (+ (slen _lbv7) 1)) (= (slen _lbv9) var_u212)))
        (a!6 (=> (= var_u213 (+ (slen _lbv7) 1)) (= (slen _lbv10) var_u213)))
        (a!7 (=> (= var_u214 (+ (slen _lbv7) 1)) (= (slen _lbv11) var_u214)))
        (a!8 (=> (= var_u215 (+ (slen _lbv7) 1)) (= (slen _lbv12) var_u215)))
        (a!9 (=> (= var_u216 (+ (slen _lbv7) 1)) (= (slen _lbv13) var_u216)))
        (a!10 (=> (= var_u217 (+ (slen _lbv7) 1)) (= (slen _lbv14) var_u217)))
        (a!11 (=> (= var_u218 (+ (slen _lbv7) 1)) (= (slen _lbv15) var_u218)))
        (a!12 (=> (= var_u219 (+ (slen _lbv7) 1)) (= (slen v) var_u219)))
        (a!13 (=> (= (slen _lbv7) var_u220)
                  (and (or (> var_u220 |0|) (= var_u220 |0|))
                       (= var_u220 _lbv1))))
        (a!14 (=> (= var_u221 (+ (slen _lbv7) 1)) (= (slen v) var_u221))))
    (and (= (slen Nil) 0)
         a!1
         a!2
         (= _lbv1 (- size 1))
         (or (> _lbv2 size1) (= _lbv2 size1))
         (or (> _lbv3 n) (= _lbv3 n))
         (or (> _lbv4 _lbv1) (= _lbv4 _lbv1))
         (or (> _lbv5 s) (= _lbv5 s))
         (or (> _lbv6 size) (= _lbv6 size))
         (> size size1)
         a!3
         a!4
         a!5
         a!6
         a!7
         a!8
         a!9
         a!10
         a!11
         a!12
         (= var_v4 false)
         a!2
         (or (> _lbv4 _lbv1) (= _lbv4 _lbv1))
         a!13
         a!14))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (let ((a!1 (forall ((var_u222 Int))
             (=> (= (slen v) var_u222)
                 (and (or (> var_u222 |0|) (= var_u222 |0|)) (= var_u222 size))))))
  (not a!1)))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
  Show *************** TypeChecking Succsessful {v:int list | Forall 
 	 
 Key =u Value = int{ 
 	 Impl < (u) ==((slen)(_lbv7) + (1))
 	 (slen)(v) ==(u) > }}
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 let _lbv16 = apply Cons  (, _lbv4 ), _lbv7 )
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 Finding Already seen tree for apply Cons  (, _lbv3 ), Nil )
 Typechecking apply Cons  (, apply gt_eq_int_gen  (, n ) ), Nil )
 Against {v:int list | Forall 
 	 
 Key =u Value = int{ 
 	 Impl < (slen)(v) ==(u)
 	 
 	 Conj <c 
 Disj <d  u > 0
 	,   u = 0>d 
 	 , u = size >c  > }}
 Typechecking the Term apply Cons  (, _lbv3 ), Nil )
 Against {v:int list | Forall 
 	 
 Key =u Value = int{ 
 	 Impl < (slen)(v) ==(u)
 	 
 	 Conj <c 
 Disj <d  u > 0
 	,   u = 0>d 
 	 , u = size >c  > }}
 Argument _lbv3 :: {v:int | 
 Disj <d  v > n
 	,   v = n>d } | 
 Disj <d  _lbv3 > n
 	,   _lbv3 = n>d 
 Argument Nil :: {v:int list | Forall 
 	 
 Key =u Value = int{ (slen)(v) ==(0) }} | Forall 
 	 
 Key =u Value = int{ (slen)(Nil) ==(0) }
 AppType Type {v:int list | Forall 
 	 
 Key =u Value = int{ 
 	 Impl < (u) ==((slen)(Nil) + (1))
 	 (slen)(v) ==(u) > }}                                                                                                                                                                                    
# of Final Z3 expressions 12
 Final solver 
 (declare-sort T346 0)
(declare-fun |0| () Int)
(declare-fun slen (T346) Int)
(declare-fun v () T346)
(declare-fun Nil () T346)
(declare-fun n () Int)
(declare-fun _lbv3 () Int)
(declare-fun size () Int)
(declare-fun var_v4 () Bool)
(declare-fun _lbv16 () T346)
(declare-fun _lbv7 () T346)
(declare-fun _lbv15 () T346)
(declare-fun _lbv14 () T346)
(declare-fun _lbv13 () T346)
(declare-fun _lbv12 () T346)
(declare-fun _lbv11 () T346)
(declare-fun _lbv10 () T346)
(declare-fun _lbv9 () T346)
(declare-fun _lbv8 () T346)
(declare-fun _lbv1 () Int)
(declare-fun size1 () Int)
(declare-fun _lbv6 () Int)
(declare-fun s () Int)
(declare-fun _lbv5 () Int)
(declare-fun _lbv4 () Int)
(declare-fun _lbv2 () Int)
(declare-fun _lbv0 () Bool)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u236 Int)
         (var_u235 Int)
         (var_u234 Int)
         (var_u233 Int)
         (var_u232 Int)
         (var_u231 Int)
         (var_u230 Int)
         (var_u229 Int)
         (var_u228 Int)
         (var_u227 Int)
         (var_u226 Int)
         (var_u225 Int)
         (var_u224 Int)
         (var_u223 Int))
  (let ((a!1 (= (= _lbv0 true)
                (and (= size |0|) (= (= _lbv0 false) (> size |0|)))))
        (a!2 (= (= var_v4 true)
                (and (= size |0|) (= (= var_v4 false) (> size |0|)))))
        (a!3 (=> (= (slen _lbv7) var_u224)
                 (and (or (> var_u224 |0|) (= var_u224 |0|)) (= var_u224 _lbv1))))
        (a!4 (=> (= var_u225 (+ (slen _lbv7) 1)) (= (slen _lbv8) var_u225)))
        (a!5 (=> (= var_u226 (+ (slen _lbv7) 1)) (= (slen _lbv9) var_u226)))
        (a!6 (=> (= var_u227 (+ (slen _lbv7) 1)) (= (slen _lbv10) var_u227)))
        (a!7 (=> (= var_u228 (+ (slen _lbv7) 1)) (= (slen _lbv11) var_u228)))
        (a!8 (=> (= var_u229 (+ (slen _lbv7) 1)) (= (slen _lbv12) var_u229)))
        (a!9 (=> (= var_u230 (+ (slen _lbv7) 1)) (= (slen _lbv13) var_u230)))
        (a!10 (=> (= var_u231 (+ (slen _lbv7) 1)) (= (slen _lbv14) var_u231)))
        (a!11 (=> (= var_u232 (+ (slen _lbv7) 1)) (= (slen _lbv15) var_u232)))
        (a!12 (=> (= var_u233 (+ (slen _lbv7) 1)) (= (slen _lbv16) var_u233)))
        (a!13 (=> (= var_u234 (+ (slen Nil) 1)) (= (slen v) var_u234)))
        (a!14 (=> (= var_u236 (+ (slen Nil) 1)) (= (slen v) var_u236))))
    (and (= (slen Nil) 0)
         a!1
         a!2
         (= _lbv1 (- size 1))
         (or (> _lbv2 size1) (= _lbv2 size1))
         (or (> _lbv3 n) (= _lbv3 n))
         (or (> _lbv4 _lbv1) (= _lbv4 _lbv1))
         (or (> _lbv5 s) (= _lbv5 s))
         (or (> _lbv6 size) (= _lbv6 size))
         (> size size1)
         a!3
         a!4
         a!5
         a!6
         a!7
         a!8
         a!9
         a!10
         a!11
         a!12
         a!13
         (= var_v4 false)
         a!2
         (or (> _lbv3 n) (= _lbv3 n))
         (= (slen Nil) 0)
         a!14))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (let ((a!1 (forall ((var_u237 Int))
             (=> (= (slen v) var_u237)
                 (and (or (> var_u237 |0|) (= var_u237 |0|)) (= var_u237 size))))))
  (not a!1)))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply Cons  (, _lbv3 ), Nil )
 Finding Already seen tree for apply Cons  (, _lbv3 ), _lbv7 )
 Typechecking apply Cons  (, apply gt_eq_int_gen  (, n ) ), apply goal  (, apply subs  (, size ) ) )
 Against {v:int list | Forall 
 	 
 Key =u Value = int{ 
 	 Impl < (slen)(v) ==(u)
 	 
 	 Conj <c 
 Disj <d  u > 0
 	,   u = 0>d 
 	 , u = size >c  > }}
 Typechecking the Term apply Cons  (, _lbv3 ), _lbv7 )
 Against {v:int list | Forall 
 	 
 Key =u Value = int{ 
 	 Impl < (slen)(v) ==(u)
 	 
 	 Conj <c 
 Disj <d  u > 0
 	,   u = 0>d 
 	 , u = size >c  > }}
 Argument _lbv3 :: {v:int | 
 Disj <d  v > n
 	,   v = n>d } | 
 Disj <d  _lbv3 > n
 	,   _lbv3 = n>d 
 Argument _lbv7 :: {v:int list | Forall 
 	 
 Key =u Value = int{ 
 	 Impl < (slen)(v) ==(u)
 	 
 	 Conj <c 
 Disj <d  u > 0
 	,   u = 0>d 
 	 , u = _lbv1 >c  > }} | Forall 
 	 
 Key =u Value = int{ 
 	 Impl < (slen)(_lbv7) ==(u)
 	 
 	 Conj <c 
 Disj <d  u > 0
 	,   u = 0>d 
 	 , u = _lbv1 >c  > }
 AppType Type {v:int list | Forall 
 	 
 Key =u Value = int{ 
 	 Impl < (u) ==((slen)(_lbv7) + (1))
 	 (slen)(v) ==(u) > }}                                                                                                                                                                                                     
# of Final Z3 expressions 14
 Final solver 
 (declare-sort T350 0)
(declare-fun |0| () Int)
(declare-fun slen (T350) Int)
(declare-fun v () T350)
(declare-fun _lbv7 () T350)
(declare-fun _lbv1 () Int)
(declare-fun n () Int)
(declare-fun _lbv3 () Int)
(declare-fun size () Int)
(declare-fun var_v4 () Bool)
(declare-fun _lbv16 () T350)
(declare-fun _lbv15 () T350)
(declare-fun _lbv14 () T350)
(declare-fun _lbv13 () T350)
(declare-fun _lbv12 () T350)
(declare-fun _lbv11 () T350)
(declare-fun _lbv10 () T350)
(declare-fun _lbv9 () T350)
(declare-fun _lbv8 () T350)
(declare-fun size1 () Int)
(declare-fun _lbv6 () Int)
(declare-fun s () Int)
(declare-fun _lbv5 () Int)
(declare-fun _lbv4 () Int)
(declare-fun _lbv2 () Int)
(declare-fun _lbv0 () Bool)
(declare-fun Nil () T350)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u251 Int)
         (var_u250 Int)
         (var_u249 Int)
         (var_u248 Int)
         (var_u247 Int)
         (var_u246 Int)
         (var_u245 Int)
         (var_u244 Int)
         (var_u243 Int)
         (var_u242 Int)
         (var_u241 Int)
         (var_u240 Int)
         (var_u239 Int)
         (var_u238 Int))
  (let ((a!1 (= (= _lbv0 true)
                (and (= size |0|) (= (= _lbv0 false) (> size |0|)))))
        (a!2 (= (= var_v4 true)
                (and (= size |0|) (= (= var_v4 false) (> size |0|)))))
        (a!3 (=> (= (slen _lbv7) var_u239)
                 (and (or (> var_u239 |0|) (= var_u239 |0|)) (= var_u239 _lbv1))))
        (a!4 (=> (= var_u240 (+ (slen _lbv7) 1)) (= (slen _lbv8) var_u240)))
        (a!5 (=> (= var_u241 (+ (slen _lbv7) 1)) (= (slen _lbv9) var_u241)))
        (a!6 (=> (= var_u242 (+ (slen _lbv7) 1)) (= (slen _lbv10) var_u242)))
        (a!7 (=> (= var_u243 (+ (slen _lbv7) 1)) (= (slen _lbv11) var_u243)))
        (a!8 (=> (= var_u244 (+ (slen _lbv7) 1)) (= (slen _lbv12) var_u244)))
        (a!9 (=> (= var_u245 (+ (slen _lbv7) 1)) (= (slen _lbv13) var_u245)))
        (a!10 (=> (= var_u246 (+ (slen _lbv7) 1)) (= (slen _lbv14) var_u246)))
        (a!11 (=> (= var_u247 (+ (slen _lbv7) 1)) (= (slen _lbv15) var_u247)))
        (a!12 (=> (= var_u248 (+ (slen _lbv7) 1)) (= (slen _lbv16) var_u248)))
        (a!13 (=> (= var_u249 (+ (slen _lbv7) 1)) (= (slen v) var_u249)))
        (a!14 (=> (= (slen _lbv7) var_u250)
                  (and (or (> var_u250 |0|) (= var_u250 |0|))
                       (= var_u250 _lbv1))))
        (a!15 (=> (= var_u251 (+ (slen _lbv7) 1)) (= (slen v) var_u251))))
    (and (= (slen Nil) 0)
         a!1
         a!2
         (= _lbv1 (- size 1))
         (or (> _lbv2 size1) (= _lbv2 size1))
         (or (> _lbv3 n) (= _lbv3 n))
         (or (> _lbv4 _lbv1) (= _lbv4 _lbv1))
         (or (> _lbv5 s) (= _lbv5 s))
         (or (> _lbv6 size) (= _lbv6 size))
         (> size size1)
         a!3
         a!4
         a!5
         a!6
         a!7
         a!8
         a!9
         a!10
         a!11
         a!12
         a!13
         (= var_v4 false)
         a!2
         (or (> _lbv3 n) (= _lbv3 n))
         a!14
         a!15))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (let ((a!1 (forall ((var_u252 Int))
             (=> (= (slen v) var_u252)
                 (and (or (> var_u252 |0|) (= var_u252 |0|)) (= var_u252 size))))))
  (not a!1)))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
  Show *************** TypeChecking Succsessful {v:int list | Forall 
 	 
 Key =u Value = int{ 
 	 Impl < (u) ==((slen)(_lbv7) + (1))
 	 (slen)(v) ==(u) > }}
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 let _lbv17 = apply Cons  (, _lbv3 ), _lbv7 )
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 Finding Already seen tree for apply Cons  (, _lbv2 ), Nil )
 Typechecking apply Cons  (, apply gt_eq_int_gen  (, size1 ) ), Nil )
 Against {v:int list | Forall 
 	 
 Key =u Value = int{ 
 	 Impl < (slen)(v) ==(u)
 	 
 	 Conj <c 
 Disj <d  u > 0
 	,   u = 0>d 
 	 , u = size >c  > }}
 Typechecking the Term apply Cons  (, _lbv2 ), Nil )
 Against {v:int list | Forall 
 	 
 Key =u Value = int{ 
 	 Impl < (slen)(v) ==(u)
 	 
 	 Conj <c 
 Disj <d  u > 0
 	,   u = 0>d 
 	 , u = size >c  > }}
 Argument _lbv2 :: {v:int | 
 Disj <d  v > size1
 	,   v = size1>d } | 
 Disj <d  _lbv2 > size1
 	,   _lbv2 = size1>d 
 Argument Nil :: {v:int list | Forall 
 	 
 Key =u Value = int{ (slen)(v) ==(0) }} | Forall 
 	 
 Key =u Value = int{ (slen)(Nil) ==(0) }
 AppType Type {v:int list | Forall 
 	 
 Key =u Value = int{ 
 	 Impl < (u) ==((slen)(Nil) + (1))
 	 (slen)(v) ==(u) > }}                                                                                                                                                                                    
# of Final Z3 expressions 12
 Final solver 
 (declare-sort T354 0)
(declare-fun |0| () Int)
(declare-fun slen (T354) Int)
(declare-fun v () T354)
(declare-fun Nil () T354)
(declare-fun size1 () Int)
(declare-fun _lbv2 () Int)
(declare-fun size () Int)
(declare-fun var_v4 () Bool)
(declare-fun _lbv17 () T354)
(declare-fun _lbv7 () T354)
(declare-fun _lbv16 () T354)
(declare-fun _lbv15 () T354)
(declare-fun _lbv14 () T354)
(declare-fun _lbv13 () T354)
(declare-fun _lbv12 () T354)
(declare-fun _lbv11 () T354)
(declare-fun _lbv10 () T354)
(declare-fun _lbv9 () T354)
(declare-fun _lbv8 () T354)
(declare-fun _lbv1 () Int)
(declare-fun _lbv6 () Int)
(declare-fun s () Int)
(declare-fun _lbv5 () Int)
(declare-fun _lbv4 () Int)
(declare-fun n () Int)
(declare-fun _lbv3 () Int)
(declare-fun _lbv0 () Bool)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u267 Int)
         (var_u266 Int)
         (var_u265 Int)
         (var_u264 Int)
         (var_u263 Int)
         (var_u262 Int)
         (var_u261 Int)
         (var_u260 Int)
         (var_u259 Int)
         (var_u258 Int)
         (var_u257 Int)
         (var_u256 Int)
         (var_u255 Int)
         (var_u254 Int)
         (var_u253 Int))
  (let ((a!1 (= (= _lbv0 true)
                (and (= size |0|) (= (= _lbv0 false) (> size |0|)))))
        (a!2 (= (= var_v4 true)
                (and (= size |0|) (= (= var_v4 false) (> size |0|)))))
        (a!3 (=> (= (slen _lbv7) var_u254)
                 (and (or (> var_u254 |0|) (= var_u254 |0|)) (= var_u254 _lbv1))))
        (a!4 (=> (= var_u255 (+ (slen _lbv7) 1)) (= (slen _lbv8) var_u255)))
        (a!5 (=> (= var_u256 (+ (slen _lbv7) 1)) (= (slen _lbv9) var_u256)))
        (a!6 (=> (= var_u257 (+ (slen _lbv7) 1)) (= (slen _lbv10) var_u257)))
        (a!7 (=> (= var_u258 (+ (slen _lbv7) 1)) (= (slen _lbv11) var_u258)))
        (a!8 (=> (= var_u259 (+ (slen _lbv7) 1)) (= (slen _lbv12) var_u259)))
        (a!9 (=> (= var_u260 (+ (slen _lbv7) 1)) (= (slen _lbv13) var_u260)))
        (a!10 (=> (= var_u261 (+ (slen _lbv7) 1)) (= (slen _lbv14) var_u261)))
        (a!11 (=> (= var_u262 (+ (slen _lbv7) 1)) (= (slen _lbv15) var_u262)))
        (a!12 (=> (= var_u263 (+ (slen _lbv7) 1)) (= (slen _lbv16) var_u263)))
        (a!13 (=> (= var_u264 (+ (slen _lbv7) 1)) (= (slen _lbv17) var_u264)))
        (a!14 (=> (= var_u265 (+ (slen Nil) 1)) (= (slen v) var_u265)))
        (a!15 (=> (= var_u267 (+ (slen Nil) 1)) (= (slen v) var_u267))))
    (and (= (slen Nil) 0)
         a!1
         a!2
         (= _lbv1 (- size 1))
         (or (> _lbv2 size1) (= _lbv2 size1))
         (or (> _lbv3 n) (= _lbv3 n))
         (or (> _lbv4 _lbv1) (= _lbv4 _lbv1))
         (or (> _lbv5 s) (= _lbv5 s))
         (or (> _lbv6 size) (= _lbv6 size))
         (> size size1)
         a!3
         a!4
         a!5
         a!6
         a!7
         a!8
         a!9
         a!10
         a!11
         a!12
         a!13
         a!14
         (= var_v4 false)
         a!2
         (or (> _lbv2 size1) (= _lbv2 size1))
         (= (slen Nil) 0)
         a!15))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (let ((a!1 (forall ((var_u268 Int))
             (=> (= (slen v) var_u268)
                 (and (or (> var_u268 |0|) (= var_u268 |0|)) (= var_u268 size))))))
  (not a!1)))

 OutBuf:sat
:sat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Failed SMT $$$$$$$$$$$$$$
  FAILED Typechecking PURE APP For apply Cons  (, _lbv2 ), Nil )
 Finding Already seen tree for apply Cons  (, _lbv2 ), _lbv7 )
 Typechecking apply Cons  (, apply gt_eq_int_gen  (, size1 ) ), apply goal  (, apply subs  (, size ) ) )
 Against {v:int list | Forall 
 	 
 Key =u Value = int{ 
 	 Impl < (slen)(v) ==(u)
 	 
 	 Conj <c 
 Disj <d  u > 0
 	,   u = 0>d 
 	 , u = size >c  > }}
 Typechecking the Term apply Cons  (, _lbv2 ), _lbv7 )
 Against {v:int list | Forall 
 	 
 Key =u Value = int{ 
 	 Impl < (slen)(v) ==(u)
 	 
 	 Conj <c 
 Disj <d  u > 0
 	,   u = 0>d 
 	 , u = size >c  > }}
 Argument _lbv2 :: {v:int | 
 Disj <d  v > size1
 	,   v = size1>d } | 
 Disj <d  _lbv2 > size1
 	,   _lbv2 = size1>d 
 Argument _lbv7 :: {v:int list | Forall 
 	 
 Key =u Value = int{ 
 	 Impl < (slen)(v) ==(u)
 	 
 	 Conj <c 
 Disj <d  u > 0
 	,   u = 0>d 
 	 , u = _lbv1 >c  > }} | Forall 
 	 
 Key =u Value = int{ 
 	 Impl < (slen)(_lbv7) ==(u)
 	 
 	 Conj <c 
 Disj <d  u > 0
 	,   u = 0>d 
 	 , u = _lbv1 >c  > }
 AppType Type {v:int list | Forall 
 	 
 Key =u Value = int{ 
 	 Impl < (u) ==((slen)(_lbv7) + (1))
 	 (slen)(v) ==(u) > }}                                                                                                                                                                                                     
# of Final Z3 expressions 14
 Final solver 
 (declare-sort T358 0)
(declare-fun |0| () Int)
(declare-fun slen (T358) Int)
(declare-fun v () T358)
(declare-fun _lbv7 () T358)
(declare-fun _lbv1 () Int)
(declare-fun size1 () Int)
(declare-fun _lbv2 () Int)
(declare-fun size () Int)
(declare-fun var_v4 () Bool)
(declare-fun _lbv17 () T358)
(declare-fun _lbv16 () T358)
(declare-fun _lbv15 () T358)
(declare-fun _lbv14 () T358)
(declare-fun _lbv13 () T358)
(declare-fun _lbv12 () T358)
(declare-fun _lbv11 () T358)
(declare-fun _lbv10 () T358)
(declare-fun _lbv9 () T358)
(declare-fun _lbv8 () T358)
(declare-fun _lbv6 () Int)
(declare-fun s () Int)
(declare-fun _lbv5 () Int)
(declare-fun _lbv4 () Int)
(declare-fun n () Int)
(declare-fun _lbv3 () Int)
(declare-fun _lbv0 () Bool)
(declare-fun Nil () T358)
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (forall ((var_u283 Int)
         (var_u282 Int)
         (var_u281 Int)
         (var_u280 Int)
         (var_u279 Int)
         (var_u278 Int)
         (var_u277 Int)
         (var_u276 Int)
         (var_u275 Int)
         (var_u274 Int)
         (var_u273 Int)
         (var_u272 Int)
         (var_u271 Int)
         (var_u270 Int)
         (var_u269 Int))
  (let ((a!1 (= (= _lbv0 true)
                (and (= size |0|) (= (= _lbv0 false) (> size |0|)))))
        (a!2 (= (= var_v4 true)
                (and (= size |0|) (= (= var_v4 false) (> size |0|)))))
        (a!3 (=> (= (slen _lbv7) var_u270)
                 (and (or (> var_u270 |0|) (= var_u270 |0|)) (= var_u270 _lbv1))))
        (a!4 (=> (= var_u271 (+ (slen _lbv7) 1)) (= (slen _lbv8) var_u271)))
        (a!5 (=> (= var_u272 (+ (slen _lbv7) 1)) (= (slen _lbv9) var_u272)))
        (a!6 (=> (= var_u273 (+ (slen _lbv7) 1)) (= (slen _lbv10) var_u273)))
        (a!7 (=> (= var_u274 (+ (slen _lbv7) 1)) (= (slen _lbv11) var_u274)))
        (a!8 (=> (= var_u275 (+ (slen _lbv7) 1)) (= (slen _lbv12) var_u275)))
        (a!9 (=> (= var_u276 (+ (slen _lbv7) 1)) (= (slen _lbv13) var_u276)))
        (a!10 (=> (= var_u277 (+ (slen _lbv7) 1)) (= (slen _lbv14) var_u277)))
        (a!11 (=> (= var_u278 (+ (slen _lbv7) 1)) (= (slen _lbv15) var_u278)))
        (a!12 (=> (= var_u279 (+ (slen _lbv7) 1)) (= (slen _lbv16) var_u279)))
        (a!13 (=> (= var_u280 (+ (slen _lbv7) 1)) (= (slen _lbv17) var_u280)))
        (a!14 (=> (= var_u281 (+ (slen _lbv7) 1)) (= (slen v) var_u281)))
        (a!15 (=> (= (slen _lbv7) var_u282)
                  (and (or (> var_u282 |0|) (= var_u282 |0|))
                       (= var_u282 _lbv1))))
        (a!16 (=> (= var_u283 (+ (slen _lbv7) 1)) (= (slen v) var_u283))))
    (and (= (slen Nil) 0)
         a!1
         a!2
         (= _lbv1 (- size 1))
         (or (> _lbv2 size1) (= _lbv2 size1))
         (or (> _lbv3 n) (= _lbv3 n))
         (or (> _lbv4 _lbv1) (= _lbv4 _lbv1))
         (or (> _lbv5 s) (= _lbv5 s))
         (or (> _lbv6 size) (= _lbv6 size))
         (> size size1)
         a!3
         a!4
         a!5
         a!6
         a!7
         a!8
         a!9
         a!10
         a!11
         a!12
         a!13
         a!14
         (= var_v4 false)
         a!2
         (or (> _lbv2 size1) (= _lbv2 size1))
         a!15
         a!16))))
(assert (= |0| 0))
(assert (= |0| 0))
(assert (let ((a!1 (forall ((var_u284 Int))
             (=> (= (slen v) var_u284)
                 (and (or (> var_u284 |0|) (= var_u284 |0|)) (= var_u284 size))))))
  (not a!1)))

 OutBuf:unsat
:unsat

 $$$$$$$$$$$$ Returned $$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$ Success SMT $$$$$$$$$$$$$$
  Show *************** TypeChecking Succsessful {v:int list | Forall 
 	 
 Key =u Value = int{ 
 	 Impl < (u) ==((slen)(_lbv7) + (1))
 	 (slen)(v) ==(u) > }}
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 let _lbv18 = apply Cons  (, _lbv2 ), _lbv7 )
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 Show :: Successfully Synthesisized False Branch 
  Found a If Then Else solution
 *************************
 Success : 
 ************************* : 